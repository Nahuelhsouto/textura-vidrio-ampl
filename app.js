!(function () {
  function t(e) {
    if (e)
      return (function (e) {
        for (var n in t.prototype) e[n] = t.prototype[n];
        return e;
      })(e);
  }
  function e() {
    (this._events = this._events || {}),
      (this._maxListeners = this._maxListeners || void 0);
  }
  function n(t) {
    return "function" == typeof t;
  }
  function i(t) {
    return "object" == typeof t && null !== t;
  }
  function r(t) {
    return void 0 === t;
  }
  function o() {
    throw new Error("setTimeout has not been defined");
  }
  function a() {
    throw new Error("clearTimeout has not been defined");
  }
  function s(t) {
    if (M === setTimeout) return setTimeout(t, 0);
    if ((M === o || !M) && setTimeout)
      return (M = setTimeout), setTimeout(t, 0);
    try {
      return M(t, 0);
    } catch (e) {
      try {
        return M.call(null, t, 0);
      } catch (e) {
        return M.call(this, t, 0);
      }
    }
  }
  function c() {
    R &&
      A &&
      ((R = !1), A.length ? (L = A.concat(L)) : (P = -1), L.length && l());
  }
  function l() {
    if (!R) {
      var t = s(c);
      R = !0;
      for (var e = L.length; e; ) {
        for (A = L, L = []; ++P < e; ) A && A[P].run();
        (P = -1), (e = L.length);
      }
      (A = null),
        (R = !1),
        (function (t) {
          if (E === clearTimeout) return clearTimeout(t);
          if ((E === a || !E) && clearTimeout)
            return (E = clearTimeout), clearTimeout(t);
          try {
            E(t);
          } catch (e) {
            try {
              return E.call(null, t);
            } catch (e) {
              return E.call(this, t);
            }
          }
        })(t);
    }
  }
  function u(t, e) {
    (this.fun = t), (this.array = e);
  }
  function h() {}
  function p(t) {
    if (!(this instanceof p)) return new p(t);
    (this.running = !1),
      (this.last = I()),
      (this._frame = 0),
      (this._tick = this.tick.bind(this)),
      t && this.on("tick", t);
  }
  function d(t, e) {
    var n = z(getComputedStyle(t).getPropertyValue(e));
    return n[0] * f(n[1], t);
  }
  function f(t, e) {
    switch (
      ((e = e || document.body),
      (t = (t || "px").trim().toLowerCase()),
      (e !== window && e !== document) || (e = document.body),
      t)
    ) {
      case "%":
        return e.clientHeight / 100;
      case "ch":
      case "ex":
        return (function (t, e) {
          var n = document.createElement("div");
          (n.style["font-size"] = "128" + t), e.appendChild(n);
          var i = d(n, "font-size") / 128;
          return e.removeChild(n), i;
        })(t, e);
      case "em":
        return d(e, "font-size");
      case "rem":
        return d(document.body, "font-size");
      case "vw":
        return window.innerWidth / 100;
      case "vh":
        return window.innerHeight / 100;
      case "vmin":
        return Math.min(window.innerWidth, window.innerHeight) / 100;
      case "vmax":
        return Math.max(window.innerWidth, window.innerHeight) / 100;
      case "in":
        return F;
      case "cm":
        return F / 2.54;
      case "mm":
        return F / 25.4;
      case "pt":
        return F / 72;
      case "pc":
        return F / 6;
    }
    return 1;
  }
  function m(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function g(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function v(t) {
    return t && t.__esModule ? t : { default: t };
  }
  var y = { exports: {} };
  (y.exports = t),
    (t.prototype.on = t.prototype.addEventListener =
      function (t, e) {
        return (
          (this._callbacks = this._callbacks || {}),
          (this._callbacks["$" + t] = this._callbacks["$" + t] || []).push(e),
          this
        );
      }),
    (t.prototype.once = function (t, e) {
      function n() {
        this.off(t, n), e.apply(this, arguments);
      }
      return (n.fn = e), this.on(t, n), this;
    }),
    (t.prototype.off =
      t.prototype.removeListener =
      t.prototype.removeAllListeners =
      t.prototype.removeEventListener =
        function (t, e) {
          if (
            ((this._callbacks = this._callbacks || {}), 0 == arguments.length)
          )
            return (this._callbacks = {}), this;
          var n = this._callbacks["$" + t];
          if (!n) return this;
          if (1 == arguments.length)
            return delete this._callbacks["$" + t], this;
          for (var i, r = 0; r < n.length; r++)
            if ((i = n[r]) === e || i.fn === e) {
              n.splice(r, 1);
              break;
            }
          return this;
        }),
    (t.prototype.emit = function (t) {
      this._callbacks = this._callbacks || {};
      var e = [].slice.call(arguments, 1),
        n = this._callbacks["$" + t];
      if (n)
        for (var i = 0, r = (n = n.slice(0)).length; i < r; ++i)
          n[i].apply(this, e);
      return this;
    }),
    (t.prototype.listeners = function (t) {
      return (
        (this._callbacks = this._callbacks || {}),
        this._callbacks["$" + t] || []
      );
    }),
    (t.prototype.hasListeners = function (t) {
      return !!this.listeners(t).length;
    });
  var x = {},
    b = x;
  (y = y.exports)(b),
    (b.debounceDelay = 50),
    (b.onGlobalResize = function () {
      (this.width = window.innerWidth),
        (this.height = window.innerHeight),
        (this.halfWidth = 0.5 * this.width),
        (this.halfHeight = 0.5 * this.height),
        this.applyResize(),
        this.debounceDelay > 0
          ? this.debounceResize()
          : this.applyResizeDebounce();
    }),
    (b.applyResizeDebounce = function () {
      this.emit("resizeDebounce");
    }),
    (b.applyResize = function () {
      this.emit("resize");
    }),
    (b.addListener = function (t, e) {
      this.on(e ? "resize" : "resizeDebounce", t);
    }),
    (b.removeListener = function (t) {
      t && (this.off("resize", t), this.off("resizeDebounce", t));
    }),
    (b.debounceResize = (function (t, e, n) {
      function i() {
        var l = Date.now() - s;
        l < e && l >= 0
          ? (r = setTimeout(i, e - l))
          : ((r = null), n || ((c = t.apply(a, o)), (a = o = null)));
      }
      var r, o, a, s, c;
      null == e && (e = 100);
      var l = function () {
        (a = this), (o = arguments), (s = Date.now());
        var l = n && !r;
        return (
          r || (r = setTimeout(i, e)),
          l && ((c = t.apply(a, o)), (a = o = null)),
          c
        );
      };
      return (
        (l.clear = function () {
          r && (clearTimeout(r), (r = null));
        }),
        (l.flush = function () {
          r &&
            ((c = t.apply(a, o)), (a = o = null), clearTimeout(r), (r = null));
        }),
        l
      );
    })(b.applyResizeDebounce.bind(b), b.debounceDelay)),
    b.onGlobalResize(),
    window.addEventListener("resize", b.onGlobalResize.bind(b));
  var _ = {};
  (_ = e),
    (e.EventEmitter = e),
    (e.prototype._events = void 0),
    (e.prototype._maxListeners = void 0),
    (e.defaultMaxListeners = 10),
    (e.prototype.setMaxListeners = function (t) {
      if ("number" != typeof t || t < 0 || isNaN(t))
        throw TypeError("n must be a positive number");
      return (this._maxListeners = t), this;
    }),
    (e.prototype.emit = function (t) {
      var e, o, a, s, c, l;
      if (
        (this._events || (this._events = {}),
        "error" === t &&
          (!this._events.error ||
            (i(this._events.error) && !this._events.error.length)))
      ) {
        if ((e = arguments[1]) instanceof Error) throw e;
        var u = new Error('Uncaught, unspecified "error" event. (' + e + ")");
        throw ((u.context = e), u);
      }
      if (((o = this._events[t]), r(o))) return !1;
      if (n(o))
        switch (arguments.length) {
          case 1:
            o.call(this);
            break;
          case 2:
            o.call(this, arguments[1]);
            break;
          case 3:
            o.call(this, arguments[1], arguments[2]);
            break;
          default:
            (s = Array.prototype.slice.call(arguments, 1)), o.apply(this, s);
        }
      else if (i(o))
        for (
          s = Array.prototype.slice.call(arguments, 1),
            a = (l = o.slice()).length,
            c = 0;
          c < a;
          c++
        )
          l[c].apply(this, s);
      return !0;
    }),
    (e.prototype.addListener = function (t, o) {
      var a;
      if (!n(o)) throw TypeError("listener must be a function");
      return (
        this._events || (this._events = {}),
        this._events.newListener &&
          this.emit("newListener", t, n(o.listener) ? o.listener : o),
        this._events[t]
          ? i(this._events[t])
            ? this._events[t].push(o)
            : (this._events[t] = [this._events[t], o])
          : (this._events[t] = o),
        i(this._events[t]) &&
          !this._events[t].warned &&
          (a = r(this._maxListeners)
            ? e.defaultMaxListeners
            : this._maxListeners) &&
          a > 0 &&
          this._events[t].length > a &&
          ((this._events[t].warned = !0),
          console.error(
            "(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",
            this._events[t].length
          ),
          "function" == typeof console.trace && console.trace()),
        this
      );
    }),
    (e.prototype.on = e.prototype.addListener),
    (e.prototype.once = function (t, e) {
      function i() {
        this.removeListener(t, i), r || ((r = !0), e.apply(this, arguments));
      }
      if (!n(e)) throw TypeError("listener must be a function");
      var r = !1;
      return (i.listener = e), this.on(t, i), this;
    }),
    (e.prototype.removeListener = function (t, e) {
      var r, o, a, s;
      if (!n(e)) throw TypeError("listener must be a function");
      if (!this._events || !this._events[t]) return this;
      if (
        ((r = this._events[t]),
        (a = r.length),
        (o = -1),
        r === e || (n(r.listener) && r.listener === e))
      )
        delete this._events[t],
          this._events.removeListener && this.emit("removeListener", t, e);
      else if (i(r)) {
        for (s = a; s-- > 0; )
          if (r[s] === e || (r[s].listener && r[s].listener === e)) {
            o = s;
            break;
          }
        if (o < 0) return this;
        1 === r.length
          ? ((r.length = 0), delete this._events[t])
          : r.splice(o, 1),
          this._events.removeListener && this.emit("removeListener", t, e);
      }
      return this;
    }),
    (e.prototype.removeAllListeners = function (t) {
      var e, i;
      if (!this._events) return this;
      if (!this._events.removeListener)
        return (
          0 === arguments.length
            ? (this._events = {})
            : this._events[t] && delete this._events[t],
          this
        );
      if (0 === arguments.length) {
        for (e in this._events)
          "removeListener" !== e && this.removeAllListeners(e);
        return (
          this.removeAllListeners("removeListener"), (this._events = {}), this
        );
      }
      if (((i = this._events[t]), n(i))) this.removeListener(t, i);
      else if (i) for (; i.length; ) this.removeListener(t, i[i.length - 1]);
      return delete this._events[t], this;
    }),
    (e.prototype.listeners = function (t) {
      return this._events && this._events[t]
        ? n(this._events[t])
          ? [this._events[t]]
          : this._events[t].slice()
        : [];
    }),
    (e.prototype.listenerCount = function (t) {
      if (this._events) {
        var e = this._events[t];
        if (n(e)) return 1;
        if (e) return e.length;
      }
      return 0;
    }),
    (e.listenerCount = function (t, e) {
      return t.listenerCount(e);
    });
  var w = {};
  w =
    "function" == typeof Object.create
      ? function (t, e) {
          (t.super_ = e),
            (t.prototype = Object.create(e.prototype, {
              constructor: {
                value: t,
                enumerable: !1,
                writable: !0,
                configurable: !0,
              },
            }));
        }
      : function (t, e) {
          t.super_ = e;
          var n = function () {};
          (n.prototype = e.prototype),
            (t.prototype = new n()),
            (t.prototype.constructor = t);
        };
  var M,
    E,
    T = {},
    S = (T = {});
  !(function () {
    try {
      M = "function" == typeof setTimeout ? setTimeout : o;
    } catch (t) {
      M = o;
    }
    try {
      E = "function" == typeof clearTimeout ? clearTimeout : a;
    } catch (t) {
      E = a;
    }
  })();
  var A,
    L = [],
    R = !1,
    P = -1;
  (S.nextTick = function (t) {
    var e = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
    L.push(new u(t, e)), 1 !== L.length || R || s(l);
  }),
    (u.prototype.run = function () {
      this.fun.apply(null, this.array);
    }),
    (S.title = "browser"),
    (S.browser = !0),
    (S.env = {}),
    (S.argv = []),
    (S.version = ""),
    (S.versions = {}),
    (S.on = h),
    (S.addListener = h),
    (S.once = h),
    (S.off = h),
    (S.removeListener = h),
    (S.removeAllListeners = h),
    (S.emit = h),
    (S.prependListener = h),
    (S.prependOnceListener = h),
    (S.listeners = function (t) {
      return [];
    }),
    (S.binding = function (t) {
      throw new Error("process.binding is not supported");
    }),
    (S.cwd = function () {
      return "/";
    }),
    (S.chdir = function (t) {
      throw new Error("process.chdir is not supported");
    }),
    (S.umask = function () {
      return 0;
    });
  var C = {};
  (function (t) {
    (function () {
      var e, n, i, r, o, a;
      "undefined" != typeof performance &&
      null !== performance &&
      performance.now
        ? (C = function () {
            return performance.now();
          })
        : void 0 !== t && null !== t && t.hrtime
        ? ((C = function () {
            return (e() - o) / 1e6;
          }),
          (n = t.hrtime),
          (r = (e = function () {
            var t;
            return 1e9 * (t = n())[0] + t[1];
          })()),
          (a = 1e9 * t.uptime()),
          (o = r - a))
        : Date.now
        ? ((C = function () {
            return Date.now() - i;
          }),
          (i = Date.now()))
        : ((C = function () {
            return new Date().getTime() - i;
          }),
          (i = new Date().getTime()));
    }.call(this));
  }.call(this, T));
  var O = {};
  (function (t) {
    for (
      var e = "undefined" == typeof window ? t : window,
        n = ["moz", "webkit"],
        i = "AnimationFrame",
        r = e["request" + i],
        o = e["cancel" + i] || e["cancelRequest" + i],
        a = 0;
      !r && a < n.length;
      a++
    )
      (r = e[n[a] + "Request" + i]),
        (o = e[n[a] + "Cancel" + i] || e[n[a] + "CancelRequest" + i]);
    if (!r || !o) {
      var s = 0,
        c = 0,
        l = [];
      (r = function (t) {
        if (0 === l.length) {
          var e = C(),
            n = Math.max(0, 1e3 / 60 - (e - s));
          (s = n + e),
            setTimeout(function () {
              var t = l.slice(0);
              l.length = 0;
              for (var e = 0; e < t.length; e++)
                if (!t[e].cancelled)
                  try {
                    t[e].callback(s);
                  } catch (t) {
                    setTimeout(function () {
                      throw t;
                    }, 0);
                  }
            }, Math.round(n));
        }
        return l.push({ handle: ++c, callback: t, cancelled: !1 }), c;
      }),
        (o = function (t) {
          for (var e = 0; e < l.length; e++)
            l[e].handle === t && (l[e].cancelled = !0);
        });
    }
    ((O = function (t) {
      return r.call(e, t);
    }).cancel = function () {
      o.apply(e, arguments);
    }),
      (O.polyfill = function (t) {
        t || (t = e),
          (t.requestAnimationFrame = r),
          (t.cancelAnimationFrame = o);
      });
  }.call(
    this,
    "undefined" != typeof global
      ? global
      : "undefined" != typeof self
      ? self
      : "undefined" != typeof window
      ? window
      : {}
  ));
  var I = {};
  (function (t) {
    I =
      t.performance && t.performance.now
        ? function () {
            return performance.now();
          }
        : Date.now ||
          function () {
            return +new Date();
          };
  }.call(
    this,
    "undefined" != typeof global
      ? global
      : "undefined" != typeof self
      ? self
      : "undefined" != typeof window
      ? window
      : {}
  ));
  var D = {};
  (D = p),
    w(p, _.EventEmitter),
    (p.prototype.start = function () {
      if (!this.running)
        return (
          (this.running = !0),
          (this.last = I()),
          (this._frame = O(this._tick)),
          this
        );
    }),
    (p.prototype.stop = function () {
      return (
        (this.running = !1),
        0 !== this._frame && O.cancel(this._frame),
        (this._frame = 0),
        this
      );
    }),
    (p.prototype.tick = function () {
      this._frame = O(this._tick);
      var t = I(),
        e = t - this.last;
      this.emit("tick", e), (this.last = t);
    });
  var U = { exports: {} };
  !(function (t, e) {
    "object" == typeof U.exports
      ? e(U.exports)
      : "function" == typeof define && define.amd
      ? define(["exports"], e)
      : e((t.THREE = t.THREE || {}));
  })(this, function (t) {
    "use strict";
    function e() {}
    function n(t, e) {
      (this.x = t || 0), (this.y = e || 0);
    }
    function i() {
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
        arguments.length > 0 &&
          console.error(
            "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
          );
    }
    function r(t, e, n, i) {
      (this._x = t || 0),
        (this._y = e || 0),
        (this._z = n || 0),
        (this._w = void 0 !== i ? i : 1);
    }
    function o(t, e, n) {
      (this.x = t || 0), (this.y = e || 0), (this.z = n || 0);
    }
    function a() {
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
        arguments.length > 0 &&
          console.error(
            "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
          );
    }
    function s(t, e, i, r, o, c, l, u, h, p) {
      Object.defineProperty(this, "id", { value: ca++ }),
        (this.uuid = sa.generateUUID()),
        (this.name = ""),
        (this.image = void 0 !== t ? t : s.DEFAULT_IMAGE),
        (this.mipmaps = []),
        (this.mapping = void 0 !== e ? e : s.DEFAULT_MAPPING),
        (this.wrapS = void 0 !== i ? i : uo),
        (this.wrapT = void 0 !== r ? r : uo),
        (this.magFilter = void 0 !== o ? o : go),
        (this.minFilter = void 0 !== c ? c : yo),
        (this.anisotropy = void 0 !== h ? h : 1),
        (this.format = void 0 !== l ? l : Io),
        (this.type = void 0 !== u ? u : xo),
        (this.offset = new n(0, 0)),
        (this.repeat = new n(1, 1)),
        (this.center = new n(0, 0)),
        (this.rotation = 0),
        (this.matrixAutoUpdate = !0),
        (this.matrix = new a()),
        (this.generateMipmaps = !0),
        (this.premultiplyAlpha = !1),
        (this.flipY = !0),
        (this.unpackAlignment = 4),
        (this.encoding = void 0 !== p ? p : Qo),
        (this.version = 0),
        (this.onUpdate = null);
    }
    function c(t, e, n, i) {
      (this.x = t || 0),
        (this.y = e || 0),
        (this.z = n || 0),
        (this.w = void 0 !== i ? i : 1);
    }
    function l(t, e, n) {
      (this.uuid = sa.generateUUID()),
        (this.width = t),
        (this.height = e),
        (this.scissor = new c(0, 0, t, e)),
        (this.scissorTest = !1),
        (this.viewport = new c(0, 0, t, e)),
        void 0 === (n = n || {}).minFilter && (n.minFilter = go),
        (this.texture = new s(
          void 0,
          void 0,
          n.wrapS,
          n.wrapT,
          n.magFilter,
          n.minFilter,
          n.format,
          n.type,
          n.anisotropy,
          n.encoding
        )),
        (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
        (this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer),
        (this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null);
    }
    function u(t, e, n) {
      l.call(this, t, e, n),
        (this.activeCubeFace = 0),
        (this.activeMipMapLevel = 0);
    }
    function h(t, e, n, i, r, o, a, c, l, u, h, p) {
      s.call(this, null, o, a, c, l, u, i, r, h, p),
        (this.image = { data: t, width: e, height: n }),
        (this.magFilter = void 0 !== l ? l : po),
        (this.minFilter = void 0 !== u ? u : po),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.unpackAlignment = 1);
    }
    function p(t, e, n, i, r, o, a, c, l, u) {
      s.call(
        this,
        (t = void 0 !== t ? t : []),
        (e = void 0 !== e ? e : no),
        n,
        i,
        r,
        o,
        a,
        c,
        l,
        u
      ),
        (this.flipY = !1);
    }
    function d() {
      (this.seq = []), (this.map = {});
    }
    function f(t, e, n) {
      var i = t[0];
      if (i <= 0 || i > 0) return t;
      var r = e * n,
        o = ha[r];
      if ((void 0 === o && ((o = new Float32Array(r)), (ha[r] = o)), 0 !== e)) {
        i.toArray(o, 0);
        for (var a = 1, s = 0; a !== e; ++a) (s += n), t[a].toArray(o, s);
      }
      return o;
    }
    function m(t, e) {
      var n = pa[e];
      void 0 === n && ((n = new Int32Array(e)), (pa[e] = n));
      for (var i = 0; i !== e; ++i) n[i] = t.allocTextureUnit();
      return n;
    }
    function g(t, e) {
      t.uniform1f(this.addr, e);
    }
    function v(t, e) {
      t.uniform1i(this.addr, e);
    }
    function y(t, e) {
      void 0 === e.x
        ? t.uniform2fv(this.addr, e)
        : t.uniform2f(this.addr, e.x, e.y);
    }
    function x(t, e) {
      void 0 !== e.x
        ? t.uniform3f(this.addr, e.x, e.y, e.z)
        : void 0 !== e.r
        ? t.uniform3f(this.addr, e.r, e.g, e.b)
        : t.uniform3fv(this.addr, e);
    }
    function b(t, e) {
      void 0 === e.x
        ? t.uniform4fv(this.addr, e)
        : t.uniform4f(this.addr, e.x, e.y, e.z, e.w);
    }
    function _(t, e) {
      t.uniformMatrix2fv(this.addr, !1, e.elements || e);
    }
    function w(t, e) {
      void 0 === e.elements
        ? t.uniformMatrix3fv(this.addr, !1, e)
        : (fa.set(e.elements), t.uniformMatrix3fv(this.addr, !1, fa));
    }
    function M(t, e) {
      void 0 === e.elements
        ? t.uniformMatrix4fv(this.addr, !1, e)
        : (da.set(e.elements), t.uniformMatrix4fv(this.addr, !1, da));
    }
    function E(t, e, n) {
      var i = n.allocTextureUnit();
      t.uniform1i(this.addr, i), n.setTexture2D(e || la, i);
    }
    function T(t, e, n) {
      var i = n.allocTextureUnit();
      t.uniform1i(this.addr, i), n.setTextureCube(e || ua, i);
    }
    function S(t, e) {
      t.uniform2iv(this.addr, e);
    }
    function A(t, e) {
      t.uniform3iv(this.addr, e);
    }
    function L(t, e) {
      t.uniform4iv(this.addr, e);
    }
    function R(t, e) {
      t.uniform1fv(this.addr, e);
    }
    function P(t, e) {
      t.uniform1iv(this.addr, e);
    }
    function C(t, e) {
      t.uniform2fv(this.addr, f(e, this.size, 2));
    }
    function O(t, e) {
      t.uniform3fv(this.addr, f(e, this.size, 3));
    }
    function I(t, e) {
      t.uniform4fv(this.addr, f(e, this.size, 4));
    }
    function D(t, e) {
      t.uniformMatrix2fv(this.addr, !1, f(e, this.size, 4));
    }
    function U(t, e) {
      t.uniformMatrix3fv(this.addr, !1, f(e, this.size, 9));
    }
    function N(t, e) {
      t.uniformMatrix4fv(this.addr, !1, f(e, this.size, 16));
    }
    function z(t, e, n) {
      var i = e.length,
        r = m(n, i);
      t.uniform1iv(this.addr, r);
      for (var o = 0; o !== i; ++o) n.setTexture2D(e[o] || la, r[o]);
    }
    function k(t, e, n) {
      var i = e.length,
        r = m(n, i);
      t.uniform1iv(this.addr, r);
      for (var o = 0; o !== i; ++o) n.setTextureCube(e[o] || ua, r[o]);
    }
    function F(t, e, n) {
      (this.id = t),
        (this.addr = n),
        (this.setValue = (function (t) {
          switch (e.type) {
            case 5126:
              return g;
            case 35664:
              return y;
            case 35665:
              return x;
            case 35666:
              return b;
            case 35674:
              return _;
            case 35675:
              return w;
            case 35676:
              return M;
            case 35678:
            case 36198:
              return E;
            case 35680:
              return T;
            case 5124:
            case 35670:
              return v;
            case 35667:
            case 35671:
              return S;
            case 35668:
            case 35672:
              return A;
            case 35669:
            case 35673:
              return L;
          }
        })());
    }
    function B(t, e, n) {
      (this.id = t),
        (this.addr = n),
        (this.size = e.size),
        (this.setValue = (function (t) {
          switch (e.type) {
            case 5126:
              return R;
            case 35664:
              return C;
            case 35665:
              return O;
            case 35666:
              return I;
            case 35674:
              return D;
            case 35675:
              return U;
            case 35676:
              return N;
            case 35678:
              return z;
            case 35680:
              return k;
            case 5124:
            case 35670:
              return P;
            case 35667:
            case 35671:
              return S;
            case 35668:
            case 35672:
              return A;
            case 35669:
            case 35673:
              return L;
          }
        })());
    }
    function H(t) {
      (this.id = t), d.call(this);
    }
    function j(t, e) {
      t.seq.push(e), (t.map[e.id] = e);
    }
    function G(t, e, n) {
      var i = t.name,
        r = i.length;
      for (ma.lastIndex = 0; ; ) {
        var o = ma.exec(i),
          a = ma.lastIndex,
          s = o[1],
          c = "]" === o[2],
          l = o[3];
        if ((c && (s |= 0), void 0 === l || ("[" === l && a + 2 === r))) {
          j(n, void 0 === l ? new F(s, t, e) : new B(s, t, e));
          break;
        }
        var u = n.map[s];
        void 0 === u && j(n, (u = new H(s))), (n = u);
      }
    }
    function V(t, e, n) {
      d.call(this), (this.renderer = n);
      for (
        var i = t.getProgramParameter(e, t.ACTIVE_UNIFORMS), r = 0;
        r < i;
        ++r
      ) {
        var o = t.getActiveUniform(e, r),
          a = o.name;
        G(o, t.getUniformLocation(e, a), this);
      }
    }
    function W(t, e, n) {
      return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n);
    }
    function X(t, e) {
      (this.min = void 0 !== t ? t : new n(1 / 0, 1 / 0)),
        (this.max = void 0 !== e ? e : new n(-1 / 0, -1 / 0));
    }
    function Y(t, e, i, r, a) {
      var s, c, l, u, h, p, d, f;
      this.render = function (t, m, g, v) {
        if (0 !== t.length) {
          var y = new o(),
            x = v.w / v.z,
            b = 0.5 * v.z,
            _ = 0.5 * v.w,
            w = 16 / v.w,
            M = new n(w * x, w),
            E = new o(1, 1, 0),
            T = new n(1, 1),
            S = new X();
          S.min.set(v.x, v.y),
            S.max.set(v.x + (v.z - 16), v.y + (v.w - 16)),
            void 0 === u &&
              (function () {
                var t = new Float32Array([
                    -1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1,
                  ]),
                  n = new Uint16Array([0, 1, 2, 0, 2, 3]);
                (s = e.createBuffer()),
                  (c = e.createBuffer()),
                  e.bindBuffer(e.ARRAY_BUFFER, s),
                  e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW),
                  e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, c),
                  e.bufferData(e.ELEMENT_ARRAY_BUFFER, n, e.STATIC_DRAW),
                  (d = e.createTexture()),
                  (f = e.createTexture()),
                  i.bindTexture(e.TEXTURE_2D, d),
                  e.texImage2D(
                    e.TEXTURE_2D,
                    0,
                    e.RGB,
                    16,
                    16,
                    0,
                    e.RGB,
                    e.UNSIGNED_BYTE,
                    null
                  ),
                  e.texParameteri(
                    e.TEXTURE_2D,
                    e.TEXTURE_WRAP_S,
                    e.CLAMP_TO_EDGE
                  ),
                  e.texParameteri(
                    e.TEXTURE_2D,
                    e.TEXTURE_WRAP_T,
                    e.CLAMP_TO_EDGE
                  ),
                  e.texParameteri(
                    e.TEXTURE_2D,
                    e.TEXTURE_MAG_FILTER,
                    e.NEAREST
                  ),
                  e.texParameteri(
                    e.TEXTURE_2D,
                    e.TEXTURE_MIN_FILTER,
                    e.NEAREST
                  ),
                  i.bindTexture(e.TEXTURE_2D, f),
                  e.texImage2D(
                    e.TEXTURE_2D,
                    0,
                    e.RGBA,
                    16,
                    16,
                    0,
                    e.RGBA,
                    e.UNSIGNED_BYTE,
                    null
                  ),
                  e.texParameteri(
                    e.TEXTURE_2D,
                    e.TEXTURE_WRAP_S,
                    e.CLAMP_TO_EDGE
                  ),
                  e.texParameteri(
                    e.TEXTURE_2D,
                    e.TEXTURE_WRAP_T,
                    e.CLAMP_TO_EDGE
                  ),
                  e.texParameteri(
                    e.TEXTURE_2D,
                    e.TEXTURE_MAG_FILTER,
                    e.NEAREST
                  ),
                  e.texParameteri(
                    e.TEXTURE_2D,
                    e.TEXTURE_MIN_FILTER,
                    e.NEAREST
                  ),
                  (l = {
                    vertexShader: [
                      "uniform lowp int renderType;",
                      "uniform vec3 screenPosition;",
                      "uniform vec2 scale;",
                      "uniform float rotation;",
                      "uniform sampler2D occlusionMap;",
                      "attribute vec2 position;",
                      "attribute vec2 uv;",
                      "varying vec2 vUV;",
                      "varying float vVisibility;",
                      "void main() {",
                      "\tvUV = uv;",
                      "\tvec2 pos = position;",
                      "\tif ( renderType == 2 ) {",
                      "\t\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
                      "\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
                      "\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
                      "\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
                      "\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
                      "\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
                      "\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
                      "\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
                      "\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",
                      "\t\tvVisibility =        visibility.r / 9.0;",
                      "\t\tvVisibility *= 1.0 - visibility.g / 9.0;",
                      "\t\tvVisibility *=       visibility.b / 9.0;",
                      "\t\tvVisibility *= 1.0 - visibility.a / 9.0;",
                      "\t\tpos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
                      "\t\tpos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",
                      "\t}",
                      "\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",
                      "}",
                    ].join("\n"),
                    fragmentShader: [
                      "uniform lowp int renderType;",
                      "uniform sampler2D map;",
                      "uniform float opacity;",
                      "uniform vec3 color;",
                      "varying vec2 vUV;",
                      "varying float vVisibility;",
                      "void main() {",
                      "\tif ( renderType == 0 ) {",
                      "\t\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",
                      "\t} else if ( renderType == 1 ) {",
                      "\t\tgl_FragColor = texture2D( map, vUV );",
                      "\t} else {",
                      "\t\tvec4 texture = texture2D( map, vUV );",
                      "\t\ttexture.a *= opacity * vVisibility;",
                      "\t\tgl_FragColor = texture;",
                      "\t\tgl_FragColor.rgb *= color;",
                      "\t}",
                      "}",
                    ].join("\n"),
                  }),
                  (u = (function (t) {
                    var n = e.createProgram(),
                      i = e.createShader(e.FRAGMENT_SHADER),
                      r = e.createShader(e.VERTEX_SHADER),
                      o = "precision " + a.precision + " float;\n";
                    return (
                      e.shaderSource(i, o + t.fragmentShader),
                      e.shaderSource(r, o + t.vertexShader),
                      e.compileShader(i),
                      e.compileShader(r),
                      e.attachShader(n, i),
                      e.attachShader(n, r),
                      e.linkProgram(n),
                      n
                    );
                  })(l)),
                  (h = {
                    vertex: e.getAttribLocation(u, "position"),
                    uv: e.getAttribLocation(u, "uv"),
                  }),
                  (p = {
                    renderType: e.getUniformLocation(u, "renderType"),
                    map: e.getUniformLocation(u, "map"),
                    occlusionMap: e.getUniformLocation(u, "occlusionMap"),
                    opacity: e.getUniformLocation(u, "opacity"),
                    color: e.getUniformLocation(u, "color"),
                    scale: e.getUniformLocation(u, "scale"),
                    rotation: e.getUniformLocation(u, "rotation"),
                    screenPosition: e.getUniformLocation(u, "screenPosition"),
                  });
              })(),
            i.useProgram(u),
            i.initAttributes(),
            i.enableAttribute(h.vertex),
            i.enableAttribute(h.uv),
            i.disableUnusedAttributes(),
            e.uniform1i(p.occlusionMap, 0),
            e.uniform1i(p.map, 1),
            e.bindBuffer(e.ARRAY_BUFFER, s),
            e.vertexAttribPointer(h.vertex, 2, e.FLOAT, !1, 16, 0),
            e.vertexAttribPointer(h.uv, 2, e.FLOAT, !1, 16, 8),
            e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, c),
            i.disable(e.CULL_FACE),
            i.buffers.depth.setMask(!1);
          for (var A = 0, L = t.length; A < L; A++) {
            (w = 16 / v.w), M.set(w * x, w);
            var R = t[A];
            if (
              (y.set(
                R.matrixWorld.elements[12],
                R.matrixWorld.elements[13],
                R.matrixWorld.elements[14]
              ),
              y.applyMatrix4(g.matrixWorldInverse),
              y.applyMatrix4(g.projectionMatrix),
              E.copy(y),
              (T.x = v.x + E.x * b + b - 8),
              (T.y = v.y + E.y * _ + _ - 8),
              !0 === S.containsPoint(T))
            ) {
              i.activeTexture(e.TEXTURE0),
                i.bindTexture(e.TEXTURE_2D, null),
                i.activeTexture(e.TEXTURE1),
                i.bindTexture(e.TEXTURE_2D, d),
                e.copyTexImage2D(e.TEXTURE_2D, 0, e.RGB, T.x, T.y, 16, 16, 0),
                e.uniform1i(p.renderType, 0),
                e.uniform2f(p.scale, M.x, M.y),
                e.uniform3f(p.screenPosition, E.x, E.y, E.z),
                i.disable(e.BLEND),
                i.enable(e.DEPTH_TEST),
                e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0),
                i.activeTexture(e.TEXTURE0),
                i.bindTexture(e.TEXTURE_2D, f),
                e.copyTexImage2D(e.TEXTURE_2D, 0, e.RGBA, T.x, T.y, 16, 16, 0),
                e.uniform1i(p.renderType, 1),
                i.disable(e.DEPTH_TEST),
                i.activeTexture(e.TEXTURE1),
                i.bindTexture(e.TEXTURE_2D, d),
                e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0),
                R.positionScreen.copy(E),
                R.customUpdateCallback
                  ? R.customUpdateCallback(R)
                  : R.updateLensFlares(),
                e.uniform1i(p.renderType, 2),
                i.enable(e.BLEND);
              for (var P = 0, C = R.lensFlares.length; P < C; P++) {
                var O = R.lensFlares[P];
                O.opacity > 0.001 &&
                  O.scale > 0.001 &&
                  ((E.x = O.x),
                  (E.y = O.y),
                  (E.z = O.z),
                  (w = (O.size * O.scale) / v.w),
                  (M.x = w * x),
                  (M.y = w),
                  e.uniform3f(p.screenPosition, E.x, E.y, E.z),
                  e.uniform2f(p.scale, M.x, M.y),
                  e.uniform1f(p.rotation, O.rotation),
                  e.uniform1f(p.opacity, O.opacity),
                  e.uniform3f(p.color, O.color.r, O.color.g, O.color.b),
                  i.setBlending(
                    O.blending,
                    O.blendEquation,
                    O.blendSrc,
                    O.blendDst
                  ),
                  r.setTexture2D(O.texture, 1),
                  e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0));
              }
            }
          }
          i.enable(e.CULL_FACE),
            i.enable(e.DEPTH_TEST),
            i.buffers.depth.setMask(!0),
            i.reset();
        }
      };
    }
    function q(t, e, n, i, r, o, a, c, l) {
      s.call(this, t, e, n, i, r, o, a, c, l), (this.needsUpdate = !0);
    }
    function $(t, e, n, i, a) {
      function s(t, e) {
        return t.renderOrder !== e.renderOrder
          ? t.renderOrder - e.renderOrder
          : t.z !== e.z
          ? e.z - t.z
          : e.id - t.id;
      }
      var c,
        l,
        u,
        h,
        p,
        d,
        f = new o(),
        m = new r(),
        g = new o();
      this.render = function (r, o, v) {
        if (0 !== r.length) {
          void 0 === u &&
            (function () {
              var t = new Float32Array([
                  -0.5, -0.5, 0, 0, 0.5, -0.5, 1, 0, 0.5, 0.5, 1, 1, -0.5, 0.5,
                  0, 1,
                ]),
                n = new Uint16Array([0, 1, 2, 0, 2, 3]);
              (c = e.createBuffer()),
                (l = e.createBuffer()),
                e.bindBuffer(e.ARRAY_BUFFER, c),
                e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW),
                e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, l),
                e.bufferData(e.ELEMENT_ARRAY_BUFFER, n, e.STATIC_DRAW),
                (u = (function () {
                  var t = e.createProgram(),
                    n = e.createShader(e.VERTEX_SHADER),
                    i = e.createShader(e.FRAGMENT_SHADER);
                  return (
                    e.shaderSource(
                      n,
                      [
                        "precision " + a.precision + " float;",
                        "#define SHADER_NAME SpriteMaterial",
                        "uniform mat4 modelViewMatrix;",
                        "uniform mat4 projectionMatrix;",
                        "uniform float rotation;",
                        "uniform vec2 scale;",
                        "uniform vec2 uvOffset;",
                        "uniform vec2 uvScale;",
                        "attribute vec2 position;",
                        "attribute vec2 uv;",
                        "varying vec2 vUV;",
                        "varying float fogDepth;",
                        "void main() {",
                        "\tvUV = uvOffset + uv * uvScale;",
                        "\tvec2 alignedPosition = position * scale;",
                        "\tvec2 rotatedPosition;",
                        "\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;",
                        "\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;",
                        "\tvec4 mvPosition;",
                        "\tmvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );",
                        "\tmvPosition.xy += rotatedPosition;",
                        "\tgl_Position = projectionMatrix * mvPosition;",
                        "\tfogDepth = - mvPosition.z;",
                        "}",
                      ].join("\n")
                    ),
                    e.shaderSource(
                      i,
                      [
                        "precision " + a.precision + " float;",
                        "#define SHADER_NAME SpriteMaterial",
                        "uniform vec3 color;",
                        "uniform sampler2D map;",
                        "uniform float opacity;",
                        "uniform int fogType;",
                        "uniform vec3 fogColor;",
                        "uniform float fogDensity;",
                        "uniform float fogNear;",
                        "uniform float fogFar;",
                        "uniform float alphaTest;",
                        "varying vec2 vUV;",
                        "varying float fogDepth;",
                        "void main() {",
                        "\tvec4 texture = texture2D( map, vUV );",
                        "\tgl_FragColor = vec4( color * texture.xyz, texture.a * opacity );",
                        "\tif ( gl_FragColor.a < alphaTest ) discard;",
                        "\tif ( fogType > 0 ) {",
                        "\t\tfloat fogFactor = 0.0;",
                        "\t\tif ( fogType == 1 ) {",
                        "\t\t\tfogFactor = smoothstep( fogNear, fogFar, fogDepth );",
                        "\t\t} else {",
                        "\t\t\tconst float LOG2 = 1.442695;",
                        "\t\t\tfogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );",
                        "\t\t\tfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );",
                        "\t\t}",
                        "\t\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );",
                        "\t}",
                        "}",
                      ].join("\n")
                    ),
                    e.compileShader(n),
                    e.compileShader(i),
                    e.attachShader(t, n),
                    e.attachShader(t, i),
                    e.linkProgram(t),
                    t
                  );
                })()),
                (h = {
                  position: e.getAttribLocation(u, "position"),
                  uv: e.getAttribLocation(u, "uv"),
                }),
                (p = {
                  uvOffset: e.getUniformLocation(u, "uvOffset"),
                  uvScale: e.getUniformLocation(u, "uvScale"),
                  rotation: e.getUniformLocation(u, "rotation"),
                  scale: e.getUniformLocation(u, "scale"),
                  color: e.getUniformLocation(u, "color"),
                  map: e.getUniformLocation(u, "map"),
                  opacity: e.getUniformLocation(u, "opacity"),
                  modelViewMatrix: e.getUniformLocation(u, "modelViewMatrix"),
                  projectionMatrix: e.getUniformLocation(u, "projectionMatrix"),
                  fogType: e.getUniformLocation(u, "fogType"),
                  fogDensity: e.getUniformLocation(u, "fogDensity"),
                  fogNear: e.getUniformLocation(u, "fogNear"),
                  fogFar: e.getUniformLocation(u, "fogFar"),
                  fogColor: e.getUniformLocation(u, "fogColor"),
                  fogDepth: e.getUniformLocation(u, "fogDepth"),
                  alphaTest: e.getUniformLocation(u, "alphaTest"),
                });
              var i = document.createElementNS(
                "http://www.w3.org/1999/xhtml",
                "canvas"
              );
              (i.width = 8), (i.height = 8);
              var r = i.getContext("2d");
              (r.fillStyle = "white"), r.fillRect(0, 0, 8, 8), (d = new q(i));
            })(),
            n.useProgram(u),
            n.initAttributes(),
            n.enableAttribute(h.position),
            n.enableAttribute(h.uv),
            n.disableUnusedAttributes(),
            n.disable(e.CULL_FACE),
            n.enable(e.BLEND),
            e.bindBuffer(e.ARRAY_BUFFER, c),
            e.vertexAttribPointer(h.position, 2, e.FLOAT, !1, 16, 0),
            e.vertexAttribPointer(h.uv, 2, e.FLOAT, !1, 16, 8),
            e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, l),
            e.uniformMatrix4fv(
              p.projectionMatrix,
              !1,
              v.projectionMatrix.elements
            ),
            n.activeTexture(e.TEXTURE0),
            e.uniform1i(p.map, 0);
          var y = 0,
            x = 0,
            b = o.fog;
          b
            ? (e.uniform3f(p.fogColor, b.color.r, b.color.g, b.color.b),
              b.isFog
                ? (e.uniform1f(p.fogNear, b.near),
                  e.uniform1f(p.fogFar, b.far),
                  e.uniform1i(p.fogType, 1),
                  (y = 1),
                  (x = 1))
                : b.isFogExp2 &&
                  (e.uniform1f(p.fogDensity, b.density),
                  e.uniform1i(p.fogType, 2),
                  (y = 2),
                  (x = 2)))
            : (e.uniform1i(p.fogType, 0), (y = 0), (x = 0));
          for (var _ = 0, w = r.length; _ < w; _++)
            (E = r[_]).modelViewMatrix.multiplyMatrices(
              v.matrixWorldInverse,
              E.matrixWorld
            ),
              (E.z = -E.modelViewMatrix.elements[14]);
          r.sort(s);
          for (var M = [], _ = 0, w = r.length; _ < w; _++) {
            var E = r[_],
              T = E.material;
            if (!1 !== T.visible) {
              E.onBeforeRender(t, o, v, void 0, T, void 0),
                e.uniform1f(p.alphaTest, T.alphaTest),
                e.uniformMatrix4fv(
                  p.modelViewMatrix,
                  !1,
                  E.modelViewMatrix.elements
                ),
                E.matrixWorld.decompose(f, m, g),
                (M[0] = g.x),
                (M[1] = g.y);
              var S = 0;
              o.fog && T.fog && (S = x),
                y !== S && (e.uniform1i(p.fogType, S), (y = S)),
                null !== T.map
                  ? (e.uniform2f(p.uvOffset, T.map.offset.x, T.map.offset.y),
                    e.uniform2f(p.uvScale, T.map.repeat.x, T.map.repeat.y))
                  : (e.uniform2f(p.uvOffset, 0, 0),
                    e.uniform2f(p.uvScale, 1, 1)),
                e.uniform1f(p.opacity, T.opacity),
                e.uniform3f(p.color, T.color.r, T.color.g, T.color.b),
                e.uniform1f(p.rotation, T.rotation),
                e.uniform2fv(p.scale, M),
                n.setBlending(
                  T.blending,
                  T.blendEquation,
                  T.blendSrc,
                  T.blendDst,
                  T.blendEquationAlpha,
                  T.blendSrcAlpha,
                  T.blendDstAlpha,
                  T.premultipliedAlpha
                ),
                n.buffers.depth.setTest(T.depthTest),
                n.buffers.depth.setMask(T.depthWrite),
                n.buffers.color.setMask(T.colorWrite),
                i.setTexture2D(T.map || d, 0),
                e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0),
                E.onAfterRender(t, o, v, void 0, T, void 0);
            }
          }
          n.enable(e.CULL_FACE), n.reset();
        }
      };
    }
    function Z() {
      Object.defineProperty(this, "id", { value: _a++ }),
        (this.uuid = sa.generateUUID()),
        (this.name = ""),
        (this.type = "Material"),
        (this.fog = !0),
        (this.lights = !0),
        (this.blending = xr),
        (this.side = pr),
        (this.flatShading = !1),
        (this.vertexColors = mr),
        (this.opacity = 1),
        (this.transparent = !1),
        (this.blendSrc = Ir),
        (this.blendDst = Dr),
        (this.blendEquation = Er),
        (this.blendSrcAlpha = null),
        (this.blendDstAlpha = null),
        (this.blendEquationAlpha = null),
        (this.depthFunc = Gr),
        (this.depthTest = !0),
        (this.depthWrite = !0),
        (this.clippingPlanes = null),
        (this.clipIntersection = !1),
        (this.clipShadows = !1),
        (this.colorWrite = !0),
        (this.precision = null),
        (this.polygonOffset = !1),
        (this.polygonOffsetFactor = 0),
        (this.polygonOffsetUnits = 0),
        (this.dithering = !1),
        (this.alphaTest = 0),
        (this.premultipliedAlpha = !1),
        (this.overdraw = 0),
        (this.visible = !0),
        (this.userData = {}),
        (this.needsUpdate = !0);
    }
    function J(t) {
      Z.call(this),
        (this.type = "MeshDepthMaterial"),
        (this.depthPacking = oa),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.map = null),
        (this.alphaMap = null),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.fog = !1),
        (this.lights = !1),
        this.setValues(t);
    }
    function Q(t) {
      Z.call(this),
        (this.type = "MeshDistanceMaterial"),
        (this.referencePosition = new o()),
        (this.nearDistance = 1),
        (this.farDistance = 1e3),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.map = null),
        (this.alphaMap = null),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.fog = !1),
        (this.lights = !1),
        this.setValues(t);
    }
    function K(t, e) {
      (this.min = void 0 !== t ? t : new o(1 / 0, 1 / 0, 1 / 0)),
        (this.max = void 0 !== e ? e : new o(-1 / 0, -1 / 0, -1 / 0));
    }
    function tt(t, e) {
      (this.center = void 0 !== t ? t : new o()),
        (this.radius = void 0 !== e ? e : 0);
    }
    function et(t, e) {
      (this.normal = void 0 !== t ? t : new o(1, 0, 0)),
        (this.constant = void 0 !== e ? e : 0);
    }
    function nt(t, e, n, i, r, o) {
      this.planes = [
        void 0 !== t ? t : new et(),
        void 0 !== e ? e : new et(),
        void 0 !== n ? n : new et(),
        void 0 !== i ? i : new et(),
        void 0 !== r ? r : new et(),
        void 0 !== o ? o : new et(),
      ];
    }
    function it(t, e, r) {
      function a(e, n, i, r, o, a) {
        var s = e.geometry,
          c = null,
          l = x,
          u = e.customDepthMaterial;
        if ((i && ((l = b), (u = e.customDistanceMaterial)), u)) c = u;
        else {
          var h = !1;
          n.morphTargets &&
            (s && s.isBufferGeometry
              ? (h =
                  s.morphAttributes &&
                  s.morphAttributes.position &&
                  s.morphAttributes.position.length > 0)
              : s &&
                s.isGeometry &&
                (h = s.morphTargets && s.morphTargets.length > 0)),
            e.isSkinnedMesh &&
              !1 === n.skinning &&
              console.warn(
                "THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",
                e
              );
          var p = e.isSkinnedMesh && n.skinning,
            d = 0;
          h && (d |= g), p && (d |= v), (c = l[d]);
        }
        if (
          t.localClippingEnabled &&
          !0 === n.clipShadows &&
          0 !== n.clippingPlanes.length
        ) {
          var f = c.uuid,
            m = n.uuid,
            y = _[f];
          void 0 === y && ((y = {}), (_[f] = y));
          var w = y[m];
          void 0 === w && ((w = c.clone()), (y[m] = w)), (c = w);
        }
        (c.visible = n.visible), (c.wireframe = n.wireframe);
        var M = n.side;
        return (
          P.renderSingleSided && M == fr && (M = pr),
          P.renderReverseSided && (M === pr ? (M = dr) : M === dr && (M = pr)),
          (c.side = M),
          (c.clipShadows = n.clipShadows),
          (c.clippingPlanes = n.clippingPlanes),
          (c.clipIntersection = n.clipIntersection),
          (c.wireframeLinewidth = n.wireframeLinewidth),
          (c.linewidth = n.linewidth),
          i &&
            c.isMeshDistanceMaterial &&
            (c.referencePosition.copy(r),
            (c.nearDistance = o),
            (c.farDistance = a)),
          c
        );
      }
      function s(n, i, r, o) {
        if (!1 !== n.visible) {
          if (
            n.layers.test(i.layers) &&
            (n.isMesh || n.isLine || n.isPoints) &&
            n.castShadow &&
            (!n.frustumCulled || u.intersectsObject(n))
          ) {
            n.modelViewMatrix.multiplyMatrices(
              r.matrixWorldInverse,
              n.matrixWorld
            );
            var c = e.update(n),
              l = n.material;
            if (Array.isArray(l))
              for (var h = c.groups, p = 0, d = h.length; p < d; p++) {
                var f = h[p],
                  g = l[f.materialIndex];
                g &&
                  g.visible &&
                  ((v = a(n, g, o, m, r.near, r.far)),
                  t.renderBufferDirect(r, null, c, v, n, f));
              }
            else if (l.visible) {
              var v = a(n, l, o, m, r.near, r.far);
              t.renderBufferDirect(r, null, c, v, n, null);
            }
          }
          for (var y = n.children, x = 0, b = y.length; x < b; x++)
            s(y[x], i, r, o);
        }
      }
      for (
        var u = new nt(),
          h = new i(),
          p = new n(),
          d = new n(r, r),
          f = new o(),
          m = new o(),
          g = 1,
          v = 2,
          y = 1 + (g | v),
          x = new Array(y),
          b = new Array(y),
          _ = {},
          w = [
            new o(1, 0, 0),
            new o(-1, 0, 0),
            new o(0, 0, 1),
            new o(0, 0, -1),
            new o(0, 1, 0),
            new o(0, -1, 0),
          ],
          M = [
            new o(0, 1, 0),
            new o(0, 1, 0),
            new o(0, 1, 0),
            new o(0, 1, 0),
            new o(0, 0, 1),
            new o(0, 0, -1),
          ],
          E = [new c(), new c(), new c(), new c(), new c(), new c()],
          T = 0;
        T !== y;
        ++T
      ) {
        var S = 0 != (T & g),
          A = 0 != (T & v),
          L = new J({ depthPacking: aa, morphTargets: S, skinning: A });
        x[T] = L;
        var R = new Q({ morphTargets: S, skinning: A });
        b[T] = R;
      }
      var P = this;
      (this.enabled = !1),
        (this.autoUpdate = !0),
        (this.needsUpdate = !1),
        (this.type = ur),
        (this.renderReverseSided = !0),
        (this.renderSingleSided = !0),
        (this.render = function (e, n, i) {
          if (
            !1 !== P.enabled &&
            (!1 !== P.autoUpdate || !1 !== P.needsUpdate) &&
            0 !== e.length
          ) {
            var r = t.context,
              o = t.state;
            o.disable(r.BLEND),
              o.buffers.color.setClear(1, 1, 1, 1),
              o.buffers.depth.setTest(!0),
              o.setScissorTest(!1);
            for (var a, c = 0, g = e.length; c < g; c++) {
              var v = e[c],
                y = v.shadow,
                x = v && v.isPointLight;
              if (void 0 !== y) {
                var b = y.camera;
                if ((p.copy(y.mapSize), p.min(d), x)) {
                  var _ = p.x,
                    T = p.y;
                  E[0].set(2 * _, T, _, T),
                    E[1].set(0, T, _, T),
                    E[2].set(3 * _, T, _, T),
                    E[3].set(_, T, _, T),
                    E[4].set(3 * _, 0, _, T),
                    E[5].set(_, 0, _, T),
                    (p.x *= 4),
                    (p.y *= 2);
                }
                if (null === y.map) {
                  var S = { minFilter: po, magFilter: po, format: Io };
                  (y.map = new l(p.x, p.y, S)),
                    (y.map.texture.name = v.name + ".shadowMap"),
                    b.updateProjectionMatrix();
                }
                y.isSpotLightShadow && y.update(v);
                var A = y.map,
                  L = y.matrix;
                m.setFromMatrixPosition(v.matrixWorld),
                  b.position.copy(m),
                  x
                    ? ((a = 6), L.makeTranslation(-m.x, -m.y, -m.z))
                    : ((a = 1),
                      f.setFromMatrixPosition(v.target.matrixWorld),
                      b.lookAt(f),
                      b.updateMatrixWorld(),
                      L.set(
                        0.5,
                        0,
                        0,
                        0.5,
                        0,
                        0.5,
                        0,
                        0.5,
                        0,
                        0,
                        0.5,
                        0.5,
                        0,
                        0,
                        0,
                        1
                      ),
                      L.multiply(b.projectionMatrix),
                      L.multiply(b.matrixWorldInverse)),
                  t.setRenderTarget(A),
                  t.clear();
                for (var R = 0; R < a; R++) {
                  if (x) {
                    f.copy(b.position),
                      f.add(w[R]),
                      b.up.copy(M[R]),
                      b.lookAt(f),
                      b.updateMatrixWorld();
                    var C = E[R];
                    o.viewport(C);
                  }
                  h.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse),
                    u.setFromMatrix(h),
                    s(n, i, b, x);
                }
              } else console.warn("THREE.WebGLShadowMap:", v, "has no shadow.");
            }
            P.needsUpdate = !1;
          }
        });
    }
    function rt(t, e, n, i) {
      (this._x = t || 0),
        (this._y = e || 0),
        (this._z = n || 0),
        (this._order = i || rt.DefaultOrder);
    }
    function ot() {
      this.mask = 1;
    }
    function at() {
      Object.defineProperty(this, "id", { value: wa++ }),
        (this.uuid = sa.generateUUID()),
        (this.name = ""),
        (this.type = "Object3D"),
        (this.parent = null),
        (this.children = []),
        (this.up = at.DefaultUp.clone());
      var t = new o(),
        e = new rt(),
        n = new r(),
        s = new o(1, 1, 1);
      e.onChange(function () {
        n.setFromEuler(e, !1);
      }),
        n.onChange(function () {
          e.setFromQuaternion(n, void 0, !1);
        }),
        Object.defineProperties(this, {
          position: { enumerable: !0, value: t },
          rotation: { enumerable: !0, value: e },
          quaternion: { enumerable: !0, value: n },
          scale: { enumerable: !0, value: s },
          modelViewMatrix: { value: new i() },
          normalMatrix: { value: new a() },
        }),
        (this.matrix = new i()),
        (this.matrixWorld = new i()),
        (this.matrixAutoUpdate = at.DefaultMatrixAutoUpdate),
        (this.matrixWorldNeedsUpdate = !1),
        (this.layers = new ot()),
        (this.visible = !0),
        (this.castShadow = !1),
        (this.receiveShadow = !1),
        (this.frustumCulled = !0),
        (this.renderOrder = 0),
        (this.userData = {});
    }
    function st() {
      at.call(this),
        (this.type = "Camera"),
        (this.matrixWorldInverse = new i()),
        (this.projectionMatrix = new i());
    }
    function ct(t, e, n, i, r, o) {
      st.call(this),
        (this.type = "OrthographicCamera"),
        (this.zoom = 1),
        (this.view = null),
        (this.left = t),
        (this.right = e),
        (this.top = n),
        (this.bottom = i),
        (this.near = void 0 !== r ? r : 0.1),
        (this.far = void 0 !== o ? o : 2e3),
        this.updateProjectionMatrix();
    }
    function lt(t, e, n, i, r, a) {
      (this.a = t),
        (this.b = e),
        (this.c = n),
        (this.normal = i && i.isVector3 ? i : new o()),
        (this.vertexNormals = Array.isArray(i) ? i : []),
        (this.color = r && r.isColor ? r : new W()),
        (this.vertexColors = Array.isArray(r) ? r : []),
        (this.materialIndex = void 0 !== a ? a : 0);
    }
    function ut() {
      Object.defineProperty(this, "id", { value: (Ma += 2) }),
        (this.uuid = sa.generateUUID()),
        (this.name = ""),
        (this.type = "Geometry"),
        (this.vertices = []),
        (this.colors = []),
        (this.faces = []),
        (this.faceVertexUvs = [[]]),
        (this.morphTargets = []),
        (this.morphNormals = []),
        (this.skinWeights = []),
        (this.skinIndices = []),
        (this.lineDistances = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.elementsNeedUpdate = !1),
        (this.verticesNeedUpdate = !1),
        (this.uvsNeedUpdate = !1),
        (this.normalsNeedUpdate = !1),
        (this.colorsNeedUpdate = !1),
        (this.lineDistancesNeedUpdate = !1),
        (this.groupsNeedUpdate = !1);
    }
    function ht(t, e, n) {
      if (Array.isArray(t))
        throw new TypeError(
          "THREE.BufferAttribute: array should be a Typed Array."
        );
      (this.uuid = sa.generateUUID()),
        (this.name = ""),
        (this.array = t),
        (this.itemSize = e),
        (this.count = void 0 !== t ? t.length / e : 0),
        (this.normalized = !0 === n),
        (this.dynamic = !1),
        (this.updateRange = { offset: 0, count: -1 }),
        (this.onUploadCallback = function () {}),
        (this.version = 0);
    }
    function pt(t, e, n) {
      ht.call(this, new Int8Array(t), e, n);
    }
    function dt(t, e, n) {
      ht.call(this, new Uint8Array(t), e, n);
    }
    function ft(t, e, n) {
      ht.call(this, new Uint8ClampedArray(t), e, n);
    }
    function mt(t, e, n) {
      ht.call(this, new Int16Array(t), e, n);
    }
    function gt(t, e, n) {
      ht.call(this, new Uint16Array(t), e, n);
    }
    function vt(t, e, n) {
      ht.call(this, new Int32Array(t), e, n);
    }
    function yt(t, e, n) {
      ht.call(this, new Uint32Array(t), e, n);
    }
    function xt(t, e, n) {
      ht.call(this, new Float32Array(t), e, n);
    }
    function bt(t, e, n) {
      ht.call(this, new Float64Array(t), e, n);
    }
    function _t() {
      (this.indices = []),
        (this.vertices = []),
        (this.normals = []),
        (this.colors = []),
        (this.uvs = []),
        (this.uvs2 = []),
        (this.groups = []),
        (this.morphTargets = {}),
        (this.skinWeights = []),
        (this.skinIndices = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.verticesNeedUpdate = !1),
        (this.normalsNeedUpdate = !1),
        (this.colorsNeedUpdate = !1),
        (this.uvsNeedUpdate = !1),
        (this.groupsNeedUpdate = !1);
    }
    function wt(t) {
      if (0 === t.length) return -1 / 0;
      for (var e = t[0], n = 1, i = t.length; n < i; ++n)
        t[n] > e && (e = t[n]);
      return e;
    }
    function Mt() {
      Object.defineProperty(this, "id", { value: (Ea += 2) }),
        (this.uuid = sa.generateUUID()),
        (this.name = ""),
        (this.type = "BufferGeometry"),
        (this.index = null),
        (this.attributes = {}),
        (this.morphAttributes = {}),
        (this.groups = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.drawRange = { start: 0, count: 1 / 0 });
    }
    function Et(t, e, n, i, r, o) {
      ut.call(this),
        (this.type = "BoxGeometry"),
        (this.parameters = {
          width: t,
          height: e,
          depth: n,
          widthSegments: i,
          heightSegments: r,
          depthSegments: o,
        }),
        this.fromBufferGeometry(new Tt(t, e, n, i, r, o)),
        this.mergeVertices();
    }
    function Tt(t, e, n, i, r, a) {
      function s(t, e, n, i, r, a, s, m, g, v, y) {
        var x,
          b,
          _ = a / g,
          w = s / v,
          M = a / 2,
          E = s / 2,
          T = m / 2,
          S = g + 1,
          A = v + 1,
          L = 0,
          R = 0,
          P = new o();
        for (b = 0; b < A; b++) {
          var C = b * w - E;
          for (x = 0; x < S; x++) {
            var O = x * _ - M;
            (P[t] = O * i),
              (P[e] = C * r),
              (P[n] = T),
              u.push(P.x, P.y, P.z),
              (P[t] = 0),
              (P[e] = 0),
              (P[n] = m > 0 ? 1 : -1),
              h.push(P.x, P.y, P.z),
              p.push(x / g),
              p.push(1 - b / v),
              (L += 1);
          }
        }
        for (b = 0; b < v; b++)
          for (x = 0; x < g; x++) {
            var I = d + x + S * b,
              D = d + x + S * (b + 1),
              U = d + (x + 1) + S * (b + 1),
              N = d + (x + 1) + S * b;
            l.push(I, D, N), l.push(D, U, N), (R += 6);
          }
        c.addGroup(f, R, y), (f += R), (d += L);
      }
      Mt.call(this),
        (this.type = "BoxBufferGeometry"),
        (this.parameters = {
          width: t,
          height: e,
          depth: n,
          widthSegments: i,
          heightSegments: r,
          depthSegments: a,
        });
      var c = this;
      (t = t || 1),
        (e = e || 1),
        (n = n || 1),
        (i = Math.floor(i) || 1),
        (r = Math.floor(r) || 1);
      var l = [],
        u = [],
        h = [],
        p = [],
        d = 0,
        f = 0;
      s("z", "y", "x", -1, -1, n, e, t, (a = Math.floor(a) || 1), r, 0),
        s("z", "y", "x", 1, -1, n, e, -t, a, r, 1),
        s("x", "z", "y", 1, 1, t, n, e, i, a, 2),
        s("x", "z", "y", 1, -1, t, n, -e, i, a, 3),
        s("x", "y", "z", 1, -1, t, e, n, i, r, 4),
        s("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
        this.setIndex(l),
        this.addAttribute("position", new xt(u, 3)),
        this.addAttribute("normal", new xt(h, 3)),
        this.addAttribute("uv", new xt(p, 2));
    }
    function St(t, e, n, i) {
      ut.call(this),
        (this.type = "PlaneGeometry"),
        (this.parameters = {
          width: t,
          height: e,
          widthSegments: n,
          heightSegments: i,
        }),
        this.fromBufferGeometry(new At(t, e, n, i)),
        this.mergeVertices();
    }
    function At(t, e, n, i) {
      Mt.call(this),
        (this.type = "PlaneBufferGeometry"),
        (this.parameters = {
          width: t,
          height: e,
          widthSegments: n,
          heightSegments: i,
        });
      var r,
        o,
        a = (t = t || 1) / 2,
        s = (e = e || 1) / 2,
        c = Math.floor(n) || 1,
        l = Math.floor(i) || 1,
        u = c + 1,
        h = l + 1,
        p = t / c,
        d = e / l,
        f = [],
        m = [],
        g = [],
        v = [];
      for (o = 0; o < h; o++) {
        var y = o * d - s;
        for (r = 0; r < u; r++) {
          var x = r * p - a;
          m.push(x, -y, 0), g.push(0, 0, 1), v.push(r / c), v.push(1 - o / l);
        }
      }
      for (o = 0; o < l; o++)
        for (r = 0; r < c; r++) {
          var b = r + u * o,
            _ = r + u * (o + 1),
            w = r + 1 + u * (o + 1),
            M = r + 1 + u * o;
          f.push(b, _, M), f.push(_, w, M);
        }
      this.setIndex(f),
        this.addAttribute("position", new xt(m, 3)),
        this.addAttribute("normal", new xt(g, 3)),
        this.addAttribute("uv", new xt(v, 2));
    }
    function Lt(t) {
      Z.call(this),
        (this.type = "MeshBasicMaterial"),
        (this.color = new W(16777215)),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.specularMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.combine = qr),
        (this.reflectivity = 1),
        (this.refractionRatio = 0.98),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.lights = !1),
        this.setValues(t);
    }
    function Rt(t) {
      Z.call(this),
        (this.type = "ShaderMaterial"),
        (this.defines = {}),
        (this.uniforms = {}),
        (this.vertexShader =
          "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
        (this.fragmentShader =
          "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
        (this.linewidth = 1),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.fog = !1),
        (this.lights = !1),
        (this.clipping = !1),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.morphNormals = !1),
        (this.extensions = {
          derivatives: !1,
          fragDepth: !1,
          drawBuffers: !1,
          shaderTextureLOD: !1,
        }),
        (this.defaultAttributeValues = {
          color: [1, 1, 1],
          uv: [0, 0],
          uv2: [0, 0],
        }),
        (this.index0AttributeName = void 0),
        void 0 !== t &&
          (void 0 !== t.attributes &&
            console.error(
              "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
            ),
          this.setValues(t));
    }
    function Pt(t, e) {
      (this.origin = void 0 !== t ? t : new o()),
        (this.direction = void 0 !== e ? e : new o());
    }
    function Ct(t, e) {
      (this.start = void 0 !== t ? t : new o()),
        (this.end = void 0 !== e ? e : new o());
    }
    function Ot(t, e, n) {
      (this.a = void 0 !== t ? t : new o()),
        (this.b = void 0 !== e ? e : new o()),
        (this.c = void 0 !== n ? n : new o());
    }
    function It(t, e) {
      at.call(this),
        (this.type = "Mesh"),
        (this.geometry = void 0 !== t ? t : new Mt()),
        (this.material =
          void 0 !== e ? e : new Lt({ color: 16777215 * Math.random() })),
        (this.drawMode = $o),
        this.updateMorphTargets();
    }
    function Dt(t, e) {
      return t.renderOrder !== e.renderOrder
        ? t.renderOrder - e.renderOrder
        : t.program && e.program && t.program !== e.program
        ? t.program.id - e.program.id
        : t.material.id !== e.material.id
        ? t.material.id - e.material.id
        : t.z !== e.z
        ? t.z - e.z
        : t.id - e.id;
    }
    function Ut(t, e) {
      return t.renderOrder !== e.renderOrder
        ? t.renderOrder - e.renderOrder
        : t.z !== e.z
        ? e.z - t.z
        : t.id - e.id;
    }
    function Nt(t, e) {
      return Math.abs(e[1]) - Math.abs(t[1]);
    }
    function zt(t, e, n) {
      var i = t.createShader(e);
      return (
        t.shaderSource(i, n),
        t.compileShader(i),
        !1 === t.getShaderParameter(i, t.COMPILE_STATUS) &&
          console.error("THREE.WebGLShader: Shader couldn't compile."),
        "" !== t.getShaderInfoLog(i) &&
          console.warn(
            "THREE.WebGLShader: gl.getShaderInfoLog()",
            e === t.VERTEX_SHADER ? "vertex" : "fragment",
            t.getShaderInfoLog(i),
            (function (t) {
              for (var e = t.split("\n"), n = 0; n < e.length; n++)
                e[n] = n + 1 + ": " + e[n];
              return e.join("\n");
            })(n)
          ),
        i
      );
    }
    function kt(t) {
      switch (t) {
        case Qo:
          return ["Linear", "( value )"];
        case Ko:
          return ["sRGB", "( value )"];
        case ea:
          return ["RGBE", "( value )"];
        case na:
          return ["RGBM", "( value, 7.0 )"];
        case ia:
          return ["RGBM", "( value, 16.0 )"];
        case ra:
          return ["RGBD", "( value, 256.0 )"];
        case ta:
          return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        default:
          throw new Error("unsupported encoding: " + t);
      }
    }
    function Ft(t, e) {
      var n = kt(e);
      return (
        "vec4 " +
        t +
        "( vec4 value ) { return " +
        n[0] +
        "ToLinear" +
        n[1] +
        "; }"
      );
    }
    function Bt(t) {
      return "" !== t;
    }
    function Ht(t, e) {
      return t
        .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
        .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
        .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
        .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
        .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights);
    }
    function jt(t) {
      return t.replace(/^[ \t]*#include +<([\w\d.]+)>/gm, function (t, e) {
        var n = xa[e];
        if (void 0 === n)
          throw new Error("Can not resolve #include <" + e + ">");
        return jt(n);
      });
    }
    function Gt(t) {
      return t.replace(
        /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
        function (t, e, n, i) {
          for (var r = "", o = parseInt(e); o < parseInt(n); o++)
            r += i.replace(/\[ i \]/g, "[ " + o + " ]");
          return r;
        }
      );
    }
    function Vt(t, e, n) {
      function i(t, e) {
        var n;
        return (
          t
            ? t.isTexture
              ? (n = t.encoding)
              : t.isWebGLRenderTarget &&
                (console.warn(
                  "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
                ),
                (n = t.texture.encoding))
            : (n = Qo),
          n === Qo && e && (n = ta),
          n
        );
      }
      var r = [],
        o = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "phong",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
        },
        a = [
          "precision",
          "supportsVertexTextures",
          "map",
          "mapEncoding",
          "envMap",
          "envMapMode",
          "envMapEncoding",
          "lightMap",
          "aoMap",
          "emissiveMap",
          "emissiveMapEncoding",
          "bumpMap",
          "normalMap",
          "displacementMap",
          "specularMap",
          "roughnessMap",
          "metalnessMap",
          "gradientMap",
          "alphaMap",
          "combine",
          "vertexColors",
          "fog",
          "useFog",
          "fogExp",
          "flatShading",
          "sizeAttenuation",
          "logarithmicDepthBuffer",
          "skinning",
          "maxBones",
          "useVertexTexture",
          "morphTargets",
          "morphNormals",
          "maxMorphTargets",
          "maxMorphNormals",
          "premultipliedAlpha",
          "numDirLights",
          "numPointLights",
          "numSpotLights",
          "numHemiLights",
          "numRectAreaLights",
          "shadowMapEnabled",
          "shadowMapType",
          "toneMapping",
          "physicallyCorrectLights",
          "alphaTest",
          "doubleSided",
          "flipSided",
          "numClippingPlanes",
          "numClipIntersection",
          "depthPacking",
          "dithering",
        ];
      (this.getParameters = function (e, r, a, s, c, l, u) {
        var h = o[e.type],
          p = u.isSkinnedMesh
            ? (function (t) {
                var e = t.skeleton.bones;
                if (n.floatVertexTextures) return 1024;
                var i = n.maxVertexUniforms,
                  r = Math.floor((i - 20) / 4),
                  o = Math.min(r, e.length);
                return o < e.length
                  ? (console.warn(
                      "THREE.WebGLRenderer: Skeleton has " +
                        e.length +
                        " bones. This GPU supports " +
                        o +
                        "."
                    ),
                    0)
                  : o;
              })(u)
            : 0,
          d = n.precision;
        null !== e.precision &&
          (d = n.getMaxPrecision(e.precision)) !== e.precision &&
          console.warn(
            "THREE.WebGLProgram.getParameters:",
            e.precision,
            "not supported, using",
            d,
            "instead."
          );
        var f = t.getRenderTarget();
        return {
          shaderID: h,
          precision: d,
          supportsVertexTextures: n.vertexTextures,
          outputEncoding: i(f ? f.texture : null, t.gammaOutput),
          map: !!e.map,
          mapEncoding: i(e.map, t.gammaInput),
          envMap: !!e.envMap,
          envMapMode: e.envMap && e.envMap.mapping,
          envMapEncoding: i(e.envMap, t.gammaInput),
          envMapCubeUV:
            !!e.envMap && (e.envMap.mapping === so || e.envMap.mapping === co),
          lightMap: !!e.lightMap,
          aoMap: !!e.aoMap,
          emissiveMap: !!e.emissiveMap,
          emissiveMapEncoding: i(e.emissiveMap, t.gammaInput),
          bumpMap: !!e.bumpMap,
          normalMap: !!e.normalMap,
          displacementMap: !!e.displacementMap,
          roughnessMap: !!e.roughnessMap,
          metalnessMap: !!e.metalnessMap,
          specularMap: !!e.specularMap,
          alphaMap: !!e.alphaMap,
          gradientMap: !!e.gradientMap,
          combine: e.combine,
          vertexColors: e.vertexColors,
          fog: !!s,
          useFog: e.fog,
          fogExp: s && s.isFogExp2,
          flatShading: e.flatShading,
          sizeAttenuation: e.sizeAttenuation,
          logarithmicDepthBuffer: n.logarithmicDepthBuffer,
          skinning: e.skinning && p > 0,
          maxBones: p,
          useVertexTexture: n.floatVertexTextures,
          morphTargets: e.morphTargets,
          morphNormals: e.morphNormals,
          maxMorphTargets: t.maxMorphTargets,
          maxMorphNormals: t.maxMorphNormals,
          numDirLights: r.directional.length,
          numPointLights: r.point.length,
          numSpotLights: r.spot.length,
          numRectAreaLights: r.rectArea.length,
          numHemiLights: r.hemi.length,
          numClippingPlanes: c,
          numClipIntersection: l,
          dithering: e.dithering,
          shadowMapEnabled:
            t.shadowMap.enabled && u.receiveShadow && a.length > 0,
          shadowMapType: t.shadowMap.type,
          toneMapping: t.toneMapping,
          physicallyCorrectLights: t.physicallyCorrectLights,
          premultipliedAlpha: e.premultipliedAlpha,
          alphaTest: e.alphaTest,
          doubleSided: e.side === fr,
          flipSided: e.side === dr,
          depthPacking: void 0 !== e.depthPacking && e.depthPacking,
        };
      }),
        (this.getProgramCode = function (e, n) {
          var i = [];
          if (
            (n.shaderID
              ? i.push(n.shaderID)
              : (i.push(e.fragmentShader), i.push(e.vertexShader)),
            void 0 !== e.defines)
          )
            for (var r in e.defines) i.push(r), i.push(e.defines[r]);
          for (var o = 0; o < a.length; o++) i.push(n[a[o]]);
          return (
            i.push(e.onBeforeCompile.toString()),
            i.push(t.gammaOutput),
            i.join()
          );
        }),
        (this.acquireProgram = function (n, i, o, a) {
          for (var s, c = 0, l = r.length; c < l; c++) {
            var u = r[c];
            if (u.code === a) {
              ++(s = u).usedTimes;
              break;
            }
          }
          return (
            void 0 === s &&
              ((s = new (function (t, e, n, i, r, o) {
                var a = t.context,
                  s = i.defines,
                  c = r.vertexShader,
                  l = r.fragmentShader,
                  u = "SHADOWMAP_TYPE_BASIC";
                o.shadowMapType === ur
                  ? (u = "SHADOWMAP_TYPE_PCF")
                  : o.shadowMapType === hr && (u = "SHADOWMAP_TYPE_PCF_SOFT");
                var h = "ENVMAP_TYPE_CUBE",
                  p = "ENVMAP_MODE_REFLECTION",
                  d = "ENVMAP_BLENDING_MULTIPLY";
                if (o.envMap) {
                  switch (i.envMap.mapping) {
                    case no:
                    case io:
                      h = "ENVMAP_TYPE_CUBE";
                      break;
                    case so:
                    case co:
                      h = "ENVMAP_TYPE_CUBE_UV";
                      break;
                    case ro:
                    case oo:
                      h = "ENVMAP_TYPE_EQUIREC";
                      break;
                    case ao:
                      h = "ENVMAP_TYPE_SPHERE";
                  }
                  switch (i.envMap.mapping) {
                    case io:
                    case oo:
                      p = "ENVMAP_MODE_REFRACTION";
                  }
                  switch (i.combine) {
                    case qr:
                      d = "ENVMAP_BLENDING_MULTIPLY";
                      break;
                    case $r:
                      d = "ENVMAP_BLENDING_MIX";
                      break;
                    case Zr:
                      d = "ENVMAP_BLENDING_ADD";
                  }
                }
                var f,
                  m,
                  g = t.gammaFactor > 0 ? t.gammaFactor : 1,
                  v = (function (t, e, n) {
                    return [
                      (t = t || {}).derivatives ||
                      e.envMapCubeUV ||
                      e.bumpMap ||
                      e.normalMap ||
                      e.flatShading
                        ? "#extension GL_OES_standard_derivatives : enable"
                        : "",
                      (t.fragDepth || e.logarithmicDepthBuffer) &&
                      n.get("EXT_frag_depth")
                        ? "#extension GL_EXT_frag_depth : enable"
                        : "",
                      t.drawBuffers && n.get("WEBGL_draw_buffers")
                        ? "#extension GL_EXT_draw_buffers : require"
                        : "",
                      (t.shaderTextureLOD || e.envMap) &&
                      n.get("EXT_shader_texture_lod")
                        ? "#extension GL_EXT_shader_texture_lod : enable"
                        : "",
                    ]
                      .filter(Bt)
                      .join("\n");
                  })(i.extensions, o, e),
                  y = (function (t) {
                    var e = [];
                    for (var n in t) {
                      var i = t[n];
                      !1 !== i && e.push("#define " + n + " " + i);
                    }
                    return e.join("\n");
                  })(s),
                  x = a.createProgram();
                i.isRawShaderMaterial
                  ? ((f = [y].filter(Bt).join("\n")).length > 0 && (f += "\n"),
                    (m = [v, y].filter(Bt).join("\n")).length > 0 &&
                      (m += "\n"))
                  : ((f = [
                      "precision " + o.precision + " float;",
                      "precision " + o.precision + " int;",
                      "#define SHADER_NAME " + r.name,
                      y,
                      o.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
                      "#define GAMMA_FACTOR " + g,
                      "#define MAX_BONES " + o.maxBones,
                      o.useFog && o.fog ? "#define USE_FOG" : "",
                      o.useFog && o.fogExp ? "#define FOG_EXP2" : "",
                      o.map ? "#define USE_MAP" : "",
                      o.envMap ? "#define USE_ENVMAP" : "",
                      o.envMap ? "#define " + p : "",
                      o.lightMap ? "#define USE_LIGHTMAP" : "",
                      o.aoMap ? "#define USE_AOMAP" : "",
                      o.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                      o.bumpMap ? "#define USE_BUMPMAP" : "",
                      o.normalMap ? "#define USE_NORMALMAP" : "",
                      o.displacementMap && o.supportsVertexTextures
                        ? "#define USE_DISPLACEMENTMAP"
                        : "",
                      o.specularMap ? "#define USE_SPECULARMAP" : "",
                      o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                      o.metalnessMap ? "#define USE_METALNESSMAP" : "",
                      o.alphaMap ? "#define USE_ALPHAMAP" : "",
                      o.vertexColors ? "#define USE_COLOR" : "",
                      o.flatShading ? "#define FLAT_SHADED" : "",
                      o.skinning ? "#define USE_SKINNING" : "",
                      o.useVertexTexture ? "#define BONE_TEXTURE" : "",
                      o.morphTargets ? "#define USE_MORPHTARGETS" : "",
                      o.morphNormals && !1 === o.flatShading
                        ? "#define USE_MORPHNORMALS"
                        : "",
                      o.doubleSided ? "#define DOUBLE_SIDED" : "",
                      o.flipSided ? "#define FLIP_SIDED" : "",
                      "#define NUM_CLIPPING_PLANES " + o.numClippingPlanes,
                      o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                      o.shadowMapEnabled ? "#define " + u : "",
                      o.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
                      o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
                      o.logarithmicDepthBuffer && e.get("EXT_frag_depth")
                        ? "#define USE_LOGDEPTHBUF_EXT"
                        : "",
                      "uniform mat4 modelMatrix;",
                      "uniform mat4 modelViewMatrix;",
                      "uniform mat4 projectionMatrix;",
                      "uniform mat4 viewMatrix;",
                      "uniform mat3 normalMatrix;",
                      "uniform vec3 cameraPosition;",
                      "attribute vec3 position;",
                      "attribute vec3 normal;",
                      "attribute vec2 uv;",
                      "#ifdef USE_COLOR",
                      "\tattribute vec3 color;",
                      "#endif",
                      "#ifdef USE_MORPHTARGETS",
                      "\tattribute vec3 morphTarget0;",
                      "\tattribute vec3 morphTarget1;",
                      "\tattribute vec3 morphTarget2;",
                      "\tattribute vec3 morphTarget3;",
                      "\t#ifdef USE_MORPHNORMALS",
                      "\t\tattribute vec3 morphNormal0;",
                      "\t\tattribute vec3 morphNormal1;",
                      "\t\tattribute vec3 morphNormal2;",
                      "\t\tattribute vec3 morphNormal3;",
                      "\t#else",
                      "\t\tattribute vec3 morphTarget4;",
                      "\t\tattribute vec3 morphTarget5;",
                      "\t\tattribute vec3 morphTarget6;",
                      "\t\tattribute vec3 morphTarget7;",
                      "\t#endif",
                      "#endif",
                      "#ifdef USE_SKINNING",
                      "\tattribute vec4 skinIndex;",
                      "\tattribute vec4 skinWeight;",
                      "#endif",
                      "\n",
                    ]
                      .filter(Bt)
                      .join("\n")),
                    (m = [
                      v,
                      "precision " + o.precision + " float;",
                      "precision " + o.precision + " int;",
                      "#define SHADER_NAME " + r.name,
                      y,
                      o.alphaTest ? "#define ALPHATEST " + o.alphaTest : "",
                      "#define GAMMA_FACTOR " + g,
                      o.useFog && o.fog ? "#define USE_FOG" : "",
                      o.useFog && o.fogExp ? "#define FOG_EXP2" : "",
                      o.map ? "#define USE_MAP" : "",
                      o.envMap ? "#define USE_ENVMAP" : "",
                      o.envMap ? "#define " + h : "",
                      o.envMap ? "#define " + p : "",
                      o.envMap ? "#define " + d : "",
                      o.lightMap ? "#define USE_LIGHTMAP" : "",
                      o.aoMap ? "#define USE_AOMAP" : "",
                      o.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                      o.bumpMap ? "#define USE_BUMPMAP" : "",
                      o.normalMap ? "#define USE_NORMALMAP" : "",
                      o.specularMap ? "#define USE_SPECULARMAP" : "",
                      o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                      o.metalnessMap ? "#define USE_METALNESSMAP" : "",
                      o.alphaMap ? "#define USE_ALPHAMAP" : "",
                      o.vertexColors ? "#define USE_COLOR" : "",
                      o.gradientMap ? "#define USE_GRADIENTMAP" : "",
                      o.flatShading ? "#define FLAT_SHADED" : "",
                      o.doubleSided ? "#define DOUBLE_SIDED" : "",
                      o.flipSided ? "#define FLIP_SIDED" : "",
                      "#define NUM_CLIPPING_PLANES " + o.numClippingPlanes,
                      "#define UNION_CLIPPING_PLANES " +
                        (o.numClippingPlanes - o.numClipIntersection),
                      o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                      o.shadowMapEnabled ? "#define " + u : "",
                      o.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
                      o.physicallyCorrectLights
                        ? "#define PHYSICALLY_CORRECT_LIGHTS"
                        : "",
                      o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
                      o.logarithmicDepthBuffer && e.get("EXT_frag_depth")
                        ? "#define USE_LOGDEPTHBUF_EXT"
                        : "",
                      o.envMap && e.get("EXT_shader_texture_lod")
                        ? "#define TEXTURE_LOD_EXT"
                        : "",
                      "uniform mat4 viewMatrix;",
                      "uniform vec3 cameraPosition;",
                      o.toneMapping !== Jr ? "#define TONE_MAPPING" : "",
                      o.toneMapping !== Jr ? xa.tonemapping_pars_fragment : "",
                      o.toneMapping !== Jr
                        ? (function (t, e) {
                            var n;
                            switch (e) {
                              case Qr:
                                n = "Linear";
                                break;
                              case Kr:
                                n = "Reinhard";
                                break;
                              case to:
                                n = "Uncharted2";
                                break;
                              case eo:
                                n = "OptimizedCineon";
                                break;
                              default:
                                throw new Error(
                                  "unsupported toneMapping: " + e
                                );
                            }
                            return (
                              "vec3 toneMapping( vec3 color ) { return " +
                              n +
                              "ToneMapping( color ); }"
                            );
                          })(0, o.toneMapping)
                        : "",
                      o.dithering ? "#define DITHERING" : "",
                      o.outputEncoding ||
                      o.mapEncoding ||
                      o.envMapEncoding ||
                      o.emissiveMapEncoding
                        ? xa.encodings_pars_fragment
                        : "",
                      o.mapEncoding
                        ? Ft("mapTexelToLinear", o.mapEncoding)
                        : "",
                      o.envMapEncoding
                        ? Ft("envMapTexelToLinear", o.envMapEncoding)
                        : "",
                      o.emissiveMapEncoding
                        ? Ft("emissiveMapTexelToLinear", o.emissiveMapEncoding)
                        : "",
                      o.outputEncoding
                        ? (function (t, e) {
                            var n = kt(o.outputEncoding);
                            return (
                              "vec4 linearToOutputTexel( vec4 value ) { return LinearTo" +
                              n[0] +
                              n[1] +
                              "; }"
                            );
                          })()
                        : "",
                      o.depthPacking
                        ? "#define DEPTH_PACKING " + i.depthPacking
                        : "",
                      "\n",
                    ]
                      .filter(Bt)
                      .join("\n"))),
                  (c = Ht((c = jt(c)), o)),
                  (l = Ht((l = jt(l)), o)),
                  i.isShaderMaterial || ((c = Gt(c)), (l = Gt(l)));
                var b = f + c,
                  _ = m + l,
                  w = zt(a, a.VERTEX_SHADER, b),
                  M = zt(a, a.FRAGMENT_SHADER, _);
                a.attachShader(x, w),
                  a.attachShader(x, M),
                  void 0 !== i.index0AttributeName
                    ? a.bindAttribLocation(x, 0, i.index0AttributeName)
                    : !0 === o.morphTargets &&
                      a.bindAttribLocation(x, 0, "position"),
                  a.linkProgram(x);
                var E = a.getProgramInfoLog(x),
                  T = a.getShaderInfoLog(w),
                  S = a.getShaderInfoLog(M),
                  A = !0,
                  L = !0;
                !1 === a.getProgramParameter(x, a.LINK_STATUS)
                  ? ((A = !1),
                    console.error(
                      "THREE.WebGLProgram: shader error: ",
                      a.getError(),
                      "gl.VALIDATE_STATUS",
                      a.getProgramParameter(x, a.VALIDATE_STATUS),
                      "gl.getProgramInfoLog",
                      E,
                      T,
                      S
                    ))
                  : "" !== E
                  ? console.warn(
                      "THREE.WebGLProgram: gl.getProgramInfoLog()",
                      E
                    )
                  : ("" !== T && "" !== S) || (L = !1),
                  L &&
                    (this.diagnostics = {
                      runnable: A,
                      material: i,
                      programLog: E,
                      vertexShader: { log: T, prefix: f },
                      fragmentShader: { log: S, prefix: m },
                    }),
                  a.deleteShader(w),
                  a.deleteShader(M);
                var R;
                this.getUniforms = function () {
                  return void 0 === R && (R = new V(a, x, t)), R;
                };
                var P;
                return (
                  (this.getAttributes = function () {
                    return (
                      void 0 === P &&
                        (P = (function (t, e) {
                          for (
                            var n = {},
                              i = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES),
                              r = 0;
                            r < i;
                            r++
                          ) {
                            var o = t.getActiveAttrib(e, r).name;
                            n[o] = t.getAttribLocation(e, o);
                          }
                          return n;
                        })(a, x)),
                      P
                    );
                  }),
                  (this.destroy = function () {
                    a.deleteProgram(x), (this.program = void 0);
                  }),
                  Object.defineProperties(this, {
                    uniforms: {
                      get: function () {
                        return (
                          console.warn(
                            "THREE.WebGLProgram: .uniforms is now .getUniforms()."
                          ),
                          this.getUniforms()
                        );
                      },
                    },
                    attributes: {
                      get: function () {
                        return (
                          console.warn(
                            "THREE.WebGLProgram: .attributes is now .getAttributes()."
                          ),
                          this.getAttributes()
                        );
                      },
                    },
                  }),
                  (this.id = Ta++),
                  (this.code = n),
                  (this.usedTimes = 1),
                  (this.program = x),
                  (this.vertexShader = w),
                  (this.fragmentShader = M),
                  this
                );
              })(t, e, a, n, i, o)),
              r.push(s)),
            s
          );
        }),
        (this.releaseProgram = function (t) {
          if (0 == --t.usedTimes) {
            var e = r.indexOf(t);
            (r[e] = r[r.length - 1]), r.pop(), t.destroy();
          }
        }),
        (this.programs = r);
    }
    function Wt(t, e, n, i, r, o, a) {
      function s(t, e) {
        if (t.width > e || t.height > e) {
          var n = e / Math.max(t.width, t.height),
            i = document.createElementNS(
              "http://www.w3.org/1999/xhtml",
              "canvas"
            );
          return (
            (i.width = Math.floor(t.width * n)),
            (i.height = Math.floor(t.height * n)),
            i
              .getContext("2d")
              .drawImage(t, 0, 0, t.width, t.height, 0, 0, i.width, i.height),
            console.warn(
              "THREE.WebGLRenderer: image is too big (" +
                t.width +
                "x" +
                t.height +
                "). Resized to " +
                i.width +
                "x" +
                i.height,
              t
            ),
            i
          );
        }
        return t;
      }
      function c(t) {
        return sa.isPowerOfTwo(t.width) && sa.isPowerOfTwo(t.height);
      }
      function l(t, e) {
        return (
          t.generateMipmaps && e && t.minFilter !== po && t.minFilter !== go
        );
      }
      function u(e) {
        return e === po || e === fo || e === mo ? t.NEAREST : t.LINEAR;
      }
      function h(e) {
        var n = e.target;
        n.removeEventListener("dispose", h),
          (function (e) {
            var n = i.get(e);
            if (e.image && n.__image__webglTextureCube)
              t.deleteTexture(n.__image__webglTextureCube);
            else {
              if (void 0 === n.__webglInit) return;
              t.deleteTexture(n.__webglTexture);
            }
            i.remove(e);
          })(n),
          a.textures--;
      }
      function p(e) {
        var n = e.target;
        n.removeEventListener("dispose", p),
          (function (e) {
            var n = i.get(e),
              r = i.get(e.texture);
            if (e) {
              if (
                (void 0 !== r.__webglTexture &&
                  t.deleteTexture(r.__webglTexture),
                e.depthTexture && e.depthTexture.dispose(),
                e.isWebGLRenderTargetCube)
              )
                for (var o = 0; o < 6; o++)
                  t.deleteFramebuffer(n.__webglFramebuffer[o]),
                    n.__webglDepthbuffer &&
                      t.deleteRenderbuffer(n.__webglDepthbuffer[o]);
              else
                t.deleteFramebuffer(n.__webglFramebuffer),
                  n.__webglDepthbuffer &&
                    t.deleteRenderbuffer(n.__webglDepthbuffer);
              i.remove(e.texture), i.remove(e);
            }
          })(n),
          a.textures--;
      }
      function d(e, u) {
        var p = i.get(e);
        if (e.version > 0 && p.__version !== e.version) {
          var d = e.image;
          if (void 0 === d)
            console.warn(
              "THREE.WebGLRenderer: Texture marked for update but image is undefined",
              e
            );
          else {
            if (!1 !== d.complete)
              return void (function (e, i, u) {
                void 0 === e.__webglInit &&
                  ((e.__webglInit = !0),
                  i.addEventListener("dispose", h),
                  (e.__webglTexture = t.createTexture()),
                  a.textures++),
                  n.activeTexture(t.TEXTURE0 + u),
                  n.bindTexture(t.TEXTURE_2D, e.__webglTexture),
                  t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, i.flipY),
                  t.pixelStorei(
                    t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                    i.premultiplyAlpha
                  ),
                  t.pixelStorei(t.UNPACK_ALIGNMENT, i.unpackAlignment);
                var p = s(i.image, r.maxTextureSize);
                (function (t) {
                  return (
                    t.wrapS !== uo ||
                    t.wrapT !== uo ||
                    (t.minFilter !== po && t.minFilter !== go)
                  );
                })(i) &&
                  !1 === c(p) &&
                  (p = (function (t) {
                    if (
                      t instanceof HTMLImageElement ||
                      t instanceof HTMLCanvasElement ||
                      t instanceof ImageBitmap
                    ) {
                      var e = document.createElementNS(
                        "http://www.w3.org/1999/xhtml",
                        "canvas"
                      );
                      return (
                        (e.width = sa.floorPowerOfTwo(t.width)),
                        (e.height = sa.floorPowerOfTwo(t.height)),
                        e
                          .getContext("2d")
                          .drawImage(t, 0, 0, e.width, e.height),
                        console.warn(
                          "THREE.WebGLRenderer: image is not power of two (" +
                            t.width +
                            "x" +
                            t.height +
                            "). Resized to " +
                            e.width +
                            "x" +
                            e.height,
                          t
                        ),
                        e
                      );
                    }
                    return t;
                  })(p));
                var d = c(p),
                  m = o.convert(i.format),
                  g = o.convert(i.type);
                f(t.TEXTURE_2D, i, d);
                var y,
                  x = i.mipmaps;
                if (i.isDepthTexture) {
                  var b = t.DEPTH_COMPONENT;
                  if (i.type === To) {
                    if (!v)
                      throw new Error(
                        "Float Depth Texture only supported in WebGL2.0"
                      );
                    b = t.DEPTH_COMPONENT32F;
                  } else v && (b = t.DEPTH_COMPONENT16);
                  i.format === No &&
                    b === t.DEPTH_COMPONENT &&
                    i.type !== wo &&
                    i.type !== Eo &&
                    (console.warn(
                      "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
                    ),
                    (i.type = wo),
                    (g = o.convert(i.type))),
                    i.format === zo &&
                      ((b = t.DEPTH_STENCIL),
                      i.type !== Po &&
                        (console.warn(
                          "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                        ),
                        (i.type = Po),
                        (g = o.convert(i.type)))),
                    n.texImage2D(
                      t.TEXTURE_2D,
                      0,
                      b,
                      p.width,
                      p.height,
                      0,
                      m,
                      g,
                      null
                    );
                } else if (i.isDataTexture)
                  if (x.length > 0 && d) {
                    for (var _ = 0, w = x.length; _ < w; _++)
                      (y = x[_]),
                        n.texImage2D(
                          t.TEXTURE_2D,
                          _,
                          m,
                          y.width,
                          y.height,
                          0,
                          m,
                          g,
                          y.data
                        );
                    i.generateMipmaps = !1;
                  } else
                    n.texImage2D(
                      t.TEXTURE_2D,
                      0,
                      m,
                      p.width,
                      p.height,
                      0,
                      m,
                      g,
                      p.data
                    );
                else if (i.isCompressedTexture)
                  for (var _ = 0, w = x.length; _ < w; _++)
                    (y = x[_]),
                      i.format !== Io && i.format !== Oo
                        ? n.getCompressedTextureFormats().indexOf(m) > -1
                          ? n.compressedTexImage2D(
                              t.TEXTURE_2D,
                              _,
                              m,
                              y.width,
                              y.height,
                              0,
                              y.data
                            )
                          : console.warn(
                              "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                            )
                        : n.texImage2D(
                            t.TEXTURE_2D,
                            _,
                            m,
                            y.width,
                            y.height,
                            0,
                            m,
                            g,
                            y.data
                          );
                else if (x.length > 0 && d) {
                  for (var _ = 0, w = x.length; _ < w; _++)
                    (y = x[_]), n.texImage2D(t.TEXTURE_2D, _, m, m, g, y);
                  i.generateMipmaps = !1;
                } else n.texImage2D(t.TEXTURE_2D, 0, m, m, g, p);
                l(i, d) && t.generateMipmap(t.TEXTURE_2D),
                  (e.__version = i.version),
                  i.onUpdate && i.onUpdate(i);
              })(p, e, u);
            console.warn(
              "THREE.WebGLRenderer: Texture marked for update but image is incomplete",
              e
            );
          }
        }
        n.activeTexture(t.TEXTURE0 + u),
          n.bindTexture(t.TEXTURE_2D, p.__webglTexture);
      }
      function f(n, a, s) {
        var c;
        if (
          (s
            ? (t.texParameteri(n, t.TEXTURE_WRAP_S, o.convert(a.wrapS)),
              t.texParameteri(n, t.TEXTURE_WRAP_T, o.convert(a.wrapT)),
              t.texParameteri(n, t.TEXTURE_MAG_FILTER, o.convert(a.magFilter)),
              t.texParameteri(n, t.TEXTURE_MIN_FILTER, o.convert(a.minFilter)))
            : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
              t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE),
              (a.wrapS === uo && a.wrapT === uo) ||
                console.warn(
                  "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.",
                  a
                ),
              t.texParameteri(n, t.TEXTURE_MAG_FILTER, u(a.magFilter)),
              t.texParameteri(n, t.TEXTURE_MIN_FILTER, u(a.minFilter)),
              a.minFilter !== po &&
                a.minFilter !== go &&
                console.warn(
                  "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.",
                  a
                )),
          (c = e.get("EXT_texture_filter_anisotropic")))
        ) {
          if (a.type === To && null === e.get("OES_texture_float_linear"))
            return;
          if (a.type === So && null === e.get("OES_texture_half_float_linear"))
            return;
          (a.anisotropy > 1 || i.get(a).__currentAnisotropy) &&
            (t.texParameterf(
              n,
              c.TEXTURE_MAX_ANISOTROPY_EXT,
              Math.min(a.anisotropy, r.getMaxAnisotropy())
            ),
            (i.get(a).__currentAnisotropy = a.anisotropy));
        }
      }
      function m(e, r, a, s) {
        var c = o.convert(r.texture.format),
          l = o.convert(r.texture.type);
        n.texImage2D(s, 0, c, r.width, r.height, 0, c, l, null),
          t.bindFramebuffer(t.FRAMEBUFFER, e),
          t.framebufferTexture2D(
            t.FRAMEBUFFER,
            a,
            s,
            i.get(r.texture).__webglTexture,
            0
          ),
          t.bindFramebuffer(t.FRAMEBUFFER, null);
      }
      function g(e, n) {
        t.bindRenderbuffer(t.RENDERBUFFER, e),
          n.depthBuffer && !n.stencilBuffer
            ? (t.renderbufferStorage(
                t.RENDERBUFFER,
                t.DEPTH_COMPONENT16,
                n.width,
                n.height
              ),
              t.framebufferRenderbuffer(
                t.FRAMEBUFFER,
                t.DEPTH_ATTACHMENT,
                t.RENDERBUFFER,
                e
              ))
            : n.depthBuffer && n.stencilBuffer
            ? (t.renderbufferStorage(
                t.RENDERBUFFER,
                t.DEPTH_STENCIL,
                n.width,
                n.height
              ),
              t.framebufferRenderbuffer(
                t.FRAMEBUFFER,
                t.DEPTH_STENCIL_ATTACHMENT,
                t.RENDERBUFFER,
                e
              ))
            : t.renderbufferStorage(t.RENDERBUFFER, t.RGBA4, n.width, n.height),
          t.bindRenderbuffer(t.RENDERBUFFER, null);
      }
      var v =
        "undefined" != typeof WebGL2RenderingContext &&
        t instanceof window.WebGL2RenderingContext;
      (this.setTexture2D = d),
        (this.setTextureCube = function (e, u) {
          var p = i.get(e);
          if (6 === e.image.length)
            if (e.version > 0 && p.__version !== e.version) {
              p.__image__webglTextureCube ||
                (e.addEventListener("dispose", h),
                (p.__image__webglTextureCube = t.createTexture()),
                a.textures++),
                n.activeTexture(t.TEXTURE0 + u),
                n.bindTexture(t.TEXTURE_CUBE_MAP, p.__image__webglTextureCube),
                t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e.flipY);
              for (
                var d = e && e.isCompressedTexture,
                  m = e.image[0] && e.image[0].isDataTexture,
                  g = [],
                  v = 0;
                v < 6;
                v++
              )
                g[v] =
                  d || m
                    ? m
                      ? e.image[v].image
                      : e.image[v]
                    : s(e.image[v], r.maxCubemapSize);
              var y = c(g[0]),
                x = o.convert(e.format),
                b = o.convert(e.type);
              for (f(t.TEXTURE_CUBE_MAP, e, y), v = 0; v < 6; v++)
                if (d)
                  for (var _, w = g[v].mipmaps, M = 0, E = w.length; M < E; M++)
                    (_ = w[M]),
                      e.format !== Io && e.format !== Oo
                        ? n.getCompressedTextureFormats().indexOf(x) > -1
                          ? n.compressedTexImage2D(
                              t.TEXTURE_CUBE_MAP_POSITIVE_X + v,
                              M,
                              x,
                              _.width,
                              _.height,
                              0,
                              _.data
                            )
                          : console.warn(
                              "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                            )
                        : n.texImage2D(
                            t.TEXTURE_CUBE_MAP_POSITIVE_X + v,
                            M,
                            x,
                            _.width,
                            _.height,
                            0,
                            x,
                            b,
                            _.data
                          );
                else
                  m
                    ? n.texImage2D(
                        t.TEXTURE_CUBE_MAP_POSITIVE_X + v,
                        0,
                        x,
                        g[v].width,
                        g[v].height,
                        0,
                        x,
                        b,
                        g[v].data
                      )
                    : n.texImage2D(
                        t.TEXTURE_CUBE_MAP_POSITIVE_X + v,
                        0,
                        x,
                        x,
                        b,
                        g[v]
                      );
              l(e, y) && t.generateMipmap(t.TEXTURE_CUBE_MAP),
                (p.__version = e.version),
                e.onUpdate && e.onUpdate(e);
            } else
              n.activeTexture(t.TEXTURE0 + u),
                n.bindTexture(t.TEXTURE_CUBE_MAP, p.__image__webglTextureCube);
        }),
        (this.setTextureCubeDynamic = function (e, r) {
          n.activeTexture(t.TEXTURE0 + r),
            n.bindTexture(t.TEXTURE_CUBE_MAP, i.get(e).__webglTexture);
        }),
        (this.setupRenderTarget = function (e) {
          var r = i.get(e),
            o = i.get(e.texture);
          e.addEventListener("dispose", p),
            (o.__webglTexture = t.createTexture()),
            a.textures++;
          var s = !0 === e.isWebGLRenderTargetCube,
            u = c(e);
          if (s)
            for (r.__webglFramebuffer = [], h = 0; h < 6; h++)
              r.__webglFramebuffer[h] = t.createFramebuffer();
          else r.__webglFramebuffer = t.createFramebuffer();
          if (s) {
            n.bindTexture(t.TEXTURE_CUBE_MAP, o.__webglTexture),
              f(t.TEXTURE_CUBE_MAP, e.texture, u);
            for (var h = 0; h < 6; h++)
              m(
                r.__webglFramebuffer[h],
                e,
                t.COLOR_ATTACHMENT0,
                t.TEXTURE_CUBE_MAP_POSITIVE_X + h
              );
            l(e.texture, u) && t.generateMipmap(t.TEXTURE_CUBE_MAP),
              n.bindTexture(t.TEXTURE_CUBE_MAP, null);
          } else
            n.bindTexture(t.TEXTURE_2D, o.__webglTexture),
              f(t.TEXTURE_2D, e.texture, u),
              m(r.__webglFramebuffer, e, t.COLOR_ATTACHMENT0, t.TEXTURE_2D),
              l(e.texture, u) && t.generateMipmap(t.TEXTURE_2D),
              n.bindTexture(t.TEXTURE_2D, null);
          e.depthBuffer &&
            (function (e) {
              var n = i.get(e),
                r = !0 === e.isWebGLRenderTargetCube;
              if (e.depthTexture) {
                if (r)
                  throw new Error(
                    "target.depthTexture not supported in Cube render targets"
                  );
                !(function (e, n) {
                  if (n && n.isWebGLRenderTargetCube)
                    throw new Error(
                      "Depth Texture with cube render targets is not supported"
                    );
                  if (
                    (t.bindFramebuffer(t.FRAMEBUFFER, e),
                    !n.depthTexture || !n.depthTexture.isDepthTexture)
                  )
                    throw new Error(
                      "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
                    );
                  (i.get(n.depthTexture).__webglTexture &&
                    n.depthTexture.image.width === n.width &&
                    n.depthTexture.image.height === n.height) ||
                    ((n.depthTexture.image.width = n.width),
                    (n.depthTexture.image.height = n.height),
                    (n.depthTexture.needsUpdate = !0)),
                    d(n.depthTexture, 0);
                  var r = i.get(n.depthTexture).__webglTexture;
                  if (n.depthTexture.format === No)
                    t.framebufferTexture2D(
                      t.FRAMEBUFFER,
                      t.DEPTH_ATTACHMENT,
                      t.TEXTURE_2D,
                      r,
                      0
                    );
                  else {
                    if (n.depthTexture.format !== zo)
                      throw new Error("Unknown depthTexture format");
                    t.framebufferTexture2D(
                      t.FRAMEBUFFER,
                      t.DEPTH_STENCIL_ATTACHMENT,
                      t.TEXTURE_2D,
                      r,
                      0
                    );
                  }
                })(n.__webglFramebuffer, e);
              } else if (r) {
                n.__webglDepthbuffer = [];
                for (var o = 0; o < 6; o++)
                  t.bindFramebuffer(t.FRAMEBUFFER, n.__webglFramebuffer[o]),
                    (n.__webglDepthbuffer[o] = t.createRenderbuffer()),
                    g(n.__webglDepthbuffer[o], e);
              } else
                t.bindFramebuffer(t.FRAMEBUFFER, n.__webglFramebuffer),
                  (n.__webglDepthbuffer = t.createRenderbuffer()),
                  g(n.__webglDepthbuffer, e);
              t.bindFramebuffer(t.FRAMEBUFFER, null);
            })(e);
        }),
        (this.updateRenderTargetMipmap = function (e) {
          var r = e.texture;
          if (l(r, c(e))) {
            var o = e.isWebGLRenderTargetCube
                ? t.TEXTURE_CUBE_MAP
                : t.TEXTURE_2D,
              a = i.get(r).__webglTexture;
            n.bindTexture(o, a), t.generateMipmap(o), n.bindTexture(o, null);
          }
        });
    }
    function Xt(t, e, n, i) {
      st.call(this),
        (this.type = "PerspectiveCamera"),
        (this.fov = void 0 !== t ? t : 50),
        (this.zoom = 1),
        (this.near = void 0 !== n ? n : 0.1),
        (this.far = void 0 !== i ? i : 2e3),
        (this.focus = 10),
        (this.aspect = void 0 !== e ? e : 1),
        (this.view = null),
        (this.filmGauge = 35),
        (this.filmOffset = 0),
        this.updateProjectionMatrix();
    }
    function Yt(t) {
      Xt.call(this), (this.cameras = t || []);
    }
    function qt(t, e) {
      return {
        convert: function (n) {
          var i;
          if (n === lo) return t.REPEAT;
          if (n === uo) return t.CLAMP_TO_EDGE;
          if (n === ho) return t.MIRRORED_REPEAT;
          if (n === po) return t.NEAREST;
          if (n === fo) return t.NEAREST_MIPMAP_NEAREST;
          if (n === mo) return t.NEAREST_MIPMAP_LINEAR;
          if (n === go) return t.LINEAR;
          if (n === vo) return t.LINEAR_MIPMAP_NEAREST;
          if (n === yo) return t.LINEAR_MIPMAP_LINEAR;
          if (n === xo) return t.UNSIGNED_BYTE;
          if (n === Ao) return t.UNSIGNED_SHORT_4_4_4_4;
          if (n === Lo) return t.UNSIGNED_SHORT_5_5_5_1;
          if (n === Ro) return t.UNSIGNED_SHORT_5_6_5;
          if (n === bo) return t.BYTE;
          if (n === _o) return t.SHORT;
          if (n === wo) return t.UNSIGNED_SHORT;
          if (n === Mo) return t.INT;
          if (n === Eo) return t.UNSIGNED_INT;
          if (n === To) return t.FLOAT;
          if (n === So && null !== (i = e.get("OES_texture_half_float")))
            return i.HALF_FLOAT_OES;
          if (n === Co) return t.ALPHA;
          if (n === Oo) return t.RGB;
          if (n === Io) return t.RGBA;
          if (n === Do) return t.LUMINANCE;
          if (n === Uo) return t.LUMINANCE_ALPHA;
          if (n === No) return t.DEPTH_COMPONENT;
          if (n === zo) return t.DEPTH_STENCIL;
          if (n === Er) return t.FUNC_ADD;
          if (n === Tr) return t.FUNC_SUBTRACT;
          if (n === Sr) return t.FUNC_REVERSE_SUBTRACT;
          if (n === Rr) return t.ZERO;
          if (n === Pr) return t.ONE;
          if (n === Cr) return t.SRC_COLOR;
          if (n === Or) return t.ONE_MINUS_SRC_COLOR;
          if (n === Ir) return t.SRC_ALPHA;
          if (n === Dr) return t.ONE_MINUS_SRC_ALPHA;
          if (n === Ur) return t.DST_ALPHA;
          if (n === Nr) return t.ONE_MINUS_DST_ALPHA;
          if (n === zr) return t.DST_COLOR;
          if (n === kr) return t.ONE_MINUS_DST_COLOR;
          if (n === Fr) return t.SRC_ALPHA_SATURATE;
          if (
            (n === ko || n === Fo || n === Bo || n === Ho) &&
            null !== (i = e.get("WEBGL_compressed_texture_s3tc"))
          ) {
            if (n === ko) return i.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (n === Fo) return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (n === Bo) return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (n === Ho) return i.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          }
          if (
            (n === jo || n === Go || n === Vo || n === Wo) &&
            null !== (i = e.get("WEBGL_compressed_texture_pvrtc"))
          ) {
            if (n === jo) return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (n === Go) return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (n === Vo) return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (n === Wo) return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          }
          if (n === Xo && null !== (i = e.get("WEBGL_compressed_texture_etc1")))
            return i.COMPRESSED_RGB_ETC1_WEBGL;
          if (
            (n === Ar || n === Lr) &&
            null !== (i = e.get("EXT_blend_minmax"))
          ) {
            if (n === Ar) return i.MIN_EXT;
            if (n === Lr) return i.MAX_EXT;
          }
          return n === Po && null !== (i = e.get("WEBGL_depth_texture"))
            ? i.UNSIGNED_INT_24_8_WEBGL
            : 0;
        },
      };
    }
    function $t(t) {
      function e() {
        return null === z ? K : 1;
      }
      function r() {
        (xt = new (function (t) {
          var e = {};
          return {
            get: function (n) {
              if (void 0 !== e[n]) return e[n];
              var i;
              switch (n) {
                case "WEBGL_depth_texture":
                  i =
                    t.getExtension("WEBGL_depth_texture") ||
                    t.getExtension("MOZ_WEBGL_depth_texture") ||
                    t.getExtension("WEBKIT_WEBGL_depth_texture");
                  break;
                case "EXT_texture_filter_anisotropic":
                  i =
                    t.getExtension("EXT_texture_filter_anisotropic") ||
                    t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                    t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                  break;
                case "WEBGL_compressed_texture_s3tc":
                  i =
                    t.getExtension("WEBGL_compressed_texture_s3tc") ||
                    t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                    t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                  break;
                case "WEBGL_compressed_texture_pvrtc":
                  i =
                    t.getExtension("WEBGL_compressed_texture_pvrtc") ||
                    t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                  break;
                case "WEBGL_compressed_texture_etc1":
                  i = t.getExtension("WEBGL_compressed_texture_etc1");
                  break;
                default:
                  i = t.getExtension(n);
              }
              return (
                null === i &&
                  console.warn(
                    "THREE.WebGLRenderer: " + n + " extension not supported."
                  ),
                (e[n] = i),
                i
              );
            },
          };
        })(mt)).get("WEBGL_depth_texture"),
          xt.get("OES_texture_float"),
          xt.get("OES_texture_float_linear"),
          xt.get("OES_texture_half_float"),
          xt.get("OES_texture_half_float_linear"),
          xt.get("OES_standard_derivatives"),
          xt.get("OES_element_index_uint"),
          xt.get("ANGLE_instanced_arrays"),
          (Jt = new qt(mt, xt)),
          (bt = new (function (t, e, n) {
            function i(e) {
              if ("highp" === e) {
                if (
                  t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT)
                    .precision > 0 &&
                  t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT)
                    .precision > 0
                )
                  return "highp";
                e = "mediump";
              }
              return "mediump" === e &&
                t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT)
                  .precision > 0 &&
                t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT)
                  .precision > 0
                ? "mediump"
                : "lowp";
            }
            var r,
              o = void 0 !== n.precision ? n.precision : "highp",
              a = i(o);
            a !== o &&
              (console.warn(
                "THREE.WebGLRenderer:",
                o,
                "not supported, using",
                a,
                "instead."
              ),
              (o = a));
            var s = !0 === n.logarithmicDepthBuffer,
              c = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
              l = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
              u = t.getParameter(t.MAX_TEXTURE_SIZE),
              h = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
              p = t.getParameter(t.MAX_VERTEX_ATTRIBS),
              d = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
              f = t.getParameter(t.MAX_VARYING_VECTORS),
              m = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
              g = l > 0,
              v = !!e.get("OES_texture_float");
            return {
              getMaxAnisotropy: function () {
                if (void 0 !== r) return r;
                var n = e.get("EXT_texture_filter_anisotropic");
                return (r =
                  null !== n
                    ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                    : 0);
              },
              getMaxPrecision: i,
              precision: o,
              logarithmicDepthBuffer: s,
              maxTextures: c,
              maxVertexTextures: l,
              maxTextureSize: u,
              maxCubemapSize: h,
              maxAttributes: p,
              maxVertexUniforms: d,
              maxVaryings: f,
              maxFragmentUniforms: m,
              vertexTextures: g,
              floatFragmentTextures: v,
              floatVertexTextures: g && v,
            };
          })(mt, xt, t)),
          (_t = new (function (t, e, n) {
            function i(e, n, i) {
              var r = new Uint8Array(4),
                o = t.createTexture();
              t.bindTexture(e, o),
                t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST),
                t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
              for (var a = 0; a < i; a++)
                t.texImage2D(
                  n + a,
                  0,
                  t.RGBA,
                  1,
                  1,
                  0,
                  t.RGBA,
                  t.UNSIGNED_BYTE,
                  r
                );
              return o;
            }
            function r(e) {
              !0 !== x[e] && (t.enable(e), (x[e] = !0));
            }
            function o(e) {
              !1 !== x[e] && (t.disable(e), (x[e] = !1));
            }
            function a(e, i, a, s, c, l, u, h) {
              if ((e !== yr ? r(t.BLEND) : o(t.BLEND), e !== Mr)) {
                if (e !== w || h !== R)
                  switch (e) {
                    case br:
                      h
                        ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                          t.blendFuncSeparate(t.ONE, t.ONE, t.ONE, t.ONE))
                        : (t.blendEquation(t.FUNC_ADD),
                          t.blendFunc(t.SRC_ALPHA, t.ONE));
                      break;
                    case _r:
                      h
                        ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                          t.blendFuncSeparate(
                            t.ZERO,
                            t.ZERO,
                            t.ONE_MINUS_SRC_COLOR,
                            t.ONE_MINUS_SRC_ALPHA
                          ))
                        : (t.blendEquation(t.FUNC_ADD),
                          t.blendFunc(t.ZERO, t.ONE_MINUS_SRC_COLOR));
                      break;
                    case wr:
                      h
                        ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                          t.blendFuncSeparate(
                            t.ZERO,
                            t.SRC_COLOR,
                            t.ZERO,
                            t.SRC_ALPHA
                          ))
                        : (t.blendEquation(t.FUNC_ADD),
                          t.blendFunc(t.ZERO, t.SRC_COLOR));
                      break;
                    default:
                      h
                        ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                          t.blendFuncSeparate(
                            t.ONE,
                            t.ONE_MINUS_SRC_ALPHA,
                            t.ONE,
                            t.ONE_MINUS_SRC_ALPHA
                          ))
                        : (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                          t.blendFuncSeparate(
                            t.SRC_ALPHA,
                            t.ONE_MINUS_SRC_ALPHA,
                            t.ONE,
                            t.ONE_MINUS_SRC_ALPHA
                          ));
                  }
                (M = null),
                  (E = null),
                  (T = null),
                  (S = null),
                  (A = null),
                  (L = null);
              } else
                (c = c || i),
                  (l = l || a),
                  (u = u || s),
                  (i === M && c === S) ||
                    (t.blendEquationSeparate(n.convert(i), n.convert(c)),
                    (M = i),
                    (S = c)),
                  (a === E && s === T && l === A && u === L) ||
                    (t.blendFuncSeparate(
                      n.convert(a),
                      n.convert(s),
                      n.convert(l),
                      n.convert(u)
                    ),
                    (E = a),
                    (T = s),
                    (A = l),
                    (L = u));
              (w = e), (R = h);
            }
            function s(e) {
              P !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), (P = e));
            }
            function l(e) {
              e !== ar
                ? (r(t.CULL_FACE),
                  e !== C &&
                    (e === sr
                      ? t.cullFace(t.BACK)
                      : e === cr
                      ? t.cullFace(t.FRONT)
                      : t.cullFace(t.FRONT_AND_BACK)))
                : o(t.CULL_FACE),
                (C = e);
            }
            function u(e, n, i) {
              e
                ? (r(t.POLYGON_OFFSET_FILL),
                  (I === n && D === i) ||
                    (t.polygonOffset(n, i), (I = n), (D = i)))
                : o(t.POLYGON_OFFSET_FILL);
            }
            function h(e) {
              void 0 === e && (e = t.TEXTURE0 + U - 1),
                k !== e && (t.activeTexture(e), (k = e));
            }
            var p = new (function () {
                var e = !1,
                  n = new c(),
                  i = null,
                  r = new c(0, 0, 0, 0);
                return {
                  setMask: function (n) {
                    i === n || e || (t.colorMask(n, n, n, n), (i = n));
                  },
                  setLocked: function (t) {
                    e = t;
                  },
                  setClear: function (e, i, o, a, s) {
                    !0 === s && ((e *= a), (i *= a), (o *= a)),
                      n.set(e, i, o, a),
                      !1 === r.equals(n) &&
                        (t.clearColor(e, i, o, a), r.copy(n));
                  },
                  reset: function () {
                    (e = !1), (i = null), r.set(-1, 0, 0, 0);
                  },
                };
              })(),
              d = new (function () {
                var e = !1,
                  n = null,
                  i = null,
                  a = null;
                return {
                  setTest: function (e) {
                    e ? r(t.DEPTH_TEST) : o(t.DEPTH_TEST);
                  },
                  setMask: function (i) {
                    n === i || e || (t.depthMask(i), (n = i));
                  },
                  setFunc: function (e) {
                    if (i !== e) {
                      if (e)
                        switch (e) {
                          case Br:
                            t.depthFunc(t.NEVER);
                            break;
                          case Hr:
                            t.depthFunc(t.ALWAYS);
                            break;
                          case jr:
                            t.depthFunc(t.LESS);
                            break;
                          case Gr:
                            t.depthFunc(t.LEQUAL);
                            break;
                          case Vr:
                            t.depthFunc(t.EQUAL);
                            break;
                          case Wr:
                            t.depthFunc(t.GEQUAL);
                            break;
                          case Xr:
                            t.depthFunc(t.GREATER);
                            break;
                          case Yr:
                            t.depthFunc(t.NOTEQUAL);
                            break;
                          default:
                            t.depthFunc(t.LEQUAL);
                        }
                      else t.depthFunc(t.LEQUAL);
                      i = e;
                    }
                  },
                  setLocked: function (t) {
                    e = t;
                  },
                  setClear: function (e) {
                    a !== e && (t.clearDepth(e), (a = e));
                  },
                  reset: function () {
                    (e = !1), (n = null), (i = null), (a = null);
                  },
                };
              })(),
              f = new (function () {
                var e = !1,
                  n = null,
                  i = null,
                  a = null,
                  s = null,
                  c = null,
                  l = null,
                  u = null,
                  h = null;
                return {
                  setTest: function (e) {
                    e ? r(t.STENCIL_TEST) : o(t.STENCIL_TEST);
                  },
                  setMask: function (i) {
                    n === i || e || (t.stencilMask(i), (n = i));
                  },
                  setFunc: function (e, n, r) {
                    (i === e && a === n && s === r) ||
                      (t.stencilFunc(e, n, r), (i = e), (a = n), (s = r));
                  },
                  setOp: function (e, n, i) {
                    (c === e && l === n && u === i) ||
                      (t.stencilOp(e, n, i), (c = e), (l = n), (u = i));
                  },
                  setLocked: function (t) {
                    e = t;
                  },
                  setClear: function (e) {
                    h !== e && (t.clearStencil(e), (h = e));
                  },
                  reset: function () {
                    (e = !1),
                      (n = null),
                      (i = null),
                      (a = null),
                      (s = null),
                      (c = null),
                      (l = null),
                      (u = null),
                      (h = null);
                  },
                };
              })(),
              m = t.getParameter(t.MAX_VERTEX_ATTRIBS),
              g = new Uint8Array(m),
              v = new Uint8Array(m),
              y = new Uint8Array(m),
              x = {},
              b = null,
              _ = null,
              w = null,
              M = null,
              E = null,
              T = null,
              S = null,
              A = null,
              L = null,
              R = !1,
              P = null,
              C = null,
              O = null,
              I = null,
              D = null,
              U = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
              N = parseFloat(
                /^WebGL\ ([0-9])/.exec(t.getParameter(t.VERSION))[1]
              ),
              z = parseFloat(N) >= 1,
              k = null,
              F = {},
              B = new c(),
              H = new c(),
              j = {};
            return (
              (j[t.TEXTURE_2D] = i(t.TEXTURE_2D, t.TEXTURE_2D, 1)),
              (j[t.TEXTURE_CUBE_MAP] = i(
                t.TEXTURE_CUBE_MAP,
                t.TEXTURE_CUBE_MAP_POSITIVE_X,
                6
              )),
              p.setClear(0, 0, 0, 1),
              d.setClear(1),
              f.setClear(0),
              r(t.DEPTH_TEST),
              d.setFunc(Gr),
              s(!1),
              l(sr),
              r(t.CULL_FACE),
              r(t.BLEND),
              a(xr),
              {
                buffers: { color: p, depth: d, stencil: f },
                initAttributes: function () {
                  for (var t = 0, e = g.length; t < e; t++) g[t] = 0;
                },
                enableAttribute: function (n) {
                  (g[n] = 1),
                    0 === v[n] && (t.enableVertexAttribArray(n), (v[n] = 1)),
                    0 !== y[n] &&
                      (e
                        .get("ANGLE_instanced_arrays")
                        .vertexAttribDivisorANGLE(n, 0),
                      (y[n] = 0));
                },
                enableAttributeAndDivisor: function (n, i) {
                  (g[n] = 1),
                    0 === v[n] && (t.enableVertexAttribArray(n), (v[n] = 1)),
                    y[n] !== i &&
                      (e
                        .get("ANGLE_instanced_arrays")
                        .vertexAttribDivisorANGLE(n, i),
                      (y[n] = i));
                },
                disableUnusedAttributes: function () {
                  for (var e = 0, n = v.length; e !== n; ++e)
                    v[e] !== g[e] &&
                      (t.disableVertexAttribArray(e), (v[e] = 0));
                },
                enable: r,
                disable: o,
                getCompressedTextureFormats: function () {
                  if (
                    null === b &&
                    ((b = []),
                    e.get("WEBGL_compressed_texture_pvrtc") ||
                      e.get("WEBGL_compressed_texture_s3tc") ||
                      e.get("WEBGL_compressed_texture_etc1"))
                  )
                    for (
                      var n = t.getParameter(t.COMPRESSED_TEXTURE_FORMATS),
                        i = 0;
                      i < n.length;
                      i++
                    )
                      b.push(n[i]);
                  return b;
                },
                useProgram: function (e) {
                  return _ !== e && (t.useProgram(e), (_ = e), !0);
                },
                setBlending: a,
                setMaterial: function (e) {
                  e.side === fr ? o(t.CULL_FACE) : r(t.CULL_FACE),
                    s(e.side === dr),
                    !0 === e.transparent
                      ? a(
                          e.blending,
                          e.blendEquation,
                          e.blendSrc,
                          e.blendDst,
                          e.blendEquationAlpha,
                          e.blendSrcAlpha,
                          e.blendDstAlpha,
                          e.premultipliedAlpha
                        )
                      : a(yr),
                    d.setFunc(e.depthFunc),
                    d.setTest(e.depthTest),
                    d.setMask(e.depthWrite),
                    p.setMask(e.colorWrite),
                    u(
                      e.polygonOffset,
                      e.polygonOffsetFactor,
                      e.polygonOffsetUnits
                    );
                },
                setFlipSided: s,
                setCullFace: l,
                setLineWidth: function (e) {
                  e !== O && (z && t.lineWidth(e), (O = e));
                },
                setPolygonOffset: u,
                setScissorTest: function (e) {
                  e ? r(t.SCISSOR_TEST) : o(t.SCISSOR_TEST);
                },
                activeTexture: h,
                bindTexture: function (e, n) {
                  null === k && h();
                  var i = F[k];
                  void 0 === i &&
                    ((i = { type: void 0, texture: void 0 }), (F[k] = i)),
                    (i.type === e && i.texture === n) ||
                      (t.bindTexture(e, n || j[e]),
                      (i.type = e),
                      (i.texture = n));
                },
                compressedTexImage2D: function () {
                  try {
                    t.compressedTexImage2D.apply(t, arguments);
                  } catch (t) {
                    console.error("THREE.WebGLState:", t);
                  }
                },
                texImage2D: function () {
                  try {
                    t.texImage2D.apply(t, arguments);
                  } catch (t) {
                    console.error("THREE.WebGLState:", t);
                  }
                },
                scissor: function (e) {
                  !1 === B.equals(e) &&
                    (t.scissor(e.x, e.y, e.z, e.w), B.copy(e));
                },
                viewport: function (e) {
                  !1 === H.equals(e) &&
                    (t.viewport(e.x, e.y, e.z, e.w), H.copy(e));
                },
                reset: function () {
                  for (var e = 0; e < v.length; e++)
                    1 === v[e] && (t.disableVertexAttribArray(e), (v[e] = 0));
                  (x = {}),
                    (b = null),
                    (k = null),
                    (F = {}),
                    (_ = null),
                    (w = null),
                    (P = null),
                    (C = null),
                    p.reset(),
                    d.reset(),
                    f.reset();
                },
              }
            );
          })(mt, xt, Jt)).scissor(X.copy(rt).multiplyScalar(K)),
          _t.viewport(G.copy(tt).multiplyScalar(K)),
          (Et = new (function () {
            var t = {};
            return {
              get: function (e) {
                var n = e.uuid,
                  i = t[n];
                return void 0 === i && ((i = {}), (t[n] = i)), i;
              },
              remove: function (e) {
                delete t[e.uuid];
              },
              clear: function () {
                t = {};
              },
            };
          })()),
          (St = new Wt(mt, xt, _t, Et, bt, Jt, dt)),
          (Pt = new (function (t) {
            var e = {};
            return {
              get: function (t) {
                return (
                  t.isInterleavedBufferAttribute && (t = t.data), e[t.uuid]
                );
              },
              remove: function (n) {
                n.isInterleavedBufferAttribute && (n = n.data);
                var i = e[n.uuid];
                i && (t.deleteBuffer(i.buffer), delete e[n.uuid]);
              },
              update: function (n, i) {
                n.isInterleavedBufferAttribute && (n = n.data);
                var r = e[n.uuid];
                void 0 === r
                  ? (e[n.uuid] = (function (e, n) {
                      var i = e.array,
                        r = e.dynamic ? t.DYNAMIC_DRAW : t.STATIC_DRAW,
                        o = t.createBuffer();
                      t.bindBuffer(n, o),
                        t.bufferData(n, i, r),
                        e.onUploadCallback();
                      var a = t.FLOAT;
                      return (
                        i instanceof Float32Array
                          ? (a = t.FLOAT)
                          : i instanceof Float64Array
                          ? console.warn(
                              "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
                            )
                          : i instanceof Uint16Array
                          ? (a = t.UNSIGNED_SHORT)
                          : i instanceof Int16Array
                          ? (a = t.SHORT)
                          : i instanceof Uint32Array
                          ? (a = t.UNSIGNED_INT)
                          : i instanceof Int32Array
                          ? (a = t.INT)
                          : i instanceof Int8Array
                          ? (a = t.BYTE)
                          : i instanceof Uint8Array && (a = t.UNSIGNED_BYTE),
                        {
                          buffer: o,
                          type: a,
                          bytesPerElement: i.BYTES_PER_ELEMENT,
                          version: e.version,
                        }
                      );
                    })(n, i))
                  : r.version < n.version &&
                    ((function (e, n, i) {
                      var r = n.array,
                        o = n.updateRange;
                      t.bindBuffer(i, e),
                        !1 === n.dynamic
                          ? t.bufferData(i, r, t.STATIC_DRAW)
                          : -1 === o.count
                          ? t.bufferSubData(i, 0, r)
                          : 0 === o.count
                          ? console.error(
                              "THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually."
                            )
                          : (t.bufferSubData(
                              i,
                              o.offset * r.BYTES_PER_ELEMENT,
                              r.subarray(o.offset, o.offset + o.count)
                            ),
                            (o.count = -1));
                    })(r.buffer, n, i),
                    (r.version = n.version));
              },
            };
          })(mt)),
          (Ct = new (function (t, e, n) {
            function i(t) {
              var a = t.target,
                s = r[a.id];
              null !== s.index && e.remove(s.index);
              for (var c in s.attributes) e.remove(s.attributes[c]);
              a.removeEventListener("dispose", i), delete r[a.id];
              var l = o[a.id];
              l && (e.remove(l), delete o[a.id]),
                (l = o[s.id]) && (e.remove(l), delete o[s.id]),
                n.geometries--;
            }
            var r = {},
              o = {};
            return {
              get: function (t, e) {
                var o = r[e.id];
                return (
                  o ||
                  (e.addEventListener("dispose", i),
                  e.isBufferGeometry
                    ? (o = e)
                    : e.isGeometry &&
                      (void 0 === e._bufferGeometry &&
                        (e._bufferGeometry = new Mt().setFromObject(t)),
                      (o = e._bufferGeometry)),
                  (r[e.id] = o),
                  n.geometries++,
                  o)
                );
              },
              update: function (n) {
                var i = n.index,
                  r = n.attributes;
                null !== i && e.update(i, t.ELEMENT_ARRAY_BUFFER);
                for (var o in r) e.update(r[o], t.ARRAY_BUFFER);
                var a = n.morphAttributes;
                for (var o in a)
                  for (var s = a[o], c = 0, l = s.length; c < l; c++)
                    e.update(s[c], t.ARRAY_BUFFER);
              },
              getWireframeAttribute: function (n) {
                var i = o[n.id];
                if (i) return i;
                var r = [],
                  a = n.index,
                  s = n.attributes;
                if (null !== a)
                  for (var c = 0, l = (d = a.array).length; c < l; c += 3) {
                    var u = d[c + 0],
                      h = d[c + 1],
                      p = d[c + 2];
                    r.push(u, h, h, p, p, u);
                  }
                else
                  for (
                    var d = s.position.array, c = 0, l = d.length / 3 - 1;
                    c < l;
                    c += 3
                  ) {
                    var u = c + 0,
                      h = c + 1,
                      p = c + 2;
                    r.push(u, h, h, p, p, u);
                  }
                return (
                  (i = new (wt(r) > 65535 ? yt : gt)(r, 1)),
                  e.update(i, t.ELEMENT_ARRAY_BUFFER),
                  (o[n.id] = i),
                  i
                );
              },
            };
          })(mt, Pt, dt)),
          (Ot = new (function (t, e) {
            var n = {};
            return {
              update: function (i) {
                var r = e.frame,
                  o = i.geometry,
                  a = t.get(i, o);
                return (
                  n[a.id] !== r &&
                    (o.isGeometry && a.updateFromObject(i),
                    t.update(a),
                    (n[a.id] = r)),
                  a
                );
              },
              clear: function () {
                n = {};
              },
            };
          })(Ct, ft)),
          (Ht = new (function (t) {
            var e = {},
              n = new Float32Array(8);
            return {
              update: function (i, r, o, a) {
                var s = i.morphTargetInfluences,
                  c = s.length,
                  l = e[r.id];
                if (void 0 === l) {
                  for (l = [], p = 0; p < c; p++) l[p] = [p, 0];
                  e[r.id] = l;
                }
                for (
                  var u = o.morphTargets && r.morphAttributes.position,
                    h = o.morphNormals && r.morphAttributes.normal,
                    p = 0;
                  p < c;
                  p++
                )
                  0 !== (d = l[p])[1] &&
                    (u && r.removeAttribute("morphTarget" + p),
                    h && r.removeAttribute("morphNormal" + p));
                for (p = 0; p < c; p++) ((d = l[p])[0] = p), (d[1] = s[p]);
                for (l.sort(Nt), p = 0; p < 8; p++) {
                  var d = l[p];
                  if (d) {
                    var f = d[0],
                      m = d[1];
                    if (m) {
                      u && r.addAttribute("morphTarget" + p, u[f]),
                        h && r.addAttribute("morphNormal" + p, h[f]),
                        (n[p] = m);
                      continue;
                    }
                  }
                  n[p] = 0;
                }
                a.getUniforms().setValue(t, "morphTargetInfluences", n);
              },
            };
          })(mt)),
          (kt = new Vt(U, xt, bt)),
          (zt = new (function () {
            var t = new (function () {
                var t = {};
                return {
                  get: function (e) {
                    if (void 0 !== t[e.id]) return t[e.id];
                    var i;
                    switch (e.type) {
                      case "DirectionalLight":
                        i = {
                          direction: new o(),
                          color: new W(),
                          shadow: !1,
                          shadowBias: 0,
                          shadowRadius: 1,
                          shadowMapSize: new n(),
                        };
                        break;
                      case "SpotLight":
                        i = {
                          position: new o(),
                          direction: new o(),
                          color: new W(),
                          distance: 0,
                          coneCos: 0,
                          penumbraCos: 0,
                          decay: 0,
                          shadow: !1,
                          shadowBias: 0,
                          shadowRadius: 1,
                          shadowMapSize: new n(),
                        };
                        break;
                      case "PointLight":
                        i = {
                          position: new o(),
                          color: new W(),
                          distance: 0,
                          decay: 0,
                          shadow: !1,
                          shadowBias: 0,
                          shadowRadius: 1,
                          shadowMapSize: new n(),
                          shadowCameraNear: 1,
                          shadowCameraFar: 1e3,
                        };
                        break;
                      case "HemisphereLight":
                        i = {
                          direction: new o(),
                          skyColor: new W(),
                          groundColor: new W(),
                        };
                        break;
                      case "RectAreaLight":
                        i = {
                          color: new W(),
                          position: new o(),
                          halfWidth: new o(),
                          halfHeight: new o(),
                        };
                    }
                    return (t[e.id] = i), i;
                  },
                };
              })(),
              e = {
                hash: "",
                ambient: [0, 0, 0],
                directional: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                rectArea: [],
                point: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: [],
              },
              r = new o(),
              a = new i(),
              s = new i();
            return {
              setup: function (n, i, o) {
                for (
                  var c = 0,
                    l = 0,
                    u = 0,
                    h = 0,
                    p = 0,
                    d = 0,
                    f = 0,
                    m = 0,
                    g = o.matrixWorldInverse,
                    v = 0,
                    y = n.length;
                  v < y;
                  v++
                ) {
                  var x = n[v],
                    b = x.color,
                    _ = x.intensity,
                    w = x.distance,
                    M = x.shadow && x.shadow.map ? x.shadow.map.texture : null;
                  if (x.isAmbientLight)
                    (c += b.r * _), (l += b.g * _), (u += b.b * _);
                  else if (x.isDirectionalLight)
                    (T = t.get(x)).color
                      .copy(x.color)
                      .multiplyScalar(x.intensity),
                      T.direction.setFromMatrixPosition(x.matrixWorld),
                      r.setFromMatrixPosition(x.target.matrixWorld),
                      T.direction.sub(r),
                      T.direction.transformDirection(g),
                      (T.shadow = x.castShadow),
                      x.castShadow &&
                        ((E = x.shadow),
                        (T.shadowBias = E.bias),
                        (T.shadowRadius = E.radius),
                        (T.shadowMapSize = E.mapSize)),
                      (e.directionalShadowMap[h] = M),
                      (e.directionalShadowMatrix[h] = x.shadow.matrix),
                      (e.directional[h] = T),
                      h++;
                  else if (x.isSpotLight)
                    (T = t.get(x)).position.setFromMatrixPosition(
                      x.matrixWorld
                    ),
                      T.position.applyMatrix4(g),
                      T.color.copy(b).multiplyScalar(_),
                      (T.distance = w),
                      T.direction.setFromMatrixPosition(x.matrixWorld),
                      r.setFromMatrixPosition(x.target.matrixWorld),
                      T.direction.sub(r),
                      T.direction.transformDirection(g),
                      (T.coneCos = Math.cos(x.angle)),
                      (T.penumbraCos = Math.cos(x.angle * (1 - x.penumbra))),
                      (T.decay = 0 === x.distance ? 0 : x.decay),
                      (T.shadow = x.castShadow),
                      x.castShadow &&
                        ((E = x.shadow),
                        (T.shadowBias = E.bias),
                        (T.shadowRadius = E.radius),
                        (T.shadowMapSize = E.mapSize)),
                      (e.spotShadowMap[d] = M),
                      (e.spotShadowMatrix[d] = x.shadow.matrix),
                      (e.spot[d] = T),
                      d++;
                  else if (x.isRectAreaLight)
                    (T = t.get(x)).color
                      .copy(b)
                      .multiplyScalar(_ / (x.width * x.height)),
                      T.position.setFromMatrixPosition(x.matrixWorld),
                      T.position.applyMatrix4(g),
                      s.identity(),
                      a.copy(x.matrixWorld),
                      a.premultiply(g),
                      s.extractRotation(a),
                      T.halfWidth.set(0.5 * x.width, 0, 0),
                      T.halfHeight.set(0, 0.5 * x.height, 0),
                      T.halfWidth.applyMatrix4(s),
                      T.halfHeight.applyMatrix4(s),
                      (e.rectArea[f] = T),
                      f++;
                  else if (x.isPointLight) {
                    if (
                      ((T = t.get(x)).position.setFromMatrixPosition(
                        x.matrixWorld
                      ),
                      T.position.applyMatrix4(g),
                      T.color.copy(x.color).multiplyScalar(x.intensity),
                      (T.distance = x.distance),
                      (T.decay = 0 === x.distance ? 0 : x.decay),
                      (T.shadow = x.castShadow),
                      x.castShadow)
                    ) {
                      var E = x.shadow;
                      (T.shadowBias = E.bias),
                        (T.shadowRadius = E.radius),
                        (T.shadowMapSize = E.mapSize),
                        (T.shadowCameraNear = E.camera.near),
                        (T.shadowCameraFar = E.camera.far);
                    }
                    (e.pointShadowMap[p] = M),
                      (e.pointShadowMatrix[p] = x.shadow.matrix),
                      (e.point[p] = T),
                      p++;
                  } else if (x.isHemisphereLight) {
                    var T = t.get(x);
                    T.direction.setFromMatrixPosition(x.matrixWorld),
                      T.direction.transformDirection(g),
                      T.direction.normalize(),
                      T.skyColor.copy(x.color).multiplyScalar(_),
                      T.groundColor.copy(x.groundColor).multiplyScalar(_),
                      (e.hemi[m] = T),
                      m++;
                  }
                }
                (e.ambient[0] = c),
                  (e.ambient[1] = l),
                  (e.ambient[2] = u),
                  (e.directional.length = h),
                  (e.spot.length = d),
                  (e.rectArea.length = f),
                  (e.point.length = p),
                  (e.hemi.length = m),
                  (e.hash =
                    h + "," + p + "," + d + "," + f + "," + m + "," + i.length);
              },
              state: e,
            };
          })()),
          (Ft = new (function () {
            var t = {};
            return {
              get: function (e, n) {
                var i = e.id + "," + n.id,
                  r = t[i];
                return (
                  void 0 === r &&
                    ((r = new (function () {
                      var t = [],
                        e = 0,
                        n = [],
                        i = [];
                      return {
                        opaque: n,
                        transparent: i,
                        init: function () {
                          (e = 0), (n.length = 0), (i.length = 0);
                        },
                        push: function (r, o, a, s, c) {
                          var l = t[e];
                          void 0 === l
                            ? ((l = {
                                id: r.id,
                                object: r,
                                geometry: o,
                                material: a,
                                program: a.program,
                                renderOrder: r.renderOrder,
                                z: s,
                                group: c,
                              }),
                              (t[e] = l))
                            : ((l.id = r.id),
                              (l.object = r),
                              (l.geometry = o),
                              (l.material = a),
                              (l.program = a.program),
                              (l.renderOrder = r.renderOrder),
                              (l.z = s),
                              (l.group = c)),
                            (!0 === a.transparent ? i : n).push(l),
                            e++;
                        },
                        sort: function () {
                          n.length > 1 && n.sort(Dt),
                            i.length > 1 && i.sort(Ut);
                        },
                      };
                    })()),
                    (t[i] = r)),
                  r
                );
              },
              dispose: function () {
                t = {};
              },
            };
          })()),
          (Bt = new (function (t, e, n, i) {
            function r(t, n) {
              e.buffers.color.setClear(t.r, t.g, t.b, n, i);
            }
            var o,
              a,
              s,
              c = new W(0),
              l = 0;
            return {
              getClearColor: function () {
                return c;
              },
              setClearColor: function (t, e) {
                c.set(t), r(c, (l = void 0 !== e ? e : 1));
              },
              getClearAlpha: function () {
                return l;
              },
              setClearAlpha: function (t) {
                r(c, (l = t));
              },
              render: function (e, i, u, h) {
                var p = i.background;
                null === p ? r(c, l) : p && p.isColor && (r(p, 1), (h = !0)),
                  (t.autoClear || h) &&
                    t.clear(
                      t.autoClearColor,
                      t.autoClearDepth,
                      t.autoClearStencil
                    ),
                  p && p.isCubeTexture
                    ? (void 0 === s &&
                        ((s = new It(
                          new Tt(1, 1, 1),
                          new Rt({
                            uniforms: ba.cube.uniforms,
                            vertexShader: ba.cube.vertexShader,
                            fragmentShader: ba.cube.fragmentShader,
                            side: dr,
                            depthTest: !0,
                            depthWrite: !1,
                            fog: !1,
                          })
                        )).geometry.removeAttribute("normal"),
                        s.geometry.removeAttribute("uv"),
                        (s.onBeforeRender = function (t, e, n) {
                          this.matrixWorld.copyPosition(n.matrixWorld);
                        }),
                        n.update(s.geometry)),
                      (s.material.uniforms.tCube.value = p),
                      e.push(s, s.geometry, s.material, 0, null))
                    : p &&
                      p.isTexture &&
                      (void 0 === o &&
                        ((o = new ct(-1, 1, 1, -1, 0, 1)),
                        (a = new It(
                          new At(2, 2),
                          new Lt({ depthTest: !1, depthWrite: !1, fog: !1 })
                        )),
                        n.update(a.geometry)),
                      (a.material.map = p),
                      t.renderBufferDirect(
                        o,
                        null,
                        a.geometry,
                        a.material,
                        a,
                        null
                      ));
              },
            };
          })(U, _t, Ct, L)),
          (jt = new (function (t, e, n) {
            var i;
            (this.setMode = function (t) {
              i = t;
            }),
              (this.render = function (e, r) {
                t.drawArrays(i, e, r),
                  n.calls++,
                  (n.vertices += r),
                  i === t.TRIANGLES
                    ? (n.faces += r / 3)
                    : i === t.POINTS && (n.points += r);
              }),
              (this.renderInstances = function (r, o, a) {
                var s = e.get("ANGLE_instanced_arrays");
                if (null !== s) {
                  var c = r.attributes.position;
                  c.isInterleavedBufferAttribute
                    ? ((a = c.data.count),
                      s.drawArraysInstancedANGLE(i, 0, a, r.maxInstancedCount))
                    : s.drawArraysInstancedANGLE(i, o, a, r.maxInstancedCount),
                    n.calls++,
                    (n.vertices += a * r.maxInstancedCount),
                    i === t.TRIANGLES
                      ? (n.faces += (r.maxInstancedCount * a) / 3)
                      : i === t.POINTS && (n.points += r.maxInstancedCount * a);
                } else
                  console.error(
                    "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
                  );
              });
          })(mt, xt, ft)),
          (Gt = new (function (t, e, n) {
            var i, r, o;
            (this.setMode = function (t) {
              i = t;
            }),
              (this.setIndex = function (t) {
                (r = t.type), (o = t.bytesPerElement);
              }),
              (this.render = function (e, a) {
                t.drawElements(i, a, r, e * o),
                  n.calls++,
                  (n.vertices += a),
                  i === t.TRIANGLES
                    ? (n.faces += a / 3)
                    : i === t.POINTS && (n.points += a);
              }),
              (this.renderInstances = function (a, s, c) {
                var l = e.get("ANGLE_instanced_arrays");
                null !== l
                  ? (l.drawElementsInstancedANGLE(
                      i,
                      c,
                      r,
                      s * o,
                      a.maxInstancedCount
                    ),
                    n.calls++,
                    (n.vertices += c * a.maxInstancedCount),
                    i === t.TRIANGLES
                      ? (n.faces += (a.maxInstancedCount * c) / 3)
                      : i === t.POINTS && (n.points += a.maxInstancedCount * c))
                  : console.error(
                      "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
                    );
              });
          })(mt, xt, ft)),
          ($t = new Y(U, mt, _t, St, bt)),
          (Zt = new $(U, mt, _t, St, bt)),
          (U.info.programs = kt.programs),
          (U.context = mt),
          (U.capabilities = bt),
          (U.extensions = xt),
          (U.properties = Et),
          (U.renderLists = Ft),
          (U.state = _t);
      }
      function s(t) {
        t.preventDefault(),
          console.log("THREE.WebGLRenderer: Context Lost."),
          (N = !0);
      }
      function l() {
        console.log("THREE.WebGLRenderer: Context Restored."), (N = !1), r();
      }
      function u(t) {
        var e = t.target;
        e.removeEventListener("dispose", u),
          (function (t) {
            p(t), Et.remove(t);
          })(e);
      }
      function p(t) {
        var e = Et.get(t).program;
        (t.program = void 0), void 0 !== e && kt.releaseProgram(e);
      }
      function d(t) {
        null !== ee && ee(t);
        var e = Qt.getDevice();
        e && e.isPresenting
          ? e.requestAnimationFrame(d)
          : window.requestAnimationFrame(d);
      }
      function f(t, e, n) {
        if (!1 !== t.visible) {
          if (t.layers.test(e.layers))
            if (t.isLight) P.push(t), t.castShadow && C.push(t);
            else if (t.isSprite)
              (t.frustumCulled && !at.intersectsSprite(t)) || I.push(t);
            else if (t.isLensFlare) D.push(t);
            else if (t.isImmediateRenderObject)
              n && pt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(ht),
                O.push(t, null, t.material, pt.z, null);
            else if (
              (t.isMesh || t.isLine || t.isPoints) &&
              (t.isSkinnedMesh && t.skeleton.update(),
              !t.frustumCulled || at.intersectsObject(t))
            ) {
              n && pt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(ht);
              var i = Ot.update(t),
                r = t.material;
              if (Array.isArray(r))
                for (var o = i.groups, a = 0, s = o.length; a < s; a++) {
                  var c = o[a],
                    l = r[c.materialIndex];
                  l && l.visible && O.push(t, i, l, pt.z, c);
                }
              else r.visible && O.push(t, i, r, pt.z, null);
            }
          for (var u = t.children, a = 0, s = u.length; a < s; a++)
            f(u[a], e, n);
        }
      }
      function m(t, e, n, i) {
        for (var r = 0, o = t.length; r < o; r++) {
          var a = t[r],
            s = a.object,
            c = a.geometry,
            l = void 0 === i ? a.material : i,
            u = a.group;
          if (n.isArrayCamera) {
            j = n;
            for (var h = n.cameras, p = 0, d = h.length; p < d; p++) {
              var f = h[p];
              if (s.layers.test(f.layers)) {
                var m = f.bounds,
                  v = m.x * J,
                  y = m.y * Q,
                  x = m.z * J,
                  b = m.w * Q;
                _t.viewport(G.set(v, y, x, b).multiplyScalar(K)),
                  g(s, e, f, c, l, u);
              }
            }
          } else (j = null), g(s, e, n, c, l, u);
        }
      }
      function g(t, e, n, i, r, o) {
        if (
          (t.onBeforeRender(U, e, n, i, r, o),
          t.modelViewMatrix.multiplyMatrices(
            n.matrixWorldInverse,
            t.matrixWorld
          ),
          t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
          t.isImmediateRenderObject)
        ) {
          _t.setMaterial(r);
          var a = y(n, e.fog, r, t);
          (B = ""),
            (function (t, e, n) {
              t.render(function (t) {
                U.renderBufferImmediate(t, e, n);
              });
            })(t, a, r);
        } else U.renderBufferDirect(n, e.fog, i, r, t, o);
        t.onAfterRender(U, e, n, i, r, o);
      }
      function v(t, e, n) {
        var i = Et.get(t),
          r = kt.getParameters(
            t,
            zt.state,
            C,
            e,
            st.numPlanes,
            st.numIntersection,
            n
          ),
          o = kt.getProgramCode(t, r),
          a = i.program,
          s = !0;
        if (void 0 === a) t.addEventListener("dispose", u);
        else if (a.code !== o) p(t);
        else {
          if (void 0 !== r.shaderID) return;
          s = !1;
        }
        if (s) {
          if (r.shaderID) {
            var c = ba[r.shaderID];
            i.shader = {
              name: t.type,
              uniforms: ya.clone(c.uniforms),
              vertexShader: c.vertexShader,
              fragmentShader: c.fragmentShader,
            };
          } else
            i.shader = {
              name: t.type,
              uniforms: t.uniforms,
              vertexShader: t.vertexShader,
              fragmentShader: t.fragmentShader,
            };
          t.onBeforeCompile(i.shader),
            (a = kt.acquireProgram(t, i.shader, r, o)),
            (i.program = a),
            (t.program = a);
        }
        var l = a.getAttributes();
        if (t.morphTargets)
          for (
            t.numSupportedMorphTargets = 0, h = 0;
            h < U.maxMorphTargets;
            h++
          )
            l["morphTarget" + h] >= 0 && t.numSupportedMorphTargets++;
        if (t.morphNormals) {
          t.numSupportedMorphNormals = 0;
          for (var h = 0; h < U.maxMorphNormals; h++)
            l["morphNormal" + h] >= 0 && t.numSupportedMorphNormals++;
        }
        var d = i.shader.uniforms;
        ((t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping) ||
          ((i.numClippingPlanes = st.numPlanes),
          (i.numIntersection = st.numIntersection),
          (d.clippingPlanes = st.uniform)),
          (i.fog = e),
          (i.lightsHash = zt.state.hash),
          t.lights &&
            ((d.ambientLightColor.value = zt.state.ambient),
            (d.directionalLights.value = zt.state.directional),
            (d.spotLights.value = zt.state.spot),
            (d.rectAreaLights.value = zt.state.rectArea),
            (d.pointLights.value = zt.state.point),
            (d.hemisphereLights.value = zt.state.hemi),
            (d.directionalShadowMap.value = zt.state.directionalShadowMap),
            (d.directionalShadowMatrix.value =
              zt.state.directionalShadowMatrix),
            (d.spotShadowMap.value = zt.state.spotShadowMap),
            (d.spotShadowMatrix.value = zt.state.spotShadowMatrix),
            (d.pointShadowMap.value = zt.state.pointShadowMap),
            (d.pointShadowMatrix.value = zt.state.pointShadowMatrix));
        var f = i.program.getUniforms(),
          m = V.seqWithValue(f.seq, d);
        i.uniformsList = m;
      }
      function y(t, e, n, i) {
        Z = 0;
        var r = Et.get(n);
        if (lt && (ut || t !== H)) {
          var o = t === H && n.id === F;
          st.setState(
            n.clippingPlanes,
            n.clipIntersection,
            n.clipShadows,
            t,
            r,
            o
          );
        }
        !1 === n.needsUpdate &&
          (void 0 === r.program
            ? (n.needsUpdate = !0)
            : n.fog && r.fog !== e
            ? (n.needsUpdate = !0)
            : n.lights && r.lightsHash !== zt.state.hash
            ? (n.needsUpdate = !0)
            : void 0 === r.numClippingPlanes ||
              (r.numClippingPlanes === st.numPlanes &&
                r.numIntersection === st.numIntersection) ||
              (n.needsUpdate = !0)),
          n.needsUpdate && (v(n, e, i), (n.needsUpdate = !1));
        var a = !1,
          s = !1,
          c = !1,
          l = r.program,
          u = l.getUniforms(),
          p = r.shader.uniforms;
        if (
          (_t.useProgram(l.program) && ((a = !0), (s = !0), (c = !0)),
          n.id !== F && ((F = n.id), (s = !0)),
          a || t !== H)
        ) {
          if (
            (u.setValue(mt, "projectionMatrix", t.projectionMatrix),
            bt.logarithmicDepthBuffer &&
              u.setValue(
                mt,
                "logDepthBufFC",
                2 / (Math.log(t.far + 1) / Math.LN2)
              ),
            H !== (j || t) && ((H = j || t), (s = !0), (c = !0)),
            n.isShaderMaterial ||
              n.isMeshPhongMaterial ||
              n.isMeshStandardMaterial ||
              n.envMap)
          ) {
            var d = u.map.cameraPosition;
            void 0 !== d &&
              d.setValue(mt, pt.setFromMatrixPosition(t.matrixWorld));
          }
          (n.isMeshPhongMaterial ||
            n.isMeshLambertMaterial ||
            n.isMeshBasicMaterial ||
            n.isMeshStandardMaterial ||
            n.isShaderMaterial ||
            n.skinning) &&
            u.setValue(mt, "viewMatrix", t.matrixWorldInverse);
        }
        if (n.skinning) {
          u.setOptional(mt, i, "bindMatrix"),
            u.setOptional(mt, i, "bindMatrixInverse");
          var f = i.skeleton;
          if (f) {
            var m = f.bones;
            if (bt.floatVertexTextures) {
              if (void 0 === f.boneTexture) {
                var g = Math.sqrt(4 * m.length);
                (g = sa.ceilPowerOfTwo(g)), (g = Math.max(g, 4));
                var y = new Float32Array(g * g * 4);
                y.set(f.boneMatrices);
                var w = new h(y, g, g, Io, To);
                (f.boneMatrices = y),
                  (f.boneTexture = w),
                  (f.boneTextureSize = g);
              }
              u.setValue(mt, "boneTexture", f.boneTexture),
                u.setValue(mt, "boneTextureSize", f.boneTextureSize);
            } else u.setOptional(mt, f, "boneMatrices");
          }
        }
        return (
          s &&
            (u.setValue(mt, "toneMappingExposure", U.toneMappingExposure),
            u.setValue(mt, "toneMappingWhitePoint", U.toneMappingWhitePoint),
            n.lights &&
              (function (t, e) {
                (t.ambientLightColor.needsUpdate = e),
                  (t.directionalLights.needsUpdate = e),
                  (t.pointLights.needsUpdate = e),
                  (t.spotLights.needsUpdate = e),
                  (t.rectAreaLights.needsUpdate = e),
                  (t.hemisphereLights.needsUpdate = e);
              })(p, c),
            e &&
              n.fog &&
              (function (t, e) {
                (t.fogColor.value = e.color),
                  e.isFog
                    ? ((t.fogNear.value = e.near), (t.fogFar.value = e.far))
                    : e.isFogExp2 && (t.fogDensity.value = e.density);
              })(p, e),
            n.isMeshBasicMaterial
              ? x(p, n)
              : n.isMeshLambertMaterial
              ? (x(p, n),
                (function (t, e) {
                  e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                })(p, n))
              : n.isMeshPhongMaterial
              ? (x(p, n),
                n.isMeshToonMaterial
                  ? (function (t, e) {
                      b(t, e),
                        e.gradientMap && (t.gradientMap.value = e.gradientMap);
                    })(p, n)
                  : b(p, n))
              : n.isMeshStandardMaterial
              ? (x(p, n),
                n.isMeshPhysicalMaterial
                  ? (function (t, e) {
                      (t.clearCoat.value = e.clearCoat),
                        (t.clearCoatRoughness.value = e.clearCoatRoughness),
                        _(t, e);
                    })(p, n)
                  : _(p, n))
              : n.isMeshDepthMaterial
              ? (x(p, n),
                (function (t, e) {
                  e.displacementMap &&
                    ((t.displacementMap.value = e.displacementMap),
                    (t.displacementScale.value = e.displacementScale),
                    (t.displacementBias.value = e.displacementBias));
                })(p, n))
              : n.isMeshDistanceMaterial
              ? (x(p, n),
                (function (t, e) {
                  e.displacementMap &&
                    ((t.displacementMap.value = e.displacementMap),
                    (t.displacementScale.value = e.displacementScale),
                    (t.displacementBias.value = e.displacementBias)),
                    t.referencePosition.value.copy(e.referencePosition),
                    (t.nearDistance.value = e.nearDistance),
                    (t.farDistance.value = e.farDistance);
                })(p, n))
              : n.isMeshNormalMaterial
              ? (x(p, n),
                (function (t, e) {
                  e.bumpMap &&
                    ((t.bumpMap.value = e.bumpMap),
                    (t.bumpScale.value = e.bumpScale)),
                    e.normalMap &&
                      ((t.normalMap.value = e.normalMap),
                      t.normalScale.value.copy(e.normalScale)),
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias));
                })(p, n))
              : n.isLineBasicMaterial
              ? ((function (t, e) {
                  (t.diffuse.value = e.color), (t.opacity.value = e.opacity);
                })(p, n),
                n.isLineDashedMaterial &&
                  (function (t, e) {
                    (t.dashSize.value = e.dashSize),
                      (t.totalSize.value = e.dashSize + e.gapSize),
                      (t.scale.value = e.scale);
                  })(p, n))
              : n.isPointsMaterial
              ? (function (t, e) {
                  if (
                    ((t.diffuse.value = e.color),
                    (t.opacity.value = e.opacity),
                    (t.size.value = e.size * K),
                    (t.scale.value = 0.5 * Q),
                    (t.map.value = e.map),
                    null !== e.map)
                  ) {
                    if (!0 === e.map.matrixAutoUpdate) {
                      var n = e.map.offset,
                        i = e.map.repeat,
                        r = e.map.rotation,
                        o = e.map.center;
                      e.map.matrix.setUvTransform(
                        n.x,
                        n.y,
                        i.x,
                        i.y,
                        r,
                        o.x,
                        o.y
                      );
                    }
                    t.uvTransform.value.copy(e.map.matrix);
                  }
                })(p, n)
              : n.isShadowMaterial &&
                ((p.color.value = n.color), (p.opacity.value = n.opacity)),
            void 0 !== p.ltcMat && (p.ltcMat.value = va.LTC_MAT_TEXTURE),
            void 0 !== p.ltcMag && (p.ltcMag.value = va.LTC_MAG_TEXTURE),
            V.upload(mt, r.uniformsList, p, U)),
          u.setValue(mt, "modelViewMatrix", i.modelViewMatrix),
          u.setValue(mt, "normalMatrix", i.normalMatrix),
          u.setValue(mt, "modelMatrix", i.matrixWorld),
          l
        );
      }
      function x(t, e) {
        (t.opacity.value = e.opacity),
          e.color && (t.diffuse.value = e.color),
          e.emissive &&
            t.emissive.value
              .copy(e.emissive)
              .multiplyScalar(e.emissiveIntensity),
          e.map && (t.map.value = e.map),
          e.alphaMap && (t.alphaMap.value = e.alphaMap),
          e.specularMap && (t.specularMap.value = e.specularMap),
          e.envMap &&
            ((t.envMap.value = e.envMap),
            (t.flipEnvMap.value = e.envMap && e.envMap.isCubeTexture ? -1 : 1),
            (t.reflectivity.value = e.reflectivity),
            (t.refractionRatio.value = e.refractionRatio)),
          e.lightMap &&
            ((t.lightMap.value = e.lightMap),
            (t.lightMapIntensity.value = e.lightMapIntensity)),
          e.aoMap &&
            ((t.aoMap.value = e.aoMap),
            (t.aoMapIntensity.value = e.aoMapIntensity));
        var n;
        if (
          (e.map
            ? (n = e.map)
            : e.specularMap
            ? (n = e.specularMap)
            : e.displacementMap
            ? (n = e.displacementMap)
            : e.normalMap
            ? (n = e.normalMap)
            : e.bumpMap
            ? (n = e.bumpMap)
            : e.roughnessMap
            ? (n = e.roughnessMap)
            : e.metalnessMap
            ? (n = e.metalnessMap)
            : e.alphaMap
            ? (n = e.alphaMap)
            : e.emissiveMap && (n = e.emissiveMap),
          void 0 !== n)
        ) {
          if (
            (n.isWebGLRenderTarget && (n = n.texture),
            !0 === n.matrixAutoUpdate)
          ) {
            var i = n.offset,
              r = n.repeat,
              o = n.rotation,
              a = n.center;
            n.matrix.setUvTransform(i.x, i.y, r.x, r.y, o, a.x, a.y);
          }
          t.uvTransform.value.copy(n.matrix);
        }
      }
      function b(t, e) {
        (t.specular.value = e.specular),
          (t.shininess.value = Math.max(e.shininess, 1e-4)),
          e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
          e.bumpMap &&
            ((t.bumpMap.value = e.bumpMap), (t.bumpScale.value = e.bumpScale)),
          e.normalMap &&
            ((t.normalMap.value = e.normalMap),
            t.normalScale.value.copy(e.normalScale)),
          e.displacementMap &&
            ((t.displacementMap.value = e.displacementMap),
            (t.displacementScale.value = e.displacementScale),
            (t.displacementBias.value = e.displacementBias));
      }
      function _(t, e) {
        (t.roughness.value = e.roughness),
          (t.metalness.value = e.metalness),
          e.roughnessMap && (t.roughnessMap.value = e.roughnessMap),
          e.metalnessMap && (t.metalnessMap.value = e.metalnessMap),
          e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
          e.bumpMap &&
            ((t.bumpMap.value = e.bumpMap), (t.bumpScale.value = e.bumpScale)),
          e.normalMap &&
            ((t.normalMap.value = e.normalMap),
            t.normalScale.value.copy(e.normalScale)),
          e.displacementMap &&
            ((t.displacementMap.value = e.displacementMap),
            (t.displacementScale.value = e.displacementScale),
            (t.displacementBias.value = e.displacementBias)),
          e.envMap && (t.envMapIntensity.value = e.envMapIntensity);
      }
      console.log("THREE.WebGLRenderer", or);
      var w =
          void 0 !== (t = t || {}).canvas
            ? t.canvas
            : document.createElementNS(
                "http://www.w3.org/1999/xhtml",
                "canvas"
              ),
        M = void 0 !== t.context ? t.context : null,
        E = void 0 !== t.alpha && t.alpha,
        T = void 0 === t.depth || t.depth,
        S = void 0 === t.stencil || t.stencil,
        A = void 0 !== t.antialias && t.antialias,
        L = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
        R = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
        P = [],
        C = [],
        O = null,
        I = [],
        D = [];
      (this.domElement = w),
        (this.context = null),
        (this.autoClear = !0),
        (this.autoClearColor = !0),
        (this.autoClearDepth = !0),
        (this.autoClearStencil = !0),
        (this.sortObjects = !0),
        (this.clippingPlanes = []),
        (this.localClippingEnabled = !1),
        (this.gammaFactor = 2),
        (this.gammaInput = !1),
        (this.gammaOutput = !1),
        (this.physicallyCorrectLights = !1),
        (this.toneMapping = Qr),
        (this.toneMappingExposure = 1),
        (this.toneMappingWhitePoint = 1),
        (this.maxMorphTargets = 8),
        (this.maxMorphNormals = 4);
      var U = this,
        N = !1,
        z = null,
        k = null,
        F = -1,
        B = "",
        H = null,
        j = null,
        G = new c(),
        X = new c(),
        q = null,
        Z = 0,
        J = w.width,
        Q = w.height,
        K = 1,
        tt = new c(0, 0, J, Q),
        rt = new c(0, 0, J, Q),
        ot = !1,
        at = new nt(),
        st = new (function () {
          function t() {
            u.value !== i && ((u.value = i), (u.needsUpdate = r > 0)),
              (n.numPlanes = r),
              (n.numIntersection = 0);
          }
          function e(t, e, i, r) {
            var o = null !== t ? t.length : 0,
              a = null;
            if (0 !== o) {
              if (((a = u.value), !0 !== r || null === a)) {
                var s = i + 4 * o,
                  h = e.matrixWorldInverse;
                l.getNormalMatrix(h),
                  (null === a || a.length < s) && (a = new Float32Array(s));
                for (var p = 0, d = i; p !== o; ++p, d += 4)
                  c.copy(t[p]).applyMatrix4(h, l),
                    c.normal.toArray(a, d),
                    (a[d + 3] = c.constant);
              }
              (u.value = a), (u.needsUpdate = !0);
            }
            return (n.numPlanes = o), a;
          }
          var n = this,
            i = null,
            r = 0,
            o = !1,
            s = !1,
            c = new et(),
            l = new a(),
            u = { value: null, needsUpdate: !1 };
          (this.uniform = u),
            (this.numPlanes = 0),
            (this.numIntersection = 0),
            (this.init = function (t, n, a) {
              var s = 0 !== t.length || n || 0 !== r || o;
              return (o = n), (i = e(t, a, 0)), (r = t.length), s;
            }),
            (this.beginShadows = function () {
              (s = !0), e(null);
            }),
            (this.endShadows = function () {
              (s = !1), t();
            }),
            (this.setState = function (n, a, c, l, h, p) {
              if (!o || null === n || 0 === n.length || (s && !c))
                s ? e(null) : t();
              else {
                var d = s ? 0 : r,
                  f = 4 * d,
                  m = h.clippingState || null;
                (u.value = m), (m = e(n, l, f, p));
                for (var g = 0; g !== f; ++g) m[g] = i[g];
                (h.clippingState = m),
                  (this.numIntersection = a ? this.numPlanes : 0),
                  (this.numPlanes += d);
              }
            });
        })(),
        lt = !1,
        ut = !1,
        ht = new i(),
        pt = new o(),
        dt = { geometries: 0, textures: 0 },
        ft = { frame: 0, calls: 0, vertices: 0, faces: 0, points: 0 };
      this.info = { render: ft, memory: dt, programs: null };
      var mt;
      try {
        var vt = {
          alpha: E,
          depth: T,
          stencil: S,
          antialias: A,
          premultipliedAlpha: L,
          preserveDrawingBuffer: R,
        };
        if (
          null ===
          (mt =
            M ||
            w.getContext("webgl", vt) ||
            w.getContext("experimental-webgl", vt))
        )
          throw null !== w.getContext("webgl")
            ? "Error creating WebGL context with your selected attributes."
            : "Error creating WebGL context.";
        void 0 === mt.getShaderPrecisionFormat &&
          (mt.getShaderPrecisionFormat = function () {
            return { rangeMin: 1, rangeMax: 1, precision: 1 };
          }),
          w.addEventListener("webglcontextlost", s, !1),
          w.addEventListener("webglcontextrestored", l, !1);
      } catch (t) {
        console.error("THREE.WebGLRenderer: " + t);
      }
      var xt,
        bt,
        _t,
        Et,
        St,
        Pt,
        Ct,
        Ot,
        zt,
        kt,
        Ft,
        Bt,
        Ht,
        jt,
        Gt,
        $t,
        Zt,
        Jt;
      r();
      var Qt = new (function (t) {
        function e() {
          if (null !== r && r.isPresenting) {
            var e = r.getEyeParameters("left"),
              i = e.renderWidth,
              o = e.renderHeight;
            (f = t.getPixelRatio()),
              (d = t.getSize()),
              t.setDrawingBufferSize(2 * i, o, 1);
          } else n.enabled && t.setDrawingBufferSize(d.width, d.height, f);
        }
        var n = this,
          r = null,
          o = null;
        "undefined" != typeof window &&
          "VRFrameData" in window &&
          (o = new window.VRFrameData());
        var a = new i(),
          s = new i(),
          l = new i(),
          u = new Xt();
        (u.bounds = new c(0, 0, 0.5, 1)), u.layers.enable(1);
        var h = new Xt();
        (h.bounds = new c(0.5, 0, 0.5, 1)), h.layers.enable(2);
        var p = new Yt([u, h]);
        p.layers.enable(1), p.layers.enable(2);
        var d, f;
        "undefined" != typeof window &&
          window.addEventListener("vrdisplaypresentchange", e, !1),
          (this.enabled = !1),
          (this.standing = !1),
          (this.getDevice = function () {
            return r;
          }),
          (this.setDevice = function (t) {
            void 0 !== t && (r = t);
          }),
          (this.getCamera = function (t) {
            if (null === r) return t;
            (r.depthNear = t.near), (r.depthFar = t.far), r.getFrameData(o);
            var e = o.pose;
            null !== e.position
              ? t.position.fromArray(e.position)
              : t.position.set(0, 0, 0),
              null !== e.orientation && t.quaternion.fromArray(e.orientation),
              t.updateMatrixWorld();
            var n = r.stageParameters;
            if (
              (this.standing &&
                n &&
                (s.fromArray(n.sittingToStandingTransform),
                l.getInverse(s),
                t.matrixWorld.multiply(s),
                t.matrixWorldInverse.multiply(l)),
              !1 === r.isPresenting)
            )
              return t;
            (u.near = t.near),
              (h.near = t.near),
              (u.far = t.far),
              (h.far = t.far),
              p.matrixWorld.copy(t.matrixWorld),
              p.matrixWorldInverse.copy(t.matrixWorldInverse),
              u.matrixWorldInverse.fromArray(o.leftViewMatrix),
              h.matrixWorldInverse.fromArray(o.rightViewMatrix),
              this.standing &&
                n &&
                (u.matrixWorldInverse.multiply(l),
                h.matrixWorldInverse.multiply(l));
            var i = t.parent;
            null !== i &&
              (a.getInverse(i.matrixWorld),
              u.matrixWorldInverse.multiply(a),
              h.matrixWorldInverse.multiply(a)),
              u.matrixWorld.getInverse(u.matrixWorldInverse),
              h.matrixWorld.getInverse(h.matrixWorldInverse),
              u.projectionMatrix.fromArray(o.leftProjectionMatrix),
              h.projectionMatrix.fromArray(o.rightProjectionMatrix),
              p.projectionMatrix.copy(u.projectionMatrix);
            var c = r.getLayers();
            if (c.length) {
              var d = c[0];
              null !== d.leftBounds &&
                4 === d.leftBounds.length &&
                u.bounds.fromArray(d.leftBounds),
                null !== d.rightBounds &&
                  4 === d.rightBounds.length &&
                  h.bounds.fromArray(d.rightBounds);
            }
            return p;
          }),
          (this.getStandingMatrix = function () {
            return s;
          }),
          (this.submitFrame = function () {
            r && r.isPresenting && r.submitFrame();
          }),
          (this.dispose = function () {
            "undefined" != typeof window &&
              window.removeEventListener("vrdisplaypresentchange", e);
          });
      })(U);
      this.vr = Qt;
      var Kt = new it(U, Ot, bt.maxTextureSize);
      (this.shadowMap = Kt),
        (this.getContext = function () {
          return mt;
        }),
        (this.getContextAttributes = function () {
          return mt.getContextAttributes();
        }),
        (this.forceContextLoss = function () {
          var t = xt.get("WEBGL_lose_context");
          t && t.loseContext();
        }),
        (this.forceContextRestore = function () {
          var t = xt.get("WEBGL_lose_context");
          t && t.restoreContext();
        }),
        (this.getPixelRatio = function () {
          return K;
        }),
        (this.setPixelRatio = function (t) {
          void 0 !== t && ((K = t), this.setSize(J, Q, !1));
        }),
        (this.getSize = function () {
          return { width: J, height: Q };
        }),
        (this.setSize = function (t, e, n) {
          var i = Qt.getDevice();
          i && i.isPresenting
            ? console.warn(
                "THREE.WebGLRenderer: Can't change size while VR device is presenting."
              )
            : ((J = t),
              (Q = e),
              (w.width = t * K),
              (w.height = e * K),
              !1 !== n &&
                ((w.style.width = t + "px"), (w.style.height = e + "px")),
              this.setViewport(0, 0, t, e));
        }),
        (this.getDrawingBufferSize = function () {
          return { width: J * K, height: Q * K };
        }),
        (this.setDrawingBufferSize = function (t, e, n) {
          (J = t),
            (Q = e),
            (K = n),
            (w.width = t * n),
            (w.height = e * n),
            this.setViewport(0, 0, t, e);
        }),
        (this.setViewport = function (t, e, n, i) {
          tt.set(t, Q - e - i, n, i), _t.viewport(G.copy(tt).multiplyScalar(K));
        }),
        (this.setScissor = function (t, e, n, i) {
          rt.set(t, Q - e - i, n, i), _t.scissor(X.copy(rt).multiplyScalar(K));
        }),
        (this.setScissorTest = function (t) {
          _t.setScissorTest((ot = t));
        }),
        (this.getClearColor = function () {
          return Bt.getClearColor();
        }),
        (this.setClearColor = function () {
          Bt.setClearColor.apply(Bt, arguments);
        }),
        (this.getClearAlpha = function () {
          return Bt.getClearAlpha();
        }),
        (this.setClearAlpha = function () {
          Bt.setClearAlpha.apply(Bt, arguments);
        }),
        (this.clear = function (t, e, n) {
          var i = 0;
          (void 0 === t || t) && (i |= mt.COLOR_BUFFER_BIT),
            (void 0 === e || e) && (i |= mt.DEPTH_BUFFER_BIT),
            (void 0 === n || n) && (i |= mt.STENCIL_BUFFER_BIT),
            mt.clear(i);
        }),
        (this.clearColor = function () {
          this.clear(!0, !1, !1);
        }),
        (this.clearDepth = function () {
          this.clear(!1, !0, !1);
        }),
        (this.clearStencil = function () {
          this.clear(!1, !1, !0);
        }),
        (this.clearTarget = function (t, e, n, i) {
          this.setRenderTarget(t), this.clear(e, n, i);
        }),
        (this.dispose = function () {
          w.removeEventListener("webglcontextlost", s, !1),
            w.removeEventListener("webglcontextrestored", l, !1),
            Ft.dispose(),
            Qt.dispose();
        }),
        (this.renderBufferImmediate = function (t, e, n) {
          _t.initAttributes();
          var i = Et.get(t);
          t.hasPositions && !i.position && (i.position = mt.createBuffer()),
            t.hasNormals && !i.normal && (i.normal = mt.createBuffer()),
            t.hasUvs && !i.uv && (i.uv = mt.createBuffer()),
            t.hasColors && !i.color && (i.color = mt.createBuffer());
          var r = e.getAttributes();
          if (
            (t.hasPositions &&
              (mt.bindBuffer(mt.ARRAY_BUFFER, i.position),
              mt.bufferData(mt.ARRAY_BUFFER, t.positionArray, mt.DYNAMIC_DRAW),
              _t.enableAttribute(r.position),
              mt.vertexAttribPointer(r.position, 3, mt.FLOAT, !1, 0, 0)),
            t.hasNormals)
          ) {
            if (
              (mt.bindBuffer(mt.ARRAY_BUFFER, i.normal),
              !n.isMeshPhongMaterial &&
                !n.isMeshStandardMaterial &&
                !n.isMeshNormalMaterial &&
                !0 === n.flatShading)
            )
              for (var o = 0, a = 3 * t.count; o < a; o += 9) {
                var s = t.normalArray,
                  c = (s[o + 0] + s[o + 3] + s[o + 6]) / 3,
                  l = (s[o + 1] + s[o + 4] + s[o + 7]) / 3,
                  u = (s[o + 2] + s[o + 5] + s[o + 8]) / 3;
                (s[o + 0] = c),
                  (s[o + 1] = l),
                  (s[o + 2] = u),
                  (s[o + 3] = c),
                  (s[o + 4] = l),
                  (s[o + 5] = u),
                  (s[o + 6] = c),
                  (s[o + 7] = l),
                  (s[o + 8] = u);
              }
            mt.bufferData(mt.ARRAY_BUFFER, t.normalArray, mt.DYNAMIC_DRAW),
              _t.enableAttribute(r.normal),
              mt.vertexAttribPointer(r.normal, 3, mt.FLOAT, !1, 0, 0);
          }
          t.hasUvs &&
            n.map &&
            (mt.bindBuffer(mt.ARRAY_BUFFER, i.uv),
            mt.bufferData(mt.ARRAY_BUFFER, t.uvArray, mt.DYNAMIC_DRAW),
            _t.enableAttribute(r.uv),
            mt.vertexAttribPointer(r.uv, 2, mt.FLOAT, !1, 0, 0)),
            t.hasColors &&
              n.vertexColors !== mr &&
              (mt.bindBuffer(mt.ARRAY_BUFFER, i.color),
              mt.bufferData(mt.ARRAY_BUFFER, t.colorArray, mt.DYNAMIC_DRAW),
              _t.enableAttribute(r.color),
              mt.vertexAttribPointer(r.color, 3, mt.FLOAT, !1, 0, 0)),
            _t.disableUnusedAttributes(),
            mt.drawArrays(mt.TRIANGLES, 0, t.count),
            (t.count = 0);
        }),
        (this.renderBufferDirect = function (t, n, i, r, o, a) {
          _t.setMaterial(r);
          var s = y(t, n, r, o),
            c = i.id + "_" + s.id + "_" + (!0 === r.wireframe),
            l = !1;
          c !== B && ((B = c), (l = !0)),
            o.morphTargetInfluences && (Ht.update(o, i, r, s), (l = !0));
          var u = i.index,
            h = i.attributes.position,
            p = 1;
          !0 === r.wireframe && ((u = Ct.getWireframeAttribute(i)), (p = 2));
          var d,
            f = jt;
          null !== u && ((d = Pt.get(u)), (f = Gt).setIndex(d)),
            l &&
              ((function (t, e, n, i) {
                if (
                  n &&
                  n.isInstancedBufferGeometry &&
                  null === xt.get("ANGLE_instanced_arrays")
                )
                  console.error(
                    "THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
                  );
                else {
                  void 0 === i && (i = 0), _t.initAttributes();
                  var r = n.attributes,
                    o = e.getAttributes(),
                    a = t.defaultAttributeValues;
                  for (var s in o) {
                    var c = o[s];
                    if (c >= 0) {
                      var l = r[s];
                      if (void 0 !== l) {
                        var u = l.normalized,
                          h = l.itemSize,
                          p = Pt.get(l);
                        if (void 0 === p) continue;
                        var d = p.buffer,
                          f = p.type,
                          m = p.bytesPerElement;
                        if (l.isInterleavedBufferAttribute) {
                          var g = l.data,
                            v = g.stride,
                            y = l.offset;
                          g && g.isInstancedInterleavedBuffer
                            ? (_t.enableAttributeAndDivisor(
                                c,
                                g.meshPerAttribute
                              ),
                              void 0 === n.maxInstancedCount &&
                                (n.maxInstancedCount =
                                  g.meshPerAttribute * g.count))
                            : _t.enableAttribute(c),
                            mt.bindBuffer(mt.ARRAY_BUFFER, d),
                            mt.vertexAttribPointer(
                              c,
                              h,
                              f,
                              u,
                              v * m,
                              (i * v + y) * m
                            );
                        } else
                          l.isInstancedBufferAttribute
                            ? (_t.enableAttributeAndDivisor(
                                c,
                                l.meshPerAttribute
                              ),
                              void 0 === n.maxInstancedCount &&
                                (n.maxInstancedCount =
                                  l.meshPerAttribute * l.count))
                            : _t.enableAttribute(c),
                            mt.bindBuffer(mt.ARRAY_BUFFER, d),
                            mt.vertexAttribPointer(c, h, f, u, 0, i * h * m);
                      } else if (void 0 !== a) {
                        var x = a[s];
                        if (void 0 !== x)
                          switch (x.length) {
                            case 2:
                              mt.vertexAttrib2fv(c, x);
                              break;
                            case 3:
                              mt.vertexAttrib3fv(c, x);
                              break;
                            case 4:
                              mt.vertexAttrib4fv(c, x);
                              break;
                            default:
                              mt.vertexAttrib1fv(c, x);
                          }
                      }
                    }
                  }
                  _t.disableUnusedAttributes();
                }
              })(r, s, i),
              null !== u && mt.bindBuffer(mt.ELEMENT_ARRAY_BUFFER, d.buffer));
          var m = 0;
          null !== u ? (m = u.count) : void 0 !== h && (m = h.count);
          var g = i.drawRange.start * p,
            v = i.drawRange.count * p,
            x = null !== a ? a.start * p : 0,
            b = null !== a ? a.count * p : 1 / 0,
            _ = Math.max(g, x),
            w = Math.min(m, g + v, x + b) - 1,
            M = Math.max(0, w - _ + 1);
          if (0 !== M) {
            if (o.isMesh)
              if (!0 === r.wireframe)
                _t.setLineWidth(r.wireframeLinewidth * e()),
                  f.setMode(mt.LINES);
              else
                switch (o.drawMode) {
                  case $o:
                    f.setMode(mt.TRIANGLES);
                    break;
                  case Zo:
                    f.setMode(mt.TRIANGLE_STRIP);
                    break;
                  case Jo:
                    f.setMode(mt.TRIANGLE_FAN);
                }
            else if (o.isLine) {
              var E = r.linewidth;
              void 0 === E && (E = 1),
                _t.setLineWidth(E * e()),
                o.isLineSegments
                  ? f.setMode(mt.LINES)
                  : o.isLineLoop
                  ? f.setMode(mt.LINE_LOOP)
                  : f.setMode(mt.LINE_STRIP);
            } else o.isPoints && f.setMode(mt.POINTS);
            i && i.isInstancedBufferGeometry
              ? i.maxInstancedCount > 0 && f.renderInstances(i, _, M)
              : f.render(_, M);
          }
        }),
        (this.compile = function (t, e) {
          (P.length = 0),
            (C.length = 0),
            t.traverse(function (t) {
              t.isLight && (P.push(t), t.castShadow && C.push(t));
            }),
            zt.setup(P, C, e),
            t.traverse(function (e) {
              if (e.material)
                if (Array.isArray(e.material))
                  for (var n = 0; n < e.material.length; n++)
                    v(e.material[n], t.fog, e);
                else v(e.material, t.fog, e);
            });
        });
      var te = !1,
        ee = null;
      (this.animate = function (t) {
        (ee = t),
          (function () {
            if (!te) {
              var t = Qt.getDevice();
              t && t.isPresenting
                ? t.requestAnimationFrame(d)
                : window.requestAnimationFrame(d),
                (te = !0);
            }
          })();
      }),
        (this.render = function (t, e, n, i) {
          if (e && e.isCamera) {
            if (!N) {
              (B = ""),
                (F = -1),
                (H = null),
                !0 === t.autoUpdate && t.updateMatrixWorld(),
                null === e.parent && e.updateMatrixWorld(),
                Qt.enabled && (e = Qt.getCamera(e)),
                ht.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                at.setFromMatrix(ht),
                (P.length = 0),
                (C.length = 0),
                (I.length = 0),
                (D.length = 0),
                (ut = this.localClippingEnabled),
                (lt = st.init(this.clippingPlanes, ut, e)),
                (O = Ft.get(t, e)).init(),
                f(t, e, U.sortObjects),
                !0 === U.sortObjects && O.sort(),
                lt && st.beginShadows(),
                Kt.render(C, t, e),
                zt.setup(P, C, e),
                lt && st.endShadows(),
                ft.frame++,
                (ft.calls = 0),
                (ft.vertices = 0),
                (ft.faces = 0),
                (ft.points = 0),
                void 0 === n && (n = null),
                this.setRenderTarget(n),
                Bt.render(O, t, e, i);
              var r = O.opaque,
                o = O.transparent;
              if (t.overrideMaterial) {
                var a = t.overrideMaterial;
                r.length && m(r, t, e, a), o.length && m(o, t, e, a);
              } else r.length && m(r, t, e), o.length && m(o, t, e);
              Zt.render(I, t, e),
                $t.render(D, t, e, G),
                n && St.updateRenderTargetMipmap(n),
                _t.buffers.depth.setTest(!0),
                _t.buffers.depth.setMask(!0),
                _t.buffers.color.setMask(!0),
                _t.setPolygonOffset(!1),
                Qt.enabled && Qt.submitFrame();
            }
          } else
            console.error(
              "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
            );
        }),
        (this.setFaceCulling = function (t, e) {
          _t.setCullFace(t), _t.setFlipSided(e === lr);
        }),
        (this.allocTextureUnit = function () {
          var t = Z;
          return (
            t >= bt.maxTextures &&
              console.warn(
                "THREE.WebGLRenderer: Trying to use " +
                  t +
                  " texture units while this GPU supports only " +
                  bt.maxTextures
              ),
            (Z += 1),
            t
          );
        }),
        (this.setTexture2D = (function () {
          var t = !1;
          return function (e, n) {
            e &&
              e.isWebGLRenderTarget &&
              (t ||
                (console.warn(
                  "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."
                ),
                (t = !0)),
              (e = e.texture)),
              St.setTexture2D(e, n);
          };
        })()),
        (this.setTexture = (function () {
          var t = !1;
          return function (e, n) {
            t ||
              (console.warn(
                "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."
              ),
              (t = !0)),
              St.setTexture2D(e, n);
          };
        })()),
        (this.setTextureCube = (function () {
          var t = !1;
          return function (e, n) {
            e &&
              e.isWebGLRenderTargetCube &&
              (t ||
                (console.warn(
                  "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."
                ),
                (t = !0)),
              (e = e.texture)),
              (e && e.isCubeTexture) ||
              (Array.isArray(e.image) && 6 === e.image.length)
                ? St.setTextureCube(e, n)
                : St.setTextureCubeDynamic(e, n);
          };
        })()),
        (this.getRenderTarget = function () {
          return z;
        }),
        (this.setRenderTarget = function (t) {
          (z = t),
            t &&
              void 0 === Et.get(t).__webglFramebuffer &&
              St.setupRenderTarget(t);
          var e = null,
            n = !1;
          if (t) {
            var i = Et.get(t).__webglFramebuffer;
            t.isWebGLRenderTargetCube
              ? ((e = i[t.activeCubeFace]), (n = !0))
              : (e = i),
              G.copy(t.viewport),
              X.copy(t.scissor),
              (q = t.scissorTest);
          } else
            G.copy(tt).multiplyScalar(K),
              X.copy(rt).multiplyScalar(K),
              (q = ot);
          if (
            (k !== e && (mt.bindFramebuffer(mt.FRAMEBUFFER, e), (k = e)),
            _t.viewport(G),
            _t.scissor(X),
            _t.setScissorTest(q),
            n)
          ) {
            var r = Et.get(t.texture);
            mt.framebufferTexture2D(
              mt.FRAMEBUFFER,
              mt.COLOR_ATTACHMENT0,
              mt.TEXTURE_CUBE_MAP_POSITIVE_X + t.activeCubeFace,
              r.__webglTexture,
              t.activeMipMapLevel
            );
          }
        }),
        (this.readRenderTargetPixels = function (t, e, n, i, r, o) {
          if (t && t.isWebGLRenderTarget) {
            var a = Et.get(t).__webglFramebuffer;
            if (a) {
              var s = !1;
              a !== k && (mt.bindFramebuffer(mt.FRAMEBUFFER, a), (s = !0));
              try {
                var c = t.texture,
                  l = c.format,
                  u = c.type;
                if (
                  l !== Io &&
                  Jt.convert(l) !==
                    mt.getParameter(mt.IMPLEMENTATION_COLOR_READ_FORMAT)
                )
                  return void console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                  );
                if (
                  !(
                    u === xo ||
                    Jt.convert(u) ===
                      mt.getParameter(mt.IMPLEMENTATION_COLOR_READ_TYPE) ||
                    (u === To &&
                      (xt.get("OES_texture_float") ||
                        xt.get("WEBGL_color_buffer_float"))) ||
                    (u === So && xt.get("EXT_color_buffer_half_float"))
                  )
                )
                  return void console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                  );
                mt.checkFramebufferStatus(mt.FRAMEBUFFER) ===
                mt.FRAMEBUFFER_COMPLETE
                  ? e >= 0 &&
                    e <= t.width - i &&
                    n >= 0 &&
                    n <= t.height - r &&
                    mt.readPixels(e, n, i, r, Jt.convert(l), Jt.convert(u), o)
                  : console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
                    );
              } finally {
                s && mt.bindFramebuffer(mt.FRAMEBUFFER, k);
              }
            }
          } else
            console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
            );
        });
    }
    function Zt(t, e) {
      (this.name = ""),
        (this.color = new W(t)),
        (this.density = void 0 !== e ? e : 25e-5);
    }
    function Jt(t, e, n) {
      (this.name = ""),
        (this.color = new W(t)),
        (this.near = void 0 !== e ? e : 1),
        (this.far = void 0 !== n ? n : 1e3);
    }
    function Qt() {
      at.call(this),
        (this.type = "Scene"),
        (this.background = null),
        (this.fog = null),
        (this.overrideMaterial = null),
        (this.autoUpdate = !0);
    }
    function Kt(t, e, n, i, r) {
      at.call(this),
        (this.lensFlares = []),
        (this.positionScreen = new o()),
        (this.customUpdateCallback = void 0),
        void 0 !== t && this.add(t, e, n, i, r);
    }
    function te(t) {
      Z.call(this),
        (this.type = "SpriteMaterial"),
        (this.color = new W(16777215)),
        (this.map = null),
        (this.rotation = 0),
        (this.fog = !1),
        (this.lights = !1),
        this.setValues(t);
    }
    function ee(t) {
      at.call(this),
        (this.type = "Sprite"),
        (this.material = void 0 !== t ? t : new te());
    }
    function ne() {
      at.call(this),
        (this.type = "LOD"),
        Object.defineProperties(this, {
          levels: { enumerable: !0, value: [] },
        });
    }
    function ie(t, e) {
      if (
        ((t = t || []),
        (this.bones = t.slice(0)),
        (this.boneMatrices = new Float32Array(16 * this.bones.length)),
        void 0 === e)
      )
        this.calculateInverses();
      else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
      else {
        console.warn("THREE.Skeleton boneInverses is the wrong length."),
          (this.boneInverses = []);
        for (var n = 0, r = this.bones.length; n < r; n++)
          this.boneInverses.push(new i());
      }
    }
    function re() {
      at.call(this), (this.type = "Bone");
    }
    function oe(t, e) {
      It.call(this, t, e),
        (this.type = "SkinnedMesh"),
        (this.bindMode = "attached"),
        (this.bindMatrix = new i()),
        (this.bindMatrixInverse = new i());
      var n = new ie(this.initBones());
      this.bind(n, this.matrixWorld), this.normalizeSkinWeights();
    }
    function ae(t) {
      Z.call(this),
        (this.type = "LineBasicMaterial"),
        (this.color = new W(16777215)),
        (this.linewidth = 1),
        (this.linecap = "round"),
        (this.linejoin = "round"),
        (this.lights = !1),
        this.setValues(t);
    }
    function se(t, e, n) {
      if (1 === n)
        return (
          console.warn(
            "THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."
          ),
          new ce(t, e)
        );
      at.call(this),
        (this.type = "Line"),
        (this.geometry = void 0 !== t ? t : new Mt()),
        (this.material =
          void 0 !== e ? e : new ae({ color: 16777215 * Math.random() }));
    }
    function ce(t, e) {
      se.call(this, t, e), (this.type = "LineSegments");
    }
    function le(t, e) {
      se.call(this, t, e), (this.type = "LineLoop");
    }
    function ue(t) {
      Z.call(this),
        (this.type = "PointsMaterial"),
        (this.color = new W(16777215)),
        (this.map = null),
        (this.size = 1),
        (this.sizeAttenuation = !0),
        (this.lights = !1),
        this.setValues(t);
    }
    function he(t, e) {
      at.call(this),
        (this.type = "Points"),
        (this.geometry = void 0 !== t ? t : new Mt()),
        (this.material =
          void 0 !== e ? e : new ue({ color: 16777215 * Math.random() }));
    }
    function pe() {
      at.call(this), (this.type = "Group");
    }
    function de(t, e, n, i, r, o, a, c, l) {
      function u() {
        var t = h.image;
        t.readyState >= t.HAVE_CURRENT_DATA && (h.needsUpdate = !0),
          requestAnimationFrame(u);
      }
      s.call(this, t, e, n, i, r, o, a, c, l), (this.generateMipmaps = !1);
      var h = this;
      requestAnimationFrame(u);
    }
    function fe(t, e, n, i, r, o, a, c, l, u, h, p) {
      s.call(this, null, o, a, c, l, u, i, r, h, p),
        (this.image = { width: e, height: n }),
        (this.mipmaps = t),
        (this.flipY = !1),
        (this.generateMipmaps = !1);
    }
    function me(t, e, n, i, r, o, a, c, l, u) {
      if ((u = void 0 !== u ? u : No) !== No && u !== zo)
        throw new Error(
          "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
        );
      void 0 === n && u === No && (n = wo),
        void 0 === n && u === zo && (n = Po),
        s.call(this, null, i, r, o, a, c, u, n, l),
        (this.image = { width: t, height: e }),
        (this.magFilter = void 0 !== a ? a : po),
        (this.minFilter = void 0 !== c ? c : po),
        (this.flipY = !1),
        (this.generateMipmaps = !1);
    }
    function ge(t) {
      Mt.call(this), (this.type = "WireframeGeometry");
      var e,
        n,
        i,
        r,
        a,
        s,
        c,
        l,
        u,
        h,
        p = [],
        d = [0, 0],
        f = {},
        m = ["a", "b", "c"];
      if (t && t.isGeometry) {
        var g = t.faces;
        for (e = 0, i = g.length; e < i; e++) {
          var v = g[e];
          for (n = 0; n < 3; n++)
            (c = v[m[n]]),
              (l = v[m[(n + 1) % 3]]),
              (d[0] = Math.min(c, l)),
              (d[1] = Math.max(c, l)),
              void 0 === f[(u = d[0] + "," + d[1])] &&
                (f[u] = { index1: d[0], index2: d[1] });
        }
        for (u in f)
          (s = f[u]),
            (h = t.vertices[s.index1]),
            p.push(h.x, h.y, h.z),
            (h = t.vertices[s.index2]),
            p.push(h.x, h.y, h.z);
      } else if (t && t.isBufferGeometry) {
        var y, x, b, _, w, M, E;
        if (((h = new o()), null !== t.index)) {
          for (
            y = t.attributes.position,
              x = t.index,
              0 === (b = t.groups).length &&
                (b = [{ start: 0, count: x.count, materialIndex: 0 }]),
              r = 0,
              a = b.length;
            r < a;
            ++r
          )
            for (e = w = (_ = b[r]).start, i = w + _.count; e < i; e += 3)
              for (n = 0; n < 3; n++)
                (c = x.getX(e + n)),
                  (l = x.getX(e + ((n + 1) % 3))),
                  (d[0] = Math.min(c, l)),
                  (d[1] = Math.max(c, l)),
                  void 0 === f[(u = d[0] + "," + d[1])] &&
                    (f[u] = { index1: d[0], index2: d[1] });
          for (u in f)
            (s = f[u]),
              h.fromBufferAttribute(y, s.index1),
              p.push(h.x, h.y, h.z),
              h.fromBufferAttribute(y, s.index2),
              p.push(h.x, h.y, h.z);
        } else
          for (e = 0, i = (y = t.attributes.position).count / 3; e < i; e++)
            for (n = 0; n < 3; n++)
              (M = 3 * e + n),
                h.fromBufferAttribute(y, M),
                p.push(h.x, h.y, h.z),
                (E = 3 * e + ((n + 1) % 3)),
                h.fromBufferAttribute(y, E),
                p.push(h.x, h.y, h.z);
      }
      this.addAttribute("position", new xt(p, 3));
    }
    function ve(t, e, n) {
      ut.call(this),
        (this.type = "ParametricGeometry"),
        (this.parameters = { func: t, slices: e, stacks: n }),
        this.fromBufferGeometry(new ye(t, e, n)),
        this.mergeVertices();
    }
    function ye(t, e, n) {
      Mt.call(this),
        (this.type = "ParametricBufferGeometry"),
        (this.parameters = { func: t, slices: e, stacks: n });
      var i,
        r,
        a = [],
        s = [],
        c = [],
        l = [],
        u = new o(),
        h = new o(),
        p = new o(),
        d = new o(),
        f = new o(),
        m = e + 1;
      for (i = 0; i <= n; i++) {
        var g = i / n;
        for (r = 0; r <= e; r++) {
          var v = r / e;
          (h = t(v, g, h)),
            s.push(h.x, h.y, h.z),
            v - 1e-5 >= 0
              ? ((p = t(v - 1e-5, g, p)), d.subVectors(h, p))
              : ((p = t(v + 1e-5, g, p)), d.subVectors(p, h)),
            g - 1e-5 >= 0
              ? ((p = t(v, g - 1e-5, p)), f.subVectors(h, p))
              : ((p = t(v, g + 1e-5, p)), f.subVectors(p, h)),
            u.crossVectors(d, f).normalize(),
            c.push(u.x, u.y, u.z),
            l.push(v, g);
        }
      }
      for (i = 0; i < n; i++)
        for (r = 0; r < e; r++) {
          var y = i * m + r,
            x = i * m + r + 1,
            b = (i + 1) * m + r + 1,
            _ = (i + 1) * m + r;
          a.push(y, x, _), a.push(x, b, _);
        }
      this.setIndex(a),
        this.addAttribute("position", new xt(s, 3)),
        this.addAttribute("normal", new xt(c, 3)),
        this.addAttribute("uv", new xt(l, 2));
    }
    function xe(t, e, n, i) {
      ut.call(this),
        (this.type = "PolyhedronGeometry"),
        (this.parameters = { vertices: t, indices: e, radius: n, detail: i }),
        this.fromBufferGeometry(new be(t, e, n, i)),
        this.mergeVertices();
    }
    function be(t, e, i, r) {
      function a(t) {
        u.push(t.x, t.y, t.z);
      }
      function s(e, n) {
        var i = 3 * e;
        (n.x = t[i + 0]), (n.y = t[i + 1]), (n.z = t[i + 2]);
      }
      function c(t, e, n, i) {
        i < 0 && 1 === t.x && (h[e] = t.x - 1),
          0 === n.x && 0 === n.z && (h[e] = i / 2 / Math.PI + 0.5);
      }
      function l(t) {
        return Math.atan2(t.z, -t.x);
      }
      Mt.call(this),
        (this.type = "PolyhedronBufferGeometry"),
        (this.parameters = { vertices: t, indices: e, radius: i, detail: r }),
        (i = i || 1);
      var u = [],
        h = [];
      !(function (t) {
        for (
          var n = new o(), i = new o(), r = new o(), c = 0;
          c < e.length;
          c += 3
        )
          s(e[c + 0], n),
            s(e[c + 1], i),
            s(e[c + 2], r),
            (function (t, e, n, i) {
              var r,
                o,
                s = Math.pow(2, i),
                c = [];
              for (r = 0; r <= s; r++) {
                c[r] = [];
                var l = t.clone().lerp(n, r / s),
                  u = e.clone().lerp(n, r / s),
                  h = s - r;
                for (o = 0; o <= h; o++)
                  c[r][o] = 0 === o && r === s ? l : l.clone().lerp(u, o / h);
              }
              for (r = 0; r < s; r++)
                for (o = 0; o < 2 * (s - r) - 1; o++) {
                  var p = Math.floor(o / 2);
                  o % 2 == 0
                    ? (a(c[r][p + 1]), a(c[r + 1][p]), a(c[r][p]))
                    : (a(c[r][p + 1]), a(c[r + 1][p + 1]), a(c[r + 1][p]));
                }
            })(n, i, r, t);
      })((r = r || 0)),
        (function (t) {
          for (var e = new o(), n = 0; n < u.length; n += 3)
            (e.x = u[n + 0]),
              (e.y = u[n + 1]),
              (e.z = u[n + 2]),
              e.normalize().multiplyScalar(t),
              (u[n + 0] = e.x),
              (u[n + 1] = e.y),
              (u[n + 2] = e.z);
        })(i),
        (function () {
          for (var t = new o(), e = 0; e < u.length; e += 3) {
            (t.x = u[e + 0]), (t.y = u[e + 1]), (t.z = u[e + 2]);
            var i = l(t) / 2 / Math.PI + 0.5,
              r =
                (function (t) {
                  return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z));
                })(t) /
                  Math.PI +
                0.5;
            h.push(i, 1 - r);
          }
          !(function () {
            for (
              var t = new o(),
                e = new o(),
                i = new o(),
                r = new o(),
                a = new n(),
                s = new n(),
                p = new n(),
                d = 0,
                f = 0;
              d < u.length;
              d += 9, f += 6
            ) {
              t.set(u[d + 0], u[d + 1], u[d + 2]),
                e.set(u[d + 3], u[d + 4], u[d + 5]),
                i.set(u[d + 6], u[d + 7], u[d + 8]),
                a.set(h[f + 0], h[f + 1]),
                s.set(h[f + 2], h[f + 3]),
                p.set(h[f + 4], h[f + 5]),
                r.copy(t).add(e).add(i).divideScalar(3);
              var m = l(r);
              c(a, f + 0, t, m), c(s, f + 2, e, m), c(p, f + 4, i, m);
            }
          })(),
            (function () {
              for (var t = 0; t < h.length; t += 6) {
                var e = h[t + 0],
                  n = h[t + 2],
                  i = h[t + 4],
                  r = Math.max(e, n, i),
                  o = Math.min(e, n, i);
                r > 0.9 &&
                  o < 0.1 &&
                  (e < 0.2 && (h[t + 0] += 1),
                  n < 0.2 && (h[t + 2] += 1),
                  i < 0.2 && (h[t + 4] += 1));
              }
            })();
        })(),
        this.addAttribute("position", new xt(u, 3)),
        this.addAttribute("normal", new xt(u.slice(), 3)),
        this.addAttribute("uv", new xt(h, 2)),
        0 === r ? this.computeVertexNormals() : this.normalizeNormals();
    }
    function _e(t, e) {
      ut.call(this),
        (this.type = "TetrahedronGeometry"),
        (this.parameters = { radius: t, detail: e }),
        this.fromBufferGeometry(new we(t, e)),
        this.mergeVertices();
    }
    function we(t, e) {
      be.call(
        this,
        [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
        [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
        t,
        e
      ),
        (this.type = "TetrahedronBufferGeometry"),
        (this.parameters = { radius: t, detail: e });
    }
    function Me(t, e) {
      ut.call(this),
        (this.type = "OctahedronGeometry"),
        (this.parameters = { radius: t, detail: e }),
        this.fromBufferGeometry(new Ee(t, e)),
        this.mergeVertices();
    }
    function Ee(t, e) {
      be.call(
        this,
        [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
        [
          0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4,
          2,
        ],
        t,
        e
      ),
        (this.type = "OctahedronBufferGeometry"),
        (this.parameters = { radius: t, detail: e });
    }
    function Te(t, e) {
      ut.call(this),
        (this.type = "IcosahedronGeometry"),
        (this.parameters = { radius: t, detail: e }),
        this.fromBufferGeometry(new Se(t, e)),
        this.mergeVertices();
    }
    function Se(t, e) {
      var n = (1 + Math.sqrt(5)) / 2;
      be.call(
        this,
        [
          -1,
          n,
          0,
          1,
          n,
          0,
          -1,
          -n,
          0,
          1,
          -n,
          0,
          0,
          -1,
          n,
          0,
          1,
          n,
          0,
          -1,
          -n,
          0,
          1,
          -n,
          n,
          0,
          -1,
          n,
          0,
          1,
          -n,
          0,
          -1,
          -n,
          0,
          1,
        ],
        [
          0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4,
          11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3,
          8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
        ],
        t,
        e
      ),
        (this.type = "IcosahedronBufferGeometry"),
        (this.parameters = { radius: t, detail: e });
    }
    function Ae(t, e) {
      ut.call(this),
        (this.type = "DodecahedronGeometry"),
        (this.parameters = { radius: t, detail: e }),
        this.fromBufferGeometry(new Le(t, e)),
        this.mergeVertices();
    }
    function Le(t, e) {
      var n = (1 + Math.sqrt(5)) / 2,
        i = 1 / n;
      be.call(
        this,
        [
          -1,
          -1,
          -1,
          -1,
          -1,
          1,
          -1,
          1,
          -1,
          -1,
          1,
          1,
          1,
          -1,
          -1,
          1,
          -1,
          1,
          1,
          1,
          -1,
          1,
          1,
          1,
          0,
          -i,
          -n,
          0,
          -i,
          n,
          0,
          i,
          -n,
          0,
          i,
          n,
          -i,
          -n,
          0,
          -i,
          n,
          0,
          i,
          -n,
          0,
          i,
          n,
          0,
          -n,
          0,
          -i,
          n,
          0,
          -i,
          -n,
          0,
          i,
          n,
          0,
          i,
        ],
        [
          3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4,
          8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1,
          18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2,
          3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8,
          11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1,
          12, 14, 1, 14, 5, 1, 5, 9,
        ],
        t,
        e
      ),
        (this.type = "DodecahedronBufferGeometry"),
        (this.parameters = { radius: t, detail: e });
    }
    function Re(t, e, n, i, r, o) {
      ut.call(this),
        (this.type = "TubeGeometry"),
        (this.parameters = {
          path: t,
          tubularSegments: e,
          radius: n,
          radialSegments: i,
          closed: r,
        }),
        void 0 !== o &&
          console.warn("THREE.TubeGeometry: taper has been removed.");
      var a = new Pe(t, e, n, i, r);
      (this.tangents = a.tangents),
        (this.normals = a.normals),
        (this.binormals = a.binormals),
        this.fromBufferGeometry(a),
        this.mergeVertices();
    }
    function Pe(t, e, i, r, a) {
      function s(n) {
        f = t.getPointAt(n / e, f);
        var o = c.normals[n],
          a = c.binormals[n];
        for (u = 0; u <= r; u++) {
          var s = (u / r) * Math.PI * 2,
            l = Math.sin(s),
            d = -Math.cos(s);
          (p.x = d * o.x + l * a.x),
            (p.y = d * o.y + l * a.y),
            (p.z = d * o.z + l * a.z),
            p.normalize(),
            g.push(p.x, p.y, p.z),
            (h.x = f.x + i * p.x),
            (h.y = f.y + i * p.y),
            (h.z = f.z + i * p.z),
            m.push(h.x, h.y, h.z);
        }
      }
      Mt.call(this),
        (this.type = "TubeBufferGeometry"),
        (this.parameters = {
          path: t,
          tubularSegments: e,
          radius: i,
          radialSegments: r,
          closed: a,
        }),
        (e = e || 64),
        (i = i || 1),
        (r = r || 8),
        (a = a || !1);
      var c = t.computeFrenetFrames(e, a);
      (this.tangents = c.tangents),
        (this.normals = c.normals),
        (this.binormals = c.binormals);
      var l,
        u,
        h = new o(),
        p = new o(),
        d = new n(),
        f = new o(),
        m = [],
        g = [],
        v = [],
        y = [];
      !(function () {
        for (l = 0; l < e; l++) s(l);
        s(!1 === a ? e : 0),
          (function () {
            for (l = 0; l <= e; l++)
              for (u = 0; u <= r; u++)
                (d.x = l / e), (d.y = u / r), v.push(d.x, d.y);
          })(),
          (function () {
            for (u = 1; u <= e; u++)
              for (l = 1; l <= r; l++) {
                var t = (r + 1) * (u - 1) + (l - 1),
                  n = (r + 1) * u + (l - 1),
                  i = (r + 1) * u + l,
                  o = (r + 1) * (u - 1) + l;
                y.push(t, n, o), y.push(n, i, o);
              }
          })();
      })(),
        this.setIndex(y),
        this.addAttribute("position", new xt(m, 3)),
        this.addAttribute("normal", new xt(g, 3)),
        this.addAttribute("uv", new xt(v, 2));
    }
    function Ce(t, e, n, i, r, o, a) {
      ut.call(this),
        (this.type = "TorusKnotGeometry"),
        (this.parameters = {
          radius: t,
          tube: e,
          tubularSegments: n,
          radialSegments: i,
          p: r,
          q: o,
        }),
        void 0 !== a &&
          console.warn(
            "THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."
          ),
        this.fromBufferGeometry(new Oe(t, e, n, i, r, o)),
        this.mergeVertices();
    }
    function Oe(t, e, n, i, r, a) {
      function s(t, e, n, i, r) {
        var o = Math.cos(t),
          a = Math.sin(t),
          s = (n / e) * t,
          c = Math.cos(s);
        (r.x = i * (2 + c) * 0.5 * o),
          (r.y = i * (2 + c) * a * 0.5),
          (r.z = i * Math.sin(s) * 0.5);
      }
      Mt.call(this),
        (this.type = "TorusKnotBufferGeometry"),
        (this.parameters = {
          radius: t,
          tube: e,
          tubularSegments: n,
          radialSegments: i,
          p: r,
          q: a,
        }),
        (t = t || 1),
        (e = e || 0.4),
        (n = Math.floor(n) || 64),
        (i = Math.floor(i) || 8),
        (r = r || 2),
        (a = a || 3);
      var c,
        l,
        u = [],
        h = [],
        p = [],
        d = [],
        f = new o(),
        m = new o(),
        g = new o(),
        v = new o(),
        y = new o(),
        x = new o(),
        b = new o();
      for (c = 0; c <= n; ++c) {
        var _ = (c / n) * r * Math.PI * 2;
        for (
          s(_, r, a, t, g),
            s(_ + 0.01, r, a, t, v),
            x.subVectors(v, g),
            b.addVectors(v, g),
            y.crossVectors(x, b),
            b.crossVectors(y, x),
            y.normalize(),
            b.normalize(),
            l = 0;
          l <= i;
          ++l
        ) {
          var w = (l / i) * Math.PI * 2,
            M = -e * Math.cos(w),
            E = e * Math.sin(w);
          (f.x = g.x + (M * b.x + E * y.x)),
            (f.y = g.y + (M * b.y + E * y.y)),
            (f.z = g.z + (M * b.z + E * y.z)),
            h.push(f.x, f.y, f.z),
            m.subVectors(f, g).normalize(),
            p.push(m.x, m.y, m.z),
            d.push(c / n),
            d.push(l / i);
        }
      }
      for (l = 1; l <= n; l++)
        for (c = 1; c <= i; c++) {
          var T = (i + 1) * (l - 1) + (c - 1),
            S = (i + 1) * l + (c - 1),
            A = (i + 1) * l + c,
            L = (i + 1) * (l - 1) + c;
          u.push(T, S, L), u.push(S, A, L);
        }
      this.setIndex(u),
        this.addAttribute("position", new xt(h, 3)),
        this.addAttribute("normal", new xt(p, 3)),
        this.addAttribute("uv", new xt(d, 2));
    }
    function Ie(t, e, n, i, r) {
      ut.call(this),
        (this.type = "TorusGeometry"),
        (this.parameters = {
          radius: t,
          tube: e,
          radialSegments: n,
          tubularSegments: i,
          arc: r,
        }),
        this.fromBufferGeometry(new De(t, e, n, i, r)),
        this.mergeVertices();
    }
    function De(t, e, n, i, r) {
      Mt.call(this),
        (this.type = "TorusBufferGeometry"),
        (this.parameters = {
          radius: t,
          tube: e,
          radialSegments: n,
          tubularSegments: i,
          arc: r,
        }),
        (t = t || 1),
        (e = e || 0.4),
        (n = Math.floor(n) || 8),
        (i = Math.floor(i) || 6),
        (r = r || 2 * Math.PI);
      var a,
        s,
        c = [],
        l = [],
        u = [],
        h = [],
        p = new o(),
        d = new o(),
        f = new o();
      for (a = 0; a <= n; a++)
        for (s = 0; s <= i; s++) {
          var m = (s / i) * r,
            g = (a / n) * Math.PI * 2;
          (d.x = (t + e * Math.cos(g)) * Math.cos(m)),
            (d.y = (t + e * Math.cos(g)) * Math.sin(m)),
            (d.z = e * Math.sin(g)),
            l.push(d.x, d.y, d.z),
            (p.x = t * Math.cos(m)),
            (p.y = t * Math.sin(m)),
            f.subVectors(d, p).normalize(),
            u.push(f.x, f.y, f.z),
            h.push(s / i),
            h.push(a / n);
        }
      for (a = 1; a <= n; a++)
        for (s = 1; s <= i; s++) {
          var v = (i + 1) * a + s - 1,
            y = (i + 1) * (a - 1) + s - 1,
            x = (i + 1) * (a - 1) + s,
            b = (i + 1) * a + s;
          c.push(v, y, b), c.push(y, x, b);
        }
      this.setIndex(c),
        this.addAttribute("position", new xt(l, 3)),
        this.addAttribute("normal", new xt(u, 3)),
        this.addAttribute("uv", new xt(h, 2));
    }
    function Ue(t, e) {
      ut.call(this),
        (this.type = "ExtrudeGeometry"),
        (this.parameters = { shapes: t, options: e }),
        this.fromBufferGeometry(new Ne(t, e)),
        this.mergeVertices();
    }
    function Ne(t, e) {
      void 0 !== t &&
        (Mt.call(this),
        (this.type = "ExtrudeBufferGeometry"),
        (t = Array.isArray(t) ? t : [t]),
        this.addShapeList(t, e),
        this.computeVertexNormals());
    }
    function ze(t, e) {
      ut.call(this),
        (this.type = "TextGeometry"),
        (this.parameters = { text: t, parameters: e }),
        this.fromBufferGeometry(new ke(t, e)),
        this.mergeVertices();
    }
    function ke(t, e) {
      var n = (e = e || {}).font;
      if (!n || !n.isFont)
        return (
          console.error(
            "THREE.TextGeometry: font parameter is not an instance of THREE.Font."
          ),
          new ut()
        );
      var i = n.generateShapes(t, e.size, e.curveSegments);
      (e.amount = void 0 !== e.height ? e.height : 50),
        void 0 === e.bevelThickness && (e.bevelThickness = 10),
        void 0 === e.bevelSize && (e.bevelSize = 8),
        void 0 === e.bevelEnabled && (e.bevelEnabled = !1),
        Ne.call(this, i, e),
        (this.type = "TextBufferGeometry");
    }
    function Fe(t, e, n, i, r, o, a) {
      ut.call(this),
        (this.type = "SphereGeometry"),
        (this.parameters = {
          radius: t,
          widthSegments: e,
          heightSegments: n,
          phiStart: i,
          phiLength: r,
          thetaStart: o,
          thetaLength: a,
        }),
        this.fromBufferGeometry(new Be(t, e, n, i, r, o, a)),
        this.mergeVertices();
    }
    function Be(t, e, n, i, r, a, s) {
      Mt.call(this),
        (this.type = "SphereBufferGeometry"),
        (this.parameters = {
          radius: t,
          widthSegments: e,
          heightSegments: n,
          phiStart: i,
          phiLength: r,
          thetaStart: a,
          thetaLength: s,
        }),
        (t = t || 1),
        (e = Math.max(3, Math.floor(e) || 8)),
        (n = Math.max(2, Math.floor(n) || 6)),
        (i = void 0 !== i ? i : 0),
        (r = void 0 !== r ? r : 2 * Math.PI);
      var c,
        l,
        u = (a = void 0 !== a ? a : 0) + (s = void 0 !== s ? s : Math.PI),
        h = 0,
        p = [],
        d = new o(),
        f = new o(),
        m = [],
        g = [],
        v = [],
        y = [];
      for (l = 0; l <= n; l++) {
        var x = [],
          b = l / n;
        for (c = 0; c <= e; c++) {
          var _ = c / e;
          (d.x = -t * Math.cos(i + _ * r) * Math.sin(a + b * s)),
            (d.y = t * Math.cos(a + b * s)),
            (d.z = t * Math.sin(i + _ * r) * Math.sin(a + b * s)),
            g.push(d.x, d.y, d.z),
            f.set(d.x, d.y, d.z).normalize(),
            v.push(f.x, f.y, f.z),
            y.push(_, 1 - b),
            x.push(h++);
        }
        p.push(x);
      }
      for (l = 0; l < n; l++)
        for (c = 0; c < e; c++) {
          var w = p[l][c + 1],
            M = p[l][c],
            E = p[l + 1][c],
            T = p[l + 1][c + 1];
          (0 !== l || a > 0) && m.push(w, M, T),
            (l !== n - 1 || u < Math.PI) && m.push(M, E, T);
        }
      this.setIndex(m),
        this.addAttribute("position", new xt(g, 3)),
        this.addAttribute("normal", new xt(v, 3)),
        this.addAttribute("uv", new xt(y, 2));
    }
    function He(t, e, n, i, r, o) {
      ut.call(this),
        (this.type = "RingGeometry"),
        (this.parameters = {
          innerRadius: t,
          outerRadius: e,
          thetaSegments: n,
          phiSegments: i,
          thetaStart: r,
          thetaLength: o,
        }),
        this.fromBufferGeometry(new je(t, e, n, i, r, o)),
        this.mergeVertices();
    }
    function je(t, e, i, r, a, s) {
      Mt.call(this),
        (this.type = "RingBufferGeometry"),
        (this.parameters = {
          innerRadius: t,
          outerRadius: e,
          thetaSegments: i,
          phiSegments: r,
          thetaStart: a,
          thetaLength: s,
        }),
        (t = t || 0.5),
        (e = e || 1),
        (a = void 0 !== a ? a : 0),
        (s = void 0 !== s ? s : 2 * Math.PI),
        (i = void 0 !== i ? Math.max(3, i) : 8);
      var c,
        l,
        u,
        h = [],
        p = [],
        d = [],
        f = [],
        m = t,
        g = (e - t) / (r = void 0 !== r ? Math.max(1, r) : 1),
        v = new o(),
        y = new n();
      for (l = 0; l <= r; l++) {
        for (u = 0; u <= i; u++)
          (c = a + (u / i) * s),
            (v.x = m * Math.cos(c)),
            (v.y = m * Math.sin(c)),
            p.push(v.x, v.y, v.z),
            d.push(0, 0, 1),
            (y.x = (v.x / e + 1) / 2),
            (y.y = (v.y / e + 1) / 2),
            f.push(y.x, y.y);
        m += g;
      }
      for (l = 0; l < r; l++) {
        var x = l * (i + 1);
        for (u = 0; u < i; u++) {
          var b = (c = u + x),
            _ = c + i + 1,
            w = c + i + 2,
            M = c + 1;
          h.push(b, _, M), h.push(_, w, M);
        }
      }
      this.setIndex(h),
        this.addAttribute("position", new xt(p, 3)),
        this.addAttribute("normal", new xt(d, 3)),
        this.addAttribute("uv", new xt(f, 2));
    }
    function Ge(t, e, n, i) {
      ut.call(this),
        (this.type = "LatheGeometry"),
        (this.parameters = {
          points: t,
          segments: e,
          phiStart: n,
          phiLength: i,
        }),
        this.fromBufferGeometry(new Ve(t, e, n, i)),
        this.mergeVertices();
    }
    function Ve(t, e, i, r) {
      Mt.call(this),
        (this.type = "LatheBufferGeometry"),
        (this.parameters = {
          points: t,
          segments: e,
          phiStart: i,
          phiLength: r,
        }),
        (e = Math.floor(e) || 12),
        (i = i || 0),
        (r = r || 2 * Math.PI),
        (r = sa.clamp(r, 0, 2 * Math.PI));
      var a,
        s,
        c,
        l = [],
        u = [],
        h = [],
        p = 1 / e,
        d = new o(),
        f = new n();
      for (s = 0; s <= e; s++) {
        var m = i + s * p * r,
          g = Math.sin(m),
          v = Math.cos(m);
        for (c = 0; c <= t.length - 1; c++)
          (d.x = t[c].x * g),
            (d.y = t[c].y),
            (d.z = t[c].x * v),
            u.push(d.x, d.y, d.z),
            (f.x = s / e),
            (f.y = c / (t.length - 1)),
            h.push(f.x, f.y);
      }
      for (s = 0; s < e; s++)
        for (c = 0; c < t.length - 1; c++) {
          var y = (a = c + s * t.length),
            x = a + t.length,
            b = a + t.length + 1,
            _ = a + 1;
          l.push(y, x, _), l.push(x, b, _);
        }
      if (
        (this.setIndex(l),
        this.addAttribute("position", new xt(u, 3)),
        this.addAttribute("uv", new xt(h, 2)),
        this.computeVertexNormals(),
        r === 2 * Math.PI)
      ) {
        var w = this.attributes.normal.array,
          M = new o(),
          E = new o(),
          T = new o();
        for (a = e * t.length * 3, s = 0, c = 0; s < t.length; s++, c += 3)
          (M.x = w[c + 0]),
            (M.y = w[c + 1]),
            (M.z = w[c + 2]),
            (E.x = w[a + c + 0]),
            (E.y = w[a + c + 1]),
            (E.z = w[a + c + 2]),
            T.addVectors(M, E).normalize(),
            (w[c + 0] = w[a + c + 0] = T.x),
            (w[c + 1] = w[a + c + 1] = T.y),
            (w[c + 2] = w[a + c + 2] = T.z);
      }
    }
    function We(t, e) {
      ut.call(this),
        (this.type = "ShapeGeometry"),
        "object" == typeof e &&
          (console.warn(
            "THREE.ShapeGeometry: Options parameter has been removed."
          ),
          (e = e.curveSegments)),
        (this.parameters = { shapes: t, curveSegments: e }),
        this.fromBufferGeometry(new Xe(t, e)),
        this.mergeVertices();
    }
    function Xe(t, e) {
      function n(t) {
        var n,
          s,
          l,
          u = r.length / 3,
          h = t.extractPoints(e),
          p = h.shape,
          d = h.holes;
        if (!1 === Sa.isClockWise(p))
          for (p = p.reverse(), n = 0, s = d.length; n < s; n++)
            (l = d[n]), !0 === Sa.isClockWise(l) && (d[n] = l.reverse());
        var f = Sa.triangulateShape(p, d);
        for (n = 0, s = d.length; n < s; n++) (l = d[n]), (p = p.concat(l));
        for (n = 0, s = p.length; n < s; n++) {
          var m = p[n];
          r.push(m.x, m.y, 0), o.push(0, 0, 1), a.push(m.x, m.y);
        }
        for (n = 0, s = f.length; n < s; n++) {
          var g = f[n],
            v = g[0] + u,
            y = g[1] + u,
            x = g[2] + u;
          i.push(v, y, x), (c += 3);
        }
      }
      Mt.call(this),
        (this.type = "ShapeBufferGeometry"),
        (this.parameters = { shapes: t, curveSegments: e }),
        (e = e || 12);
      var i = [],
        r = [],
        o = [],
        a = [],
        s = 0,
        c = 0;
      if (!1 === Array.isArray(t)) n(t);
      else
        for (var l = 0; l < t.length; l++)
          n(t[l]), this.addGroup(s, c, l), (s += c), (c = 0);
      this.setIndex(i),
        this.addAttribute("position", new xt(r, 3)),
        this.addAttribute("normal", new xt(o, 3)),
        this.addAttribute("uv", new xt(a, 2));
    }
    function Ye(t, e) {
      Mt.call(this),
        (this.type = "EdgesGeometry"),
        (this.parameters = { thresholdAngle: e }),
        (e = void 0 !== e ? e : 1);
      var n,
        i,
        r,
        o,
        a = [],
        s = Math.cos(sa.DEG2RAD * e),
        c = [0, 0],
        l = {},
        u = ["a", "b", "c"];
      t.isBufferGeometry
        ? (o = new ut()).fromBufferGeometry(t)
        : (o = t.clone()),
        o.mergeVertices(),
        o.computeFaceNormals();
      for (var h = o.vertices, p = o.faces, d = 0, f = p.length; d < f; d++)
        for (var m = p[d], g = 0; g < 3; g++)
          (n = m[u[g]]),
            (i = m[u[(g + 1) % 3]]),
            (c[0] = Math.min(n, i)),
            (c[1] = Math.max(n, i)),
            void 0 === l[(r = c[0] + "," + c[1])]
              ? (l[r] = { index1: c[0], index2: c[1], face1: d, face2: void 0 })
              : (l[r].face2 = d);
      for (r in l) {
        var v = l[r];
        if (
          void 0 === v.face2 ||
          p[v.face1].normal.dot(p[v.face2].normal) <= s
        ) {
          var y = h[v.index1];
          a.push(y.x, y.y, y.z), (y = h[v.index2]), a.push(y.x, y.y, y.z);
        }
      }
      this.addAttribute("position", new xt(a, 3));
    }
    function qe(t, e, n, i, r, o, a, s) {
      ut.call(this),
        (this.type = "CylinderGeometry"),
        (this.parameters = {
          radiusTop: t,
          radiusBottom: e,
          height: n,
          radialSegments: i,
          heightSegments: r,
          openEnded: o,
          thetaStart: a,
          thetaLength: s,
        }),
        this.fromBufferGeometry(new $e(t, e, n, i, r, o, a, s)),
        this.mergeVertices();
    }
    function $e(t, e, i, r, a, s, c, l) {
      function u(i) {
        var a,
          s,
          u,
          v = new n(),
          b = new o(),
          _ = 0,
          w = !0 === i ? t : e,
          M = !0 === i ? 1 : -1;
        for (s = g, a = 1; a <= r; a++)
          d.push(0, y * M, 0), f.push(0, M, 0), m.push(0.5, 0.5), g++;
        for (u = g, a = 0; a <= r; a++) {
          var E = (a / r) * l + c,
            T = Math.cos(E),
            S = Math.sin(E);
          (b.x = w * S),
            (b.y = y * M),
            (b.z = w * T),
            d.push(b.x, b.y, b.z),
            f.push(0, M, 0),
            (v.x = 0.5 * T + 0.5),
            (v.y = 0.5 * S * M + 0.5),
            m.push(v.x, v.y),
            g++;
        }
        for (a = 0; a < r; a++) {
          var A = s + a,
            L = u + a;
          !0 === i ? p.push(L, L + 1, A) : p.push(L + 1, L, A), (_ += 3);
        }
        h.addGroup(x, _, !0 === i ? 1 : 2), (x += _);
      }
      Mt.call(this),
        (this.type = "CylinderBufferGeometry"),
        (this.parameters = {
          radiusTop: t,
          radiusBottom: e,
          height: i,
          radialSegments: r,
          heightSegments: a,
          openEnded: s,
          thetaStart: c,
          thetaLength: l,
        });
      var h = this;
      (t = void 0 !== t ? t : 1),
        (e = void 0 !== e ? e : 1),
        (i = i || 1),
        (r = Math.floor(r) || 8),
        (a = Math.floor(a) || 1),
        (s = void 0 !== s && s),
        (c = void 0 !== c ? c : 0),
        (l = void 0 !== l ? l : 2 * Math.PI);
      var p = [],
        d = [],
        f = [],
        m = [],
        g = 0,
        v = [],
        y = i / 2,
        x = 0;
      !(function () {
        var n,
          s,
          u = new o(),
          b = new o(),
          _ = 0,
          w = (e - t) / i;
        for (s = 0; s <= a; s++) {
          var M = [],
            E = s / a,
            T = E * (e - t) + t;
          for (n = 0; n <= r; n++) {
            var S = n / r,
              A = S * l + c,
              L = Math.sin(A),
              R = Math.cos(A);
            (b.x = T * L),
              (b.y = -E * i + y),
              (b.z = T * R),
              d.push(b.x, b.y, b.z),
              u.set(L, w, R).normalize(),
              f.push(u.x, u.y, u.z),
              m.push(S, 1 - E),
              M.push(g++);
          }
          v.push(M);
        }
        for (n = 0; n < r; n++)
          for (s = 0; s < a; s++) {
            var P = v[s][n],
              C = v[s + 1][n],
              O = v[s + 1][n + 1],
              I = v[s][n + 1];
            p.push(P, C, I), p.push(C, O, I), (_ += 6);
          }
        h.addGroup(x, _, 0), (x += _);
      })(),
        !1 === s && (t > 0 && u(!0), e > 0 && u(!1)),
        this.setIndex(p),
        this.addAttribute("position", new xt(d, 3)),
        this.addAttribute("normal", new xt(f, 3)),
        this.addAttribute("uv", new xt(m, 2));
    }
    function Ze(t, e, n, i, r, o, a) {
      qe.call(this, 0, t, e, n, i, r, o, a),
        (this.type = "ConeGeometry"),
        (this.parameters = {
          radius: t,
          height: e,
          radialSegments: n,
          heightSegments: i,
          openEnded: r,
          thetaStart: o,
          thetaLength: a,
        });
    }
    function Je(t, e, n, i, r, o, a) {
      $e.call(this, 0, t, e, n, i, r, o, a),
        (this.type = "ConeBufferGeometry"),
        (this.parameters = {
          radius: t,
          height: e,
          radialSegments: n,
          heightSegments: i,
          openEnded: r,
          thetaStart: o,
          thetaLength: a,
        });
    }
    function Qe(t, e, n, i) {
      ut.call(this),
        (this.type = "CircleGeometry"),
        (this.parameters = {
          radius: t,
          segments: e,
          thetaStart: n,
          thetaLength: i,
        }),
        this.fromBufferGeometry(new Ke(t, e, n, i)),
        this.mergeVertices();
    }
    function Ke(t, e, i, r) {
      Mt.call(this),
        (this.type = "CircleBufferGeometry"),
        (this.parameters = {
          radius: t,
          segments: e,
          thetaStart: i,
          thetaLength: r,
        }),
        (t = t || 1),
        (e = void 0 !== e ? Math.max(3, e) : 8),
        (i = void 0 !== i ? i : 0),
        (r = void 0 !== r ? r : 2 * Math.PI);
      var a,
        s,
        c = [],
        l = [],
        u = [],
        h = [],
        p = new o(),
        d = new n();
      for (
        l.push(0, 0, 0), u.push(0, 0, 1), h.push(0.5, 0.5), s = 0, a = 3;
        s <= e;
        s++, a += 3
      ) {
        var f = i + (s / e) * r;
        (p.x = t * Math.cos(f)),
          (p.y = t * Math.sin(f)),
          l.push(p.x, p.y, p.z),
          u.push(0, 0, 1),
          (d.x = (l[a] / t + 1) / 2),
          (d.y = (l[a + 1] / t + 1) / 2),
          h.push(d.x, d.y);
      }
      for (a = 1; a <= e; a++) c.push(a, a + 1, 0);
      this.setIndex(c),
        this.addAttribute("position", new xt(l, 3)),
        this.addAttribute("normal", new xt(u, 3)),
        this.addAttribute("uv", new xt(h, 2));
    }
    function tn(t) {
      Z.call(this),
        (this.type = "ShadowMaterial"),
        (this.color = new W(0)),
        (this.opacity = 1),
        (this.lights = !0),
        (this.transparent = !0),
        this.setValues(t);
    }
    function en(t) {
      Rt.call(this, t), (this.type = "RawShaderMaterial");
    }
    function nn(t) {
      Z.call(this),
        (this.defines = { STANDARD: "" }),
        (this.type = "MeshStandardMaterial"),
        (this.color = new W(16777215)),
        (this.roughness = 0.5),
        (this.metalness = 0.5),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.emissive = new W(0)),
        (this.emissiveIntensity = 1),
        (this.emissiveMap = null),
        (this.bumpMap = null),
        (this.bumpScale = 1),
        (this.normalMap = null),
        (this.normalScale = new n(1, 1)),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.roughnessMap = null),
        (this.metalnessMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.envMapIntensity = 1),
        (this.refractionRatio = 0.98),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.morphNormals = !1),
        this.setValues(t);
    }
    function rn(t) {
      nn.call(this),
        (this.defines = { PHYSICAL: "" }),
        (this.type = "MeshPhysicalMaterial"),
        (this.reflectivity = 0.5),
        (this.clearCoat = 0),
        (this.clearCoatRoughness = 0),
        this.setValues(t);
    }
    function on(t) {
      Z.call(this),
        (this.type = "MeshPhongMaterial"),
        (this.color = new W(16777215)),
        (this.specular = new W(1118481)),
        (this.shininess = 30),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.emissive = new W(0)),
        (this.emissiveIntensity = 1),
        (this.emissiveMap = null),
        (this.bumpMap = null),
        (this.bumpScale = 1),
        (this.normalMap = null),
        (this.normalScale = new n(1, 1)),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.specularMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.combine = qr),
        (this.reflectivity = 1),
        (this.refractionRatio = 0.98),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.morphNormals = !1),
        this.setValues(t);
    }
    function an(t) {
      on.call(this),
        (this.defines = { TOON: "" }),
        (this.type = "MeshToonMaterial"),
        (this.gradientMap = null),
        this.setValues(t);
    }
    function sn(t) {
      Z.call(this),
        (this.type = "MeshNormalMaterial"),
        (this.bumpMap = null),
        (this.bumpScale = 1),
        (this.normalMap = null),
        (this.normalScale = new n(1, 1)),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.fog = !1),
        (this.lights = !1),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.morphNormals = !1),
        this.setValues(t);
    }
    function cn(t) {
      Z.call(this),
        (this.type = "MeshLambertMaterial"),
        (this.color = new W(16777215)),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.emissive = new W(0)),
        (this.emissiveIntensity = 1),
        (this.emissiveMap = null),
        (this.specularMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.combine = qr),
        (this.reflectivity = 1),
        (this.refractionRatio = 0.98),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.skinning = !1),
        (this.morphTargets = !1),
        (this.morphNormals = !1),
        this.setValues(t);
    }
    function ln(t) {
      ae.call(this),
        (this.type = "LineDashedMaterial"),
        (this.scale = 1),
        (this.dashSize = 3),
        (this.gapSize = 1),
        this.setValues(t);
    }
    function un(t, e, n) {
      var i = this,
        r = !1,
        o = 0,
        a = 0,
        s = void 0;
      (this.onStart = void 0),
        (this.onLoad = t),
        (this.onProgress = e),
        (this.onError = n),
        (this.itemStart = function (t) {
          a++, !1 === r && void 0 !== i.onStart && i.onStart(t, o, a), (r = !0);
        }),
        (this.itemEnd = function (t) {
          o++,
            void 0 !== i.onProgress && i.onProgress(t, o, a),
            o === a && ((r = !1), void 0 !== i.onLoad && i.onLoad());
        }),
        (this.itemError = function (t) {
          void 0 !== i.onError && i.onError(t);
        }),
        (this.resolveURL = function (t) {
          return s ? s(t) : t;
        }),
        (this.setURLModifier = function (t) {
          s = t;
        });
    }
    function hn(t) {
      this.manager = void 0 !== t ? t : Pa;
    }
    function pn(t) {
      (this.manager = void 0 !== t ? t : Pa), (this._parser = null);
    }
    function dn(t) {
      (this.manager = void 0 !== t ? t : Pa), (this._parser = null);
    }
    function fn(t) {
      this.manager = void 0 !== t ? t : Pa;
    }
    function mn(t) {
      this.manager = void 0 !== t ? t : Pa;
    }
    function gn(t) {
      this.manager = void 0 !== t ? t : Pa;
    }
    function vn(t, e) {
      at.call(this),
        (this.type = "Light"),
        (this.color = new W(t)),
        (this.intensity = void 0 !== e ? e : 1),
        (this.receiveShadow = void 0);
    }
    function yn(t, e, n) {
      vn.call(this, t, n),
        (this.type = "HemisphereLight"),
        (this.castShadow = void 0),
        this.position.copy(at.DefaultUp),
        this.updateMatrix(),
        (this.groundColor = new W(e));
    }
    function xn(t) {
      (this.camera = t),
        (this.bias = 0),
        (this.radius = 1),
        (this.mapSize = new n(512, 512)),
        (this.map = null),
        (this.matrix = new i());
    }
    function bn() {
      xn.call(this, new Xt(50, 1, 0.5, 500));
    }
    function _n(t, e, n, i, r, o) {
      vn.call(this, t, e),
        (this.type = "SpotLight"),
        this.position.copy(at.DefaultUp),
        this.updateMatrix(),
        (this.target = new at()),
        Object.defineProperty(this, "power", {
          get: function () {
            return this.intensity * Math.PI;
          },
          set: function (t) {
            this.intensity = t / Math.PI;
          },
        }),
        (this.distance = void 0 !== n ? n : 0),
        (this.angle = void 0 !== i ? i : Math.PI / 3),
        (this.penumbra = void 0 !== r ? r : 0),
        (this.decay = void 0 !== o ? o : 1),
        (this.shadow = new bn());
    }
    function wn(t, e, n, i) {
      vn.call(this, t, e),
        (this.type = "PointLight"),
        Object.defineProperty(this, "power", {
          get: function () {
            return 4 * this.intensity * Math.PI;
          },
          set: function (t) {
            this.intensity = t / (4 * Math.PI);
          },
        }),
        (this.distance = void 0 !== n ? n : 0),
        (this.decay = void 0 !== i ? i : 1),
        (this.shadow = new xn(new Xt(90, 1, 0.5, 500)));
    }
    function Mn() {
      xn.call(this, new ct(-5, 5, 5, -5, 0.5, 500));
    }
    function En(t, e) {
      vn.call(this, t, e),
        (this.type = "DirectionalLight"),
        this.position.copy(at.DefaultUp),
        this.updateMatrix(),
        (this.target = new at()),
        (this.shadow = new Mn());
    }
    function Tn(t, e) {
      vn.call(this, t, e),
        (this.type = "AmbientLight"),
        (this.castShadow = void 0);
    }
    function Sn(t, e, n, i) {
      vn.call(this, t, e),
        (this.type = "RectAreaLight"),
        this.position.set(0, 1, 0),
        this.updateMatrix(),
        (this.width = void 0 !== n ? n : 10),
        (this.height = void 0 !== i ? i : 10);
    }
    function An(t, e, n, i) {
      (this.parameterPositions = t),
        (this._cachedIndex = 0),
        (this.resultBuffer = void 0 !== i ? i : new e.constructor(n)),
        (this.sampleValues = e),
        (this.valueSize = n);
    }
    function Ln(t, e, n, i) {
      An.call(this, t, e, n, i),
        (this._weightPrev = -0),
        (this._offsetPrev = -0),
        (this._weightNext = -0),
        (this._offsetNext = -0);
    }
    function Rn(t, e, n, i) {
      An.call(this, t, e, n, i);
    }
    function Pn(t, e, n, i) {
      An.call(this, t, e, n, i);
    }
    function Cn(t, e, n, i) {
      if (void 0 === t) throw new Error("track name is undefined");
      if (void 0 === e || 0 === e.length)
        throw new Error("no keyframes in track named " + t);
      (this.name = t),
        (this.times = Oa.convertArray(e, this.TimeBufferType)),
        (this.values = Oa.convertArray(n, this.ValueBufferType)),
        this.setInterpolation(i || this.DefaultInterpolation),
        this.validate(),
        this.optimize();
    }
    function On(t, e, n, i) {
      Cn.call(this, t, e, n, i);
    }
    function In(t, e, n, i) {
      An.call(this, t, e, n, i);
    }
    function Dn(t, e, n, i) {
      Cn.call(this, t, e, n, i);
    }
    function Un(t, e, n, i) {
      Cn.call(this, t, e, n, i);
    }
    function Nn(t, e, n, i) {
      Cn.call(this, t, e, n, i);
    }
    function zn(t, e, n) {
      Cn.call(this, t, e, n);
    }
    function kn(t, e, n, i) {
      Cn.call(this, t, e, n, i);
    }
    function Fn(t, e, n, i) {
      Cn.apply(this, t, e, n, i);
    }
    function Bn(t, e, n) {
      (this.name = t),
        (this.tracks = n),
        (this.duration = void 0 !== e ? e : -1),
        (this.uuid = sa.generateUUID()),
        this.duration < 0 && this.resetDuration(),
        this.optimize();
    }
    function Hn(t) {
      (this.manager = void 0 !== t ? t : Pa), (this.textures = {});
    }
    function jn(t) {
      this.manager = void 0 !== t ? t : Pa;
    }
    function Gn() {
      (this.onLoadStart = function () {}),
        (this.onLoadProgress = function () {}),
        (this.onLoadComplete = function () {});
    }
    function Vn(t) {
      "boolean" == typeof t &&
        (console.warn(
          "THREE.JSONLoader: showStatus parameter has been removed from constructor."
        ),
        (t = void 0)),
        (this.manager = void 0 !== t ? t : Pa),
        (this.withCredentials = !1);
    }
    function Wn(t) {
      (this.manager = void 0 !== t ? t : Pa), (this.texturePath = "");
    }
    function Xn(t, e, n, i, r) {
      var o = 0.5 * (i - e),
        a = 0.5 * (r - n),
        s = t * t;
      return (
        (2 * n - 2 * i + o + a) * (t * s) +
        (-3 * n + 3 * i - 2 * o - a) * s +
        o * t +
        n
      );
    }
    function Yn(t, e, n, i) {
      return (
        (function (t, n) {
          var i = 1 - t;
          return i * i * e;
        })(t) +
        (function (t, e) {
          return 2 * (1 - t) * t * n;
        })(t) +
        (function (t, e) {
          return t * t * i;
        })(t)
      );
    }
    function qn(t, e, n, i, r) {
      return (
        (function (t, n) {
          var i = 1 - t;
          return i * i * i * e;
        })(t) +
        (function (t, e) {
          var i = 1 - t;
          return 3 * i * i * t * n;
        })(t) +
        (function (t, e) {
          return 3 * (1 - t) * t * t * i;
        })(t) +
        (function (t, e) {
          return t * t * t * r;
        })(t)
      );
    }
    function $n() {
      (this.type = "Curve"), (this.arcLengthDivisions = 200);
    }
    function Zn(t, e) {
      $n.call(this),
        (this.type = "LineCurve"),
        (this.v1 = t || new n()),
        (this.v2 = e || new n());
    }
    function Jn() {
      $n.call(this),
        (this.type = "CurvePath"),
        (this.curves = []),
        (this.autoClose = !1);
    }
    function Qn(t, e, n, i, r, o, a, s) {
      $n.call(this),
        (this.type = "EllipseCurve"),
        (this.aX = t || 0),
        (this.aY = e || 0),
        (this.xRadius = n || 1),
        (this.yRadius = i || 1),
        (this.aStartAngle = r || 0),
        (this.aEndAngle = o || 2 * Math.PI),
        (this.aClockwise = a || !1),
        (this.aRotation = s || 0);
    }
    function Kn(t) {
      $n.call(this), (this.type = "SplineCurve"), (this.points = t || []);
    }
    function ti(t, e, i, r) {
      $n.call(this),
        (this.type = "CubicBezierCurve"),
        (this.v0 = t || new n()),
        (this.v1 = e || new n()),
        (this.v2 = i || new n()),
        (this.v3 = r || new n());
    }
    function ei(t, e, i) {
      $n.call(this),
        (this.type = "QuadraticBezierCurve"),
        (this.v0 = t || new n()),
        (this.v1 = e || new n()),
        (this.v2 = i || new n());
    }
    function ni(t) {
      Jn.call(this),
        (this.type = "Path"),
        (this.currentPoint = new n()),
        t && this.setFromPoints(t);
    }
    function ii(t) {
      ni.call(this, t), (this.type = "Shape"), (this.holes = []);
    }
    function ri() {
      (this.type = "ShapePath"),
        (this.subPaths = []),
        (this.currentPath = null);
    }
    function oi(t) {
      (this.type = "Font"), (this.data = t);
    }
    function ai(t) {
      this.manager = void 0 !== t ? t : Pa;
    }
    function si(t) {
      this.manager = void 0 !== t ? t : Pa;
    }
    function ci() {
      (this.type = "StereoCamera"),
        (this.aspect = 1),
        (this.eyeSep = 0.064),
        (this.cameraL = new Xt()),
        this.cameraL.layers.enable(1),
        (this.cameraL.matrixAutoUpdate = !1),
        (this.cameraR = new Xt()),
        this.cameraR.layers.enable(2),
        (this.cameraR.matrixAutoUpdate = !1);
    }
    function li(t, e, n) {
      at.call(this), (this.type = "CubeCamera");
      var i = new Xt(90, 1, t, e);
      i.up.set(0, -1, 0), i.lookAt(new o(1, 0, 0)), this.add(i);
      var r = new Xt(90, 1, t, e);
      r.up.set(0, -1, 0), r.lookAt(new o(-1, 0, 0)), this.add(r);
      var a = new Xt(90, 1, t, e);
      a.up.set(0, 0, 1), a.lookAt(new o(0, 1, 0)), this.add(a);
      var s = new Xt(90, 1, t, e);
      s.up.set(0, 0, -1), s.lookAt(new o(0, -1, 0)), this.add(s);
      var c = new Xt(90, 1, t, e);
      c.up.set(0, -1, 0), c.lookAt(new o(0, 0, 1)), this.add(c);
      var l = new Xt(90, 1, t, e);
      l.up.set(0, -1, 0), l.lookAt(new o(0, 0, -1)), this.add(l);
      var h = { format: Oo, magFilter: go, minFilter: go };
      (this.renderTarget = new u(n, n, h)),
        (this.renderTarget.texture.name = "CubeCamera"),
        (this.update = function (t, e) {
          null === this.parent && this.updateMatrixWorld();
          var n = this.renderTarget,
            o = n.texture.generateMipmaps;
          (n.texture.generateMipmaps = !1),
            (n.activeCubeFace = 0),
            t.render(e, i, n),
            (n.activeCubeFace = 1),
            t.render(e, r, n),
            (n.activeCubeFace = 2),
            t.render(e, a, n),
            (n.activeCubeFace = 3),
            t.render(e, s, n),
            (n.activeCubeFace = 4),
            t.render(e, c, n),
            (n.texture.generateMipmaps = o),
            (n.activeCubeFace = 5),
            t.render(e, l, n),
            t.setRenderTarget(null);
        }),
        (this.clear = function (t, e, n, i) {
          for (var r = this.renderTarget, o = 0; o < 6; o++)
            (r.activeCubeFace = o), t.setRenderTarget(r), t.clear(e, n, i);
          t.setRenderTarget(null);
        });
    }
    function ui() {
      at.call(this),
        (this.type = "AudioListener"),
        (this.context = Ba.getContext()),
        (this.gain = this.context.createGain()),
        this.gain.connect(this.context.destination),
        (this.filter = null);
    }
    function hi(t) {
      at.call(this),
        (this.type = "Audio"),
        (this.context = t.context),
        (this.gain = this.context.createGain()),
        this.gain.connect(t.getInput()),
        (this.autoplay = !1),
        (this.buffer = null),
        (this.loop = !1),
        (this.startTime = 0),
        (this.offset = 0),
        (this.playbackRate = 1),
        (this.isPlaying = !1),
        (this.hasPlaybackControl = !0),
        (this.sourceType = "empty"),
        (this.filters = []);
    }
    function pi(t) {
      hi.call(this, t),
        (this.panner = this.context.createPanner()),
        this.panner.connect(this.gain);
    }
    function di(t, e) {
      (this.analyser = t.context.createAnalyser()),
        (this.analyser.fftSize = void 0 !== e ? e : 2048),
        (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
        t.getOutput().connect(this.analyser);
    }
    function fi(t, e, n) {
      (this.binding = t), (this.valueSize = n);
      var i,
        r = Float64Array;
      switch (e) {
        case "quaternion":
          i = this._slerp;
          break;
        case "string":
        case "bool":
          (r = Array), (i = this._select);
          break;
        default:
          i = this._lerp;
      }
      (this.buffer = new r(4 * n)),
        (this._mixBufferRegion = i),
        (this.cumulativeWeight = 0),
        (this.useCount = 0),
        (this.referenceCount = 0);
    }
    function mi(t, e, n) {
      var i = n || gi.parseTrackName(e);
      (this._targetGroup = t), (this._bindings = t.subscribe_(e, i));
    }
    function gi(t, e, n) {
      (this.path = e),
        (this.parsedPath = n || gi.parseTrackName(e)),
        (this.node = gi.findNode(t, this.parsedPath.nodeName) || t),
        (this.rootNode = t);
    }
    function vi() {
      (this.uuid = sa.generateUUID()),
        (this._objects = Array.prototype.slice.call(arguments)),
        (this.nCachedObjects_ = 0);
      var t = {};
      this._indicesByUUID = t;
      for (var e = 0, n = arguments.length; e !== n; ++e)
        t[arguments[e].uuid] = e;
      (this._paths = []),
        (this._parsedPaths = []),
        (this._bindings = []),
        (this._bindingsIndicesByPath = {});
      var i = this;
      this.stats = {
        objects: {
          get total() {
            return i._objects.length;
          },
          get inUse() {
            return this.total - i.nCachedObjects_;
          },
        },
        get bindingsPerObject() {
          return i._bindings.length;
        },
      };
    }
    function yi(t, e, n) {
      (this._mixer = t), (this._clip = e), (this._localRoot = n || null);
      for (
        var i = e.tracks,
          r = i.length,
          o = new Array(r),
          a = { endingStart: qo, endingEnd: qo },
          s = 0;
        s !== r;
        ++s
      ) {
        var c = i[s].createInterpolant(null);
        (o[s] = c), (c.settings = a);
      }
      (this._interpolantSettings = a),
        (this._interpolants = o),
        (this._propertyBindings = new Array(r)),
        (this._cacheIndex = null),
        (this._byClipCacheIndex = null),
        (this._timeScaleInterpolant = null),
        (this._weightInterpolant = null),
        (this.loop = Yo),
        (this._loopCount = -1),
        (this._startTime = null),
        (this.time = 0),
        (this.timeScale = 1),
        (this._effectiveTimeScale = 1),
        (this.weight = 1),
        (this._effectiveWeight = 1),
        (this.repetitions = 1 / 0),
        (this.paused = !1),
        (this.enabled = !0),
        (this.clampWhenFinished = !1),
        (this.zeroSlopeAtStart = !0),
        (this.zeroSlopeAtEnd = !0);
    }
    function xi(t) {
      (this._root = t),
        this._initMemoryManager(),
        (this._accuIndex = 0),
        (this.time = 0),
        (this.timeScale = 1);
    }
    function bi(t) {
      "string" == typeof t &&
        (console.warn("THREE.Uniform: Type parameter is no longer needed."),
        (t = arguments[1])),
        (this.value = t);
    }
    function _i() {
      Mt.call(this),
        (this.type = "InstancedBufferGeometry"),
        (this.maxInstancedCount = void 0);
    }
    function wi(t, e, n, i) {
      (this.uuid = sa.generateUUID()),
        (this.data = t),
        (this.itemSize = e),
        (this.offset = n),
        (this.normalized = !0 === i);
    }
    function Mi(t, e) {
      (this.uuid = sa.generateUUID()),
        (this.array = t),
        (this.stride = e),
        (this.count = void 0 !== t ? t.length / e : 0),
        (this.dynamic = !1),
        (this.updateRange = { offset: 0, count: -1 }),
        (this.onUploadCallback = function () {}),
        (this.version = 0);
    }
    function Ei(t, e, n) {
      Mi.call(this, t, e), (this.meshPerAttribute = n || 1);
    }
    function Ti(t, e, n) {
      ht.call(this, t, e), (this.meshPerAttribute = n || 1);
    }
    function Si(t, e, n, i) {
      (this.ray = new Pt(t, e)),
        (this.near = n || 0),
        (this.far = i || 1 / 0),
        (this.params = {
          Mesh: {},
          Line: {},
          LOD: {},
          Points: { threshold: 1 },
          Sprite: {},
        }),
        Object.defineProperties(this.params, {
          PointCloud: {
            get: function () {
              return (
                console.warn(
                  "THREE.Raycaster: params.PointCloud has been renamed to params.Points."
                ),
                this.Points
              );
            },
          },
        });
    }
    function Ai(t, e) {
      return t.distance - e.distance;
    }
    function Li(t, e, n, i) {
      if (!1 !== t.visible && (t.raycast(e, n), !0 === i))
        for (var r = t.children, o = 0, a = r.length; o < a; o++)
          Li(r[o], e, n, !0);
    }
    function Ri(t) {
      (this.autoStart = void 0 === t || t),
        (this.startTime = 0),
        (this.oldTime = 0),
        (this.elapsedTime = 0),
        (this.running = !1);
    }
    function Pi(t, e, n) {
      return (
        (this.radius = void 0 !== t ? t : 1),
        (this.phi = void 0 !== e ? e : 0),
        (this.theta = void 0 !== n ? n : 0),
        this
      );
    }
    function Ci(t, e, n) {
      return (
        (this.radius = void 0 !== t ? t : 1),
        (this.theta = void 0 !== e ? e : 0),
        (this.y = void 0 !== n ? n : 0),
        this
      );
    }
    function Oi(t) {
      at.call(this), (this.material = t), (this.render = function () {});
    }
    function Ii(t, e, n, i) {
      (this.object = t), (this.size = void 0 !== e ? e : 1);
      var r = void 0 !== n ? n : 16711680,
        o = void 0 !== i ? i : 1,
        a = 0,
        s = this.object.geometry;
      s && s.isGeometry
        ? (a = 3 * s.faces.length)
        : s && s.isBufferGeometry && (a = s.attributes.normal.count);
      var c = new Mt(),
        l = new xt(2 * a * 3, 3);
      c.addAttribute("position", l),
        ce.call(this, c, new ae({ color: r, linewidth: o })),
        (this.matrixAutoUpdate = !1),
        this.update();
    }
    function Di(t, e) {
      at.call(this),
        (this.light = t),
        this.light.updateMatrixWorld(),
        (this.matrix = t.matrixWorld),
        (this.matrixAutoUpdate = !1),
        (this.color = e);
      for (
        var n = new Mt(),
          i = [
            0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0,
            1, 1, 0, 0, 0, 0, -1, 1,
          ],
          r = 0,
          o = 1;
        r < 32;
        r++, o++
      ) {
        var a = (r / 32) * Math.PI * 2,
          s = (o / 32) * Math.PI * 2;
        i.push(Math.cos(a), Math.sin(a), 1, Math.cos(s), Math.sin(s), 1);
      }
      n.addAttribute("position", new xt(i, 3));
      var c = new ae({ fog: !1 });
      (this.cone = new ce(n, c)), this.add(this.cone), this.update();
    }
    function Ui(t) {
      var e = [];
      t && t.isBone && e.push(t);
      for (var n = 0; n < t.children.length; n++)
        e.push.apply(e, Ui(t.children[n]));
      return e;
    }
    function Ni(t) {
      for (
        var e = Ui(t),
          n = new Mt(),
          i = [],
          r = [],
          o = new W(0, 0, 1),
          a = new W(0, 1, 0),
          s = 0;
        s < e.length;
        s++
      ) {
        var c = e[s];
        c.parent &&
          c.parent.isBone &&
          (i.push(0, 0, 0),
          i.push(0, 0, 0),
          r.push(o.r, o.g, o.b),
          r.push(a.r, a.g, a.b));
      }
      n.addAttribute("position", new xt(i, 3)),
        n.addAttribute("color", new xt(r, 3));
      var l = new ae({
        vertexColors: vr,
        depthTest: !1,
        depthWrite: !1,
        transparent: !0,
      });
      ce.call(this, n, l),
        (this.root = t),
        (this.bones = e),
        (this.matrix = t.matrixWorld),
        (this.matrixAutoUpdate = !1);
    }
    function zi(t, e, n) {
      (this.light = t), this.light.updateMatrixWorld(), (this.color = n);
      var i = new Be(e, 4, 2),
        r = new Lt({ wireframe: !0, fog: !1 });
      It.call(this, i, r),
        (this.matrix = this.light.matrixWorld),
        (this.matrixAutoUpdate = !1),
        this.update();
    }
    function ki(t, e) {
      at.call(this),
        (this.light = t),
        this.light.updateMatrixWorld(),
        (this.matrix = t.matrixWorld),
        (this.matrixAutoUpdate = !1),
        (this.color = e);
      var n = new ae({ fog: !1 }),
        i = new Mt();
      i.addAttribute("position", new ht(new Float32Array(15), 3)),
        (this.line = new se(i, n)),
        this.add(this.line),
        this.update();
    }
    function Fi(t, e, n) {
      at.call(this),
        (this.light = t),
        this.light.updateMatrixWorld(),
        (this.matrix = t.matrixWorld),
        (this.matrixAutoUpdate = !1),
        (this.color = n);
      var i = new Ee(e);
      i.rotateY(0.5 * Math.PI),
        (this.material = new Lt({ wireframe: !0, fog: !1 })),
        void 0 === this.color && (this.material.vertexColors = vr);
      var r = i.getAttribute("position"),
        o = new Float32Array(3 * r.count);
      i.addAttribute("color", new ht(o, 3)),
        this.add(new It(i, this.material)),
        this.update();
    }
    function Bi(t, e, n, i) {
      (t = t || 10),
        (e = e || 10),
        (n = new W(void 0 !== n ? n : 4473924)),
        (i = new W(void 0 !== i ? i : 8947848));
      for (
        var r = e / 2,
          o = t / e,
          a = t / 2,
          s = [],
          c = [],
          l = 0,
          u = 0,
          h = -a;
        l <= e;
        l++, h += o
      ) {
        s.push(-a, 0, h, a, 0, h), s.push(h, 0, -a, h, 0, a);
        var p = l === r ? n : i;
        p.toArray(c, u),
          (u += 3),
          p.toArray(c, u),
          (u += 3),
          p.toArray(c, u),
          (u += 3),
          p.toArray(c, u),
          (u += 3);
      }
      var d = new Mt();
      d.addAttribute("position", new xt(s, 3)),
        d.addAttribute("color", new xt(c, 3));
      var f = new ae({ vertexColors: vr });
      ce.call(this, d, f);
    }
    function Hi(t, e, n, i, r, o) {
      (t = t || 10),
        (e = e || 16),
        (n = n || 8),
        (i = i || 64),
        (r = new W(void 0 !== r ? r : 4473924)),
        (o = new W(void 0 !== o ? o : 8947848));
      var a,
        s,
        c,
        l,
        u,
        h,
        p,
        d = [],
        f = [];
      for (l = 0; l <= e; l++)
        (c = (l / e) * (2 * Math.PI)),
          (a = Math.sin(c) * t),
          (s = Math.cos(c) * t),
          d.push(0, 0, 0),
          d.push(a, 0, s),
          (p = 1 & l ? r : o),
          f.push(p.r, p.g, p.b),
          f.push(p.r, p.g, p.b);
      for (l = 0; l <= n; l++)
        for (p = 1 & l ? r : o, h = t - (t / n) * l, u = 0; u < i; u++)
          (c = (u / i) * (2 * Math.PI)),
            (a = Math.sin(c) * h),
            (s = Math.cos(c) * h),
            d.push(a, 0, s),
            f.push(p.r, p.g, p.b),
            (c = ((u + 1) / i) * (2 * Math.PI)),
            (a = Math.sin(c) * h),
            (s = Math.cos(c) * h),
            d.push(a, 0, s),
            f.push(p.r, p.g, p.b);
      var m = new Mt();
      m.addAttribute("position", new xt(d, 3)),
        m.addAttribute("color", new xt(f, 3));
      var g = new ae({ vertexColors: vr });
      ce.call(this, m, g);
    }
    function ji(t, e, n, i) {
      (this.object = t), (this.size = void 0 !== e ? e : 1);
      var r = void 0 !== n ? n : 16776960,
        o = void 0 !== i ? i : 1,
        a = 0,
        s = this.object.geometry;
      s && s.isGeometry
        ? (a = s.faces.length)
        : console.warn(
            "THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."
          );
      var c = new Mt(),
        l = new xt(2 * a * 3, 3);
      c.addAttribute("position", l),
        ce.call(this, c, new ae({ color: r, linewidth: o })),
        (this.matrixAutoUpdate = !1),
        this.update();
    }
    function Gi(t, e, n) {
      at.call(this),
        (this.light = t),
        this.light.updateMatrixWorld(),
        (this.matrix = t.matrixWorld),
        (this.matrixAutoUpdate = !1),
        (this.color = n),
        void 0 === e && (e = 1);
      var i = new Mt();
      i.addAttribute(
        "position",
        new xt([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)
      );
      var r = new ae({ fog: !1 });
      (this.lightPlane = new se(i, r)),
        this.add(this.lightPlane),
        (i = new Mt()).addAttribute("position", new xt([0, 0, 0, 0, 0, 1], 3)),
        (this.targetLine = new se(i, r)),
        this.add(this.targetLine),
        this.update();
    }
    function Vi(t) {
      function e(t, e, i) {
        n(t, i), n(e, i);
      }
      function n(t, e) {
        o.push(0, 0, 0),
          a.push(e.r, e.g, e.b),
          void 0 === s[t] && (s[t] = []),
          s[t].push(o.length / 3 - 1);
      }
      var i = new Mt(),
        r = new ae({ color: 16777215, vertexColors: gr }),
        o = [],
        a = [],
        s = {},
        c = new W(16755200),
        l = new W(16711680),
        u = new W(43775),
        h = new W(16777215),
        p = new W(3355443);
      e("n1", "n2", c),
        e("n2", "n4", c),
        e("n4", "n3", c),
        e("n3", "n1", c),
        e("f1", "f2", c),
        e("f2", "f4", c),
        e("f4", "f3", c),
        e("f3", "f1", c),
        e("n1", "f1", c),
        e("n2", "f2", c),
        e("n3", "f3", c),
        e("n4", "f4", c),
        e("p", "n1", l),
        e("p", "n2", l),
        e("p", "n3", l),
        e("p", "n4", l),
        e("u1", "u2", u),
        e("u2", "u3", u),
        e("u3", "u1", u),
        e("c", "t", h),
        e("p", "c", p),
        e("cn1", "cn2", p),
        e("cn3", "cn4", p),
        e("cf1", "cf2", p),
        e("cf3", "cf4", p),
        i.addAttribute("position", new xt(o, 3)),
        i.addAttribute("color", new xt(a, 3)),
        ce.call(this, i, r),
        (this.camera = t),
        this.camera.updateProjectionMatrix &&
          this.camera.updateProjectionMatrix(),
        (this.matrix = t.matrixWorld),
        (this.matrixAutoUpdate = !1),
        (this.pointMap = s),
        this.update();
    }
    function Wi(t, e) {
      (this.object = t), void 0 === e && (e = 16776960);
      var n = new Uint16Array([
          0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3,
          7,
        ]),
        i = new Float32Array(24),
        r = new Mt();
      r.setIndex(new ht(n, 1)),
        r.addAttribute("position", new ht(i, 3)),
        ce.call(this, r, new ae({ color: e })),
        (this.matrixAutoUpdate = !1),
        this.update();
    }
    function Xi(t, e) {
      (this.type = "Box3Helper"), (this.box = t);
      var n = void 0 !== e ? e : 16776960,
        i = new Uint16Array([
          0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3,
          7,
        ]),
        r = new Mt();
      r.setIndex(new ht(i, 1)),
        r.addAttribute(
          "position",
          new xt(
            [
              1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1,
              -1, -1, 1, -1, -1,
            ],
            3
          )
        ),
        ce.call(this, r, new ae({ color: n })),
        this.geometry.computeBoundingSphere();
    }
    function Yi(t, e, n) {
      (this.type = "PlaneHelper"),
        (this.plane = t),
        (this.size = void 0 === e ? 1 : e);
      var i = void 0 !== n ? n : 16776960,
        r = new Mt();
      r.addAttribute(
        "position",
        new xt(
          [
            1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1,
            1, 1, 1, 1, 0, 0, 1, 0, 0, 0,
          ],
          3
        )
      ),
        r.computeBoundingSphere(),
        se.call(this, r, new ae({ color: i }));
      var o = new Mt();
      o.addAttribute(
        "position",
        new xt([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)
      ),
        o.computeBoundingSphere(),
        this.add(
          new It(
            o,
            new Lt({ color: i, opacity: 0.2, transparent: !0, depthWrite: !1 })
          )
        );
    }
    function qi(t, e, n, i, r, o) {
      at.call(this),
        void 0 === i && (i = 16776960),
        void 0 === n && (n = 1),
        void 0 === r && (r = 0.2 * n),
        void 0 === o && (o = 0.2 * r),
        void 0 === Ha &&
          ((Ha = new Mt()).addAttribute(
            "position",
            new xt([0, 0, 0, 0, 1, 0], 3)
          ),
          (ja = new $e(0, 0.5, 1, 5, 1)).translate(0, -0.5, 0)),
        this.position.copy(e),
        (this.line = new se(Ha, new ae({ color: i }))),
        (this.line.matrixAutoUpdate = !1),
        this.add(this.line),
        (this.cone = new It(ja, new Lt({ color: i }))),
        (this.cone.matrixAutoUpdate = !1),
        this.add(this.cone),
        this.setDirection(t),
        this.setLength(n, r, o);
    }
    function $i(t) {
      var e = [0, 0, 0, (t = t || 1), 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
        n = new Mt();
      n.addAttribute("position", new xt(e, 3)),
        n.addAttribute(
          "color",
          new xt(
            [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
            3
          )
        );
      var i = new ae({ vertexColors: vr });
      ce.call(this, n, i);
    }
    function Zi() {
      function t(t, o, a, s) {
        (e = t),
          (n = a),
          (i = -3 * t + 3 * o - 2 * a - s),
          (r = 2 * t - 2 * o + a + s);
      }
      var e = 0,
        n = 0,
        i = 0,
        r = 0;
      return {
        initCatmullRom: function (e, n, i, r, o) {
          t(n, i, o * (i - e), o * (r - n));
        },
        initNonuniformCatmullRom: function (e, n, i, r, o, a, s) {
          var c = (n - e) / o - (i - e) / (o + a) + (i - n) / a,
            l = (i - n) / a - (r - n) / (a + s) + (r - i) / s;
          t(n, i, (c *= a), (l *= a));
        },
        calc: function (t) {
          var o = t * t;
          return e + n * t + i * o + r * (o * t);
        },
      };
    }
    function Ji(t, e, n, i) {
      $n.call(this),
        (this.type = "CatmullRomCurve3"),
        (this.points = t || []),
        (this.closed = e || !1),
        (this.curveType = n || "centripetal"),
        (this.tension = i || 0.5);
    }
    function Qi(t, e, n, i) {
      $n.call(this),
        (this.type = "CubicBezierCurve3"),
        (this.v0 = t || new o()),
        (this.v1 = e || new o()),
        (this.v2 = n || new o()),
        (this.v3 = i || new o());
    }
    function Ki(t, e, n) {
      $n.call(this),
        (this.type = "QuadraticBezierCurve3"),
        (this.v0 = t || new o()),
        (this.v1 = e || new o()),
        (this.v2 = n || new o());
    }
    function tr(t, e) {
      $n.call(this),
        (this.type = "LineCurve3"),
        (this.v1 = t || new o()),
        (this.v2 = e || new o());
    }
    function er(t, e, n, i, r, o) {
      Qn.call(this, t, e, n, n, i, r, o), (this.type = "ArcCurve");
    }
    function nr(t) {
      console.warn(
        "THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."
      ),
        Ji.call(this, t),
        (this.type = "catmullrom"),
        (this.closed = !0);
    }
    function ir(t) {
      console.warn(
        "THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."
      ),
        Ji.call(this, t),
        (this.type = "catmullrom");
    }
    function rr(t) {
      console.warn(
        "THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."
      ),
        Ji.call(this, t),
        (this.type = "catmullrom");
    }
    void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
      void 0 === Number.isInteger &&
        (Number.isInteger = function (t) {
          return "number" == typeof t && isFinite(t) && Math.floor(t) === t;
        }),
      void 0 === Math.sign &&
        (Math.sign = function (t) {
          return t < 0 ? -1 : t > 0 ? 1 : +t;
        }),
      "name" in Function.prototype == 0 &&
        Object.defineProperty(Function.prototype, "name", {
          get: function () {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
          },
        }),
      void 0 === Object.assign &&
        (Object.assign = function (t) {
          if (void 0 === t || null === t)
            throw new TypeError("Cannot convert undefined or null to object");
          for (var e = Object(t), n = 1; n < arguments.length; n++) {
            var i = arguments[n];
            if (void 0 !== i && null !== i)
              for (var r in i)
                Object.prototype.hasOwnProperty.call(i, r) && (e[r] = i[r]);
          }
          return e;
        }),
      Object.assign(e.prototype, {
        addEventListener: function (t, e) {
          void 0 === this._listeners && (this._listeners = {});
          var n = this._listeners;
          void 0 === n[t] && (n[t] = []),
            -1 === n[t].indexOf(e) && n[t].push(e);
        },
        hasEventListener: function (t, e) {
          if (void 0 === this._listeners) return !1;
          var n = this._listeners;
          return void 0 !== n[t] && -1 !== n[t].indexOf(e);
        },
        removeEventListener: function (t, e) {
          if (void 0 !== this._listeners) {
            var n = this._listeners[t];
            if (void 0 !== n) {
              var i = n.indexOf(e);
              -1 !== i && n.splice(i, 1);
            }
          }
        },
        dispatchEvent: function (t) {
          if (void 0 !== this._listeners) {
            var e = this._listeners[t.type];
            if (void 0 !== e) {
              t.target = this;
              for (var n = e.slice(0), i = 0, r = n.length; i < r; i++)
                n[i].call(this, t);
            }
          }
        },
      });
    var or = "88",
      ar = 0,
      sr = 1,
      cr = 2,
      lr = 0,
      ur = 1,
      hr = 2,
      pr = 0,
      dr = 1,
      fr = 2,
      mr = 0,
      gr = 1,
      vr = 2,
      yr = 0,
      xr = 1,
      br = 2,
      _r = 3,
      wr = 4,
      Mr = 5,
      Er = 100,
      Tr = 101,
      Sr = 102,
      Ar = 103,
      Lr = 104,
      Rr = 200,
      Pr = 201,
      Cr = 202,
      Or = 203,
      Ir = 204,
      Dr = 205,
      Ur = 206,
      Nr = 207,
      zr = 208,
      kr = 209,
      Fr = 210,
      Br = 0,
      Hr = 1,
      jr = 2,
      Gr = 3,
      Vr = 4,
      Wr = 5,
      Xr = 6,
      Yr = 7,
      qr = 0,
      $r = 1,
      Zr = 2,
      Jr = 0,
      Qr = 1,
      Kr = 2,
      to = 3,
      eo = 4,
      no = 301,
      io = 302,
      ro = 303,
      oo = 304,
      ao = 305,
      so = 306,
      co = 307,
      lo = 1e3,
      uo = 1001,
      ho = 1002,
      po = 1003,
      fo = 1004,
      mo = 1005,
      go = 1006,
      vo = 1007,
      yo = 1008,
      xo = 1009,
      bo = 1010,
      _o = 1011,
      wo = 1012,
      Mo = 1013,
      Eo = 1014,
      To = 1015,
      So = 1016,
      Ao = 1017,
      Lo = 1018,
      Ro = 1019,
      Po = 1020,
      Co = 1021,
      Oo = 1022,
      Io = 1023,
      Do = 1024,
      Uo = 1025,
      No = 1026,
      zo = 1027,
      ko = 2001,
      Fo = 2002,
      Bo = 2003,
      Ho = 2004,
      jo = 2100,
      Go = 2101,
      Vo = 2102,
      Wo = 2103,
      Xo = 2151,
      Yo = 2201,
      qo = 2400,
      $o = 0,
      Zo = 1,
      Jo = 2,
      Qo = 3e3,
      Ko = 3001,
      ta = 3007,
      ea = 3002,
      na = 3004,
      ia = 3005,
      ra = 3006,
      oa = 3200,
      aa = 3201,
      sa = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: (function () {
          var t,
            e =
              "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(
                ""
              ),
            n = 0;
          return function () {
            for (var i = "", r = 0; r < 36; r++)
              8 === r || 13 === r || 18 === r || 23 === r
                ? (i += "-")
                : 14 === r
                ? (i += "4")
                : (n <= 2 && (n = (33554432 + 16777216 * Math.random()) | 0),
                  (t = 15 & n),
                  (n >>= 4),
                  (i += e[19 === r ? (3 & t) | 8 : t]));
            return i;
          };
        })(),
        clamp: function (t, e, n) {
          return Math.max(e, Math.min(n, t));
        },
        euclideanModulo: function (t, e) {
          return ((t % e) + e) % e;
        },
        mapLinear: function (t, e, n, i, r) {
          return i + ((t - e) * (r - i)) / (n - e);
        },
        lerp: function (t, e, n) {
          return (1 - n) * t + n * e;
        },
        smoothstep: function (t, e, n) {
          return t <= e
            ? 0
            : t >= n
            ? 1
            : (t = (t - e) / (n - e)) * t * (3 - 2 * t);
        },
        smootherstep: function (t, e, n) {
          return t <= e
            ? 0
            : t >= n
            ? 1
            : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10);
        },
        randInt: function (t, e) {
          return t + Math.floor(Math.random() * (e - t + 1));
        },
        randFloat: function (t, e) {
          return t + Math.random() * (e - t);
        },
        randFloatSpread: function (t) {
          return t * (0.5 - Math.random());
        },
        degToRad: function (t) {
          return t * sa.DEG2RAD;
        },
        radToDeg: function (t) {
          return t * sa.RAD2DEG;
        },
        isPowerOfTwo: function (t) {
          return 0 == (t & (t - 1)) && 0 !== t;
        },
        ceilPowerOfTwo: function (t) {
          return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
        },
        floorPowerOfTwo: function (t) {
          return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
        },
      };
    Object.defineProperties(n.prototype, {
      width: {
        get: function () {
          return this.x;
        },
        set: function (t) {
          this.x = t;
        },
      },
      height: {
        get: function () {
          return this.y;
        },
        set: function (t) {
          this.y = t;
        },
      },
    }),
      Object.assign(n.prototype, {
        isVector2: !0,
        set: function (t, e) {
          return (this.x = t), (this.y = e), this;
        },
        setScalar: function (t) {
          return (this.x = t), (this.y = t), this;
        },
        setX: function (t) {
          return (this.x = t), this;
        },
        setY: function (t) {
          return (this.y = t), this;
        },
        setComponent: function (t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        },
        getComponent: function (t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + t);
          }
        },
        clone: function () {
          return new this.constructor(this.x, this.y);
        },
        copy: function (t) {
          return (this.x = t.x), (this.y = t.y), this;
        },
        add: function (t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(t, e))
            : ((this.x += t.x), (this.y += t.y), this);
        },
        addScalar: function (t) {
          return (this.x += t), (this.y += t), this;
        },
        addVectors: function (t, e) {
          return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
        },
        addScaledVector: function (t, e) {
          return (this.x += t.x * e), (this.y += t.y * e), this;
        },
        sub: function (t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(t, e))
            : ((this.x -= t.x), (this.y -= t.y), this);
        },
        subScalar: function (t) {
          return (this.x -= t), (this.y -= t), this;
        },
        subVectors: function (t, e) {
          return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
        },
        multiply: function (t) {
          return (this.x *= t.x), (this.y *= t.y), this;
        },
        multiplyScalar: function (t) {
          return (this.x *= t), (this.y *= t), this;
        },
        divide: function (t) {
          return (this.x /= t.x), (this.y /= t.y), this;
        },
        divideScalar: function (t) {
          return this.multiplyScalar(1 / t);
        },
        applyMatrix3: function (t) {
          var e = this.x,
            n = this.y,
            i = t.elements;
          return (
            (this.x = i[0] * e + i[3] * n + i[6]),
            (this.y = i[1] * e + i[4] * n + i[7]),
            this
          );
        },
        min: function (t) {
          return (
            (this.x = Math.min(this.x, t.x)),
            (this.y = Math.min(this.y, t.y)),
            this
          );
        },
        max: function (t) {
          return (
            (this.x = Math.max(this.x, t.x)),
            (this.y = Math.max(this.y, t.y)),
            this
          );
        },
        clamp: function (t, e) {
          return (
            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
            this
          );
        },
        clampScalar: (function () {
          var t = new n(),
            e = new n();
          return function (n, i) {
            return t.set(n, n), e.set(i, i), this.clamp(t, e);
          };
        })(),
        clampLength: function (t, e) {
          var n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(t, Math.min(e, n))
          );
        },
        floor: function () {
          return (
            (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
          );
        },
        ceil: function () {
          return (
            (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
          );
        },
        round: function () {
          return (
            (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
          );
        },
        roundToZero: function () {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            this
          );
        },
        negate: function () {
          return (this.x = -this.x), (this.y = -this.y), this;
        },
        dot: function (t) {
          return this.x * t.x + this.y * t.y;
        },
        lengthSq: function () {
          return this.x * this.x + this.y * this.y;
        },
        length: function () {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        manhattanLength: function () {
          return Math.abs(this.x) + Math.abs(this.y);
        },
        normalize: function () {
          return this.divideScalar(this.length() || 1);
        },
        angle: function () {
          var t = Math.atan2(this.y, this.x);
          return t < 0 && (t += 2 * Math.PI), t;
        },
        distanceTo: function (t) {
          return Math.sqrt(this.distanceToSquared(t));
        },
        distanceToSquared: function (t) {
          var e = this.x - t.x,
            n = this.y - t.y;
          return e * e + n * n;
        },
        manhattanDistanceTo: function (t) {
          return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
        },
        setLength: function (t) {
          return this.normalize().multiplyScalar(t);
        },
        lerp: function (t, e) {
          return (
            (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this
          );
        },
        lerpVectors: function (t, e, n) {
          return this.subVectors(e, t).multiplyScalar(n).add(t);
        },
        equals: function (t) {
          return t.x === this.x && t.y === this.y;
        },
        fromArray: function (t, e) {
          return (
            void 0 === e && (e = 0), (this.x = t[e]), (this.y = t[e + 1]), this
          );
        },
        toArray: function (t, e) {
          return (
            void 0 === t && (t = []),
            void 0 === e && (e = 0),
            (t[e] = this.x),
            (t[e + 1] = this.y),
            t
          );
        },
        fromBufferAttribute: function (t, e, n) {
          return (
            void 0 !== n &&
              console.warn(
                "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = t.getX(e)),
            (this.y = t.getY(e)),
            this
          );
        },
        rotateAround: function (t, e) {
          var n = Math.cos(e),
            i = Math.sin(e),
            r = this.x - t.x,
            o = this.y - t.y;
          return (
            (this.x = r * n - o * i + t.x), (this.y = r * i + o * n + t.y), this
          );
        },
      }),
      Object.assign(i.prototype, {
        isMatrix4: !0,
        set: function (t, e, n, i, r, o, a, s, c, l, u, h, p, d, f, m) {
          var g = this.elements;
          return (
            (g[0] = t),
            (g[4] = e),
            (g[8] = n),
            (g[12] = i),
            (g[1] = r),
            (g[5] = o),
            (g[9] = a),
            (g[13] = s),
            (g[2] = c),
            (g[6] = l),
            (g[10] = u),
            (g[14] = h),
            (g[3] = p),
            (g[7] = d),
            (g[11] = f),
            (g[15] = m),
            this
          );
        },
        identity: function () {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        },
        clone: function () {
          return new i().fromArray(this.elements);
        },
        copy: function (t) {
          var e = this.elements,
            n = t.elements;
          return (
            (e[0] = n[0]),
            (e[1] = n[1]),
            (e[2] = n[2]),
            (e[3] = n[3]),
            (e[4] = n[4]),
            (e[5] = n[5]),
            (e[6] = n[6]),
            (e[7] = n[7]),
            (e[8] = n[8]),
            (e[9] = n[9]),
            (e[10] = n[10]),
            (e[11] = n[11]),
            (e[12] = n[12]),
            (e[13] = n[13]),
            (e[14] = n[14]),
            (e[15] = n[15]),
            this
          );
        },
        copyPosition: function (t) {
          var e = this.elements,
            n = t.elements;
          return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
        },
        extractBasis: function (t, e, n) {
          return (
            t.setFromMatrixColumn(this, 0),
            e.setFromMatrixColumn(this, 1),
            n.setFromMatrixColumn(this, 2),
            this
          );
        },
        makeBasis: function (t, e, n) {
          return (
            this.set(
              t.x,
              e.x,
              n.x,
              0,
              t.y,
              e.y,
              n.y,
              0,
              t.z,
              e.z,
              n.z,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        },
        extractRotation: (function () {
          var t = new o();
          return function (e) {
            var n = this.elements,
              i = e.elements,
              r = 1 / t.setFromMatrixColumn(e, 0).length(),
              o = 1 / t.setFromMatrixColumn(e, 1).length(),
              a = 1 / t.setFromMatrixColumn(e, 2).length();
            return (
              (n[0] = i[0] * r),
              (n[1] = i[1] * r),
              (n[2] = i[2] * r),
              (n[4] = i[4] * o),
              (n[5] = i[5] * o),
              (n[6] = i[6] * o),
              (n[8] = i[8] * a),
              (n[9] = i[9] * a),
              (n[10] = i[10] * a),
              this
            );
          };
        })(),
        makeRotationFromEuler: function (t) {
          (t && t.isEuler) ||
            console.error(
              "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
            );
          var e = this.elements,
            n = t.x,
            i = t.y,
            r = t.z,
            o = Math.cos(n),
            a = Math.sin(n),
            s = Math.cos(i),
            c = Math.sin(i),
            l = Math.cos(r),
            u = Math.sin(r);
          if ("XYZ" === t.order) {
            var h = o * l,
              p = o * u,
              d = a * l,
              f = a * u;
            (e[0] = s * l),
              (e[4] = -s * u),
              (e[8] = c),
              (e[1] = p + d * c),
              (e[5] = h - f * c),
              (e[9] = -a * s),
              (e[2] = f - h * c),
              (e[6] = d + p * c),
              (e[10] = o * s);
          } else if ("YXZ" === t.order) {
            var m = s * l,
              g = s * u,
              v = c * l,
              y = c * u;
            (e[0] = m + y * a),
              (e[4] = v * a - g),
              (e[8] = o * c),
              (e[1] = o * u),
              (e[5] = o * l),
              (e[9] = -a),
              (e[2] = g * a - v),
              (e[6] = y + m * a),
              (e[10] = o * s);
          } else if ("ZXY" === t.order) {
            var m = s * l,
              g = s * u,
              v = c * l,
              y = c * u;
            (e[0] = m - y * a),
              (e[4] = -o * u),
              (e[8] = v + g * a),
              (e[1] = g + v * a),
              (e[5] = o * l),
              (e[9] = y - m * a),
              (e[2] = -o * c),
              (e[6] = a),
              (e[10] = o * s);
          } else if ("ZYX" === t.order) {
            var h = o * l,
              p = o * u,
              d = a * l,
              f = a * u;
            (e[0] = s * l),
              (e[4] = d * c - p),
              (e[8] = h * c + f),
              (e[1] = s * u),
              (e[5] = f * c + h),
              (e[9] = p * c - d),
              (e[2] = -c),
              (e[6] = a * s),
              (e[10] = o * s);
          } else if ("YZX" === t.order) {
            var x = o * s,
              b = o * c,
              _ = a * s,
              w = a * c;
            (e[0] = s * l),
              (e[4] = w - x * u),
              (e[8] = _ * u + b),
              (e[1] = u),
              (e[5] = o * l),
              (e[9] = -a * l),
              (e[2] = -c * l),
              (e[6] = b * u + _),
              (e[10] = x - w * u);
          } else if ("XZY" === t.order) {
            var x = o * s,
              b = o * c,
              _ = a * s,
              w = a * c;
            (e[0] = s * l),
              (e[4] = -u),
              (e[8] = c * l),
              (e[1] = x * u + w),
              (e[5] = o * l),
              (e[9] = b * u - _),
              (e[2] = _ * u - b),
              (e[6] = a * l),
              (e[10] = w * u + x);
          }
          return (
            (e[3] = 0),
            (e[7] = 0),
            (e[11] = 0),
            (e[12] = 0),
            (e[13] = 0),
            (e[14] = 0),
            (e[15] = 1),
            this
          );
        },
        makeRotationFromQuaternion: function (t) {
          var e = this.elements,
            n = t._x,
            i = t._y,
            r = t._z,
            o = t._w,
            a = n + n,
            s = i + i,
            c = r + r,
            l = n * a,
            u = n * s,
            h = n * c,
            p = i * s,
            d = i * c,
            f = r * c,
            m = o * a,
            g = o * s,
            v = o * c;
          return (
            (e[0] = 1 - (p + f)),
            (e[4] = u - v),
            (e[8] = h + g),
            (e[1] = u + v),
            (e[5] = 1 - (l + f)),
            (e[9] = d - m),
            (e[2] = h - g),
            (e[6] = d + m),
            (e[10] = 1 - (l + p)),
            (e[3] = 0),
            (e[7] = 0),
            (e[11] = 0),
            (e[12] = 0),
            (e[13] = 0),
            (e[14] = 0),
            (e[15] = 1),
            this
          );
        },
        lookAt: (function () {
          var t = new o(),
            e = new o(),
            n = new o();
          return function (i, r, o) {
            var a = this.elements;
            return (
              n.subVectors(i, r),
              0 === n.lengthSq() && (n.z = 1),
              n.normalize(),
              t.crossVectors(o, n),
              0 === t.lengthSq() &&
                (1 === Math.abs(o.z) ? (n.x += 1e-4) : (n.z += 1e-4),
                n.normalize(),
                t.crossVectors(o, n)),
              t.normalize(),
              e.crossVectors(n, t),
              (a[0] = t.x),
              (a[4] = e.x),
              (a[8] = n.x),
              (a[1] = t.y),
              (a[5] = e.y),
              (a[9] = n.y),
              (a[2] = t.z),
              (a[6] = e.z),
              (a[10] = n.z),
              this
            );
          };
        })(),
        multiply: function (t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
              ),
              this.multiplyMatrices(t, e))
            : this.multiplyMatrices(this, t);
        },
        premultiply: function (t) {
          return this.multiplyMatrices(t, this);
        },
        multiplyMatrices: function (t, e) {
          var n = t.elements,
            i = e.elements,
            r = this.elements,
            o = n[0],
            a = n[4],
            s = n[8],
            c = n[12],
            l = n[1],
            u = n[5],
            h = n[9],
            p = n[13],
            d = n[2],
            f = n[6],
            m = n[10],
            g = n[14],
            v = n[3],
            y = n[7],
            x = n[11],
            b = n[15],
            _ = i[0],
            w = i[4],
            M = i[8],
            E = i[12],
            T = i[1],
            S = i[5],
            A = i[9],
            L = i[13],
            R = i[2],
            P = i[6],
            C = i[10],
            O = i[14],
            I = i[3],
            D = i[7],
            U = i[11],
            N = i[15];
          return (
            (r[0] = o * _ + a * T + s * R + c * I),
            (r[4] = o * w + a * S + s * P + c * D),
            (r[8] = o * M + a * A + s * C + c * U),
            (r[12] = o * E + a * L + s * O + c * N),
            (r[1] = l * _ + u * T + h * R + p * I),
            (r[5] = l * w + u * S + h * P + p * D),
            (r[9] = l * M + u * A + h * C + p * U),
            (r[13] = l * E + u * L + h * O + p * N),
            (r[2] = d * _ + f * T + m * R + g * I),
            (r[6] = d * w + f * S + m * P + g * D),
            (r[10] = d * M + f * A + m * C + g * U),
            (r[14] = d * E + f * L + m * O + g * N),
            (r[3] = v * _ + y * T + x * R + b * I),
            (r[7] = v * w + y * S + x * P + b * D),
            (r[11] = v * M + y * A + x * C + b * U),
            (r[15] = v * E + y * L + x * O + b * N),
            this
          );
        },
        multiplyScalar: function (t) {
          var e = this.elements;
          return (
            (e[0] *= t),
            (e[4] *= t),
            (e[8] *= t),
            (e[12] *= t),
            (e[1] *= t),
            (e[5] *= t),
            (e[9] *= t),
            (e[13] *= t),
            (e[2] *= t),
            (e[6] *= t),
            (e[10] *= t),
            (e[14] *= t),
            (e[3] *= t),
            (e[7] *= t),
            (e[11] *= t),
            (e[15] *= t),
            this
          );
        },
        applyToBufferAttribute: (function () {
          var t = new o();
          return function (e) {
            for (var n = 0, i = e.count; n < i; n++)
              (t.x = e.getX(n)),
                (t.y = e.getY(n)),
                (t.z = e.getZ(n)),
                t.applyMatrix4(this),
                e.setXYZ(n, t.x, t.y, t.z);
            return e;
          };
        })(),
        determinant: function () {
          var t = this.elements,
            e = t[0],
            n = t[4],
            i = t[8],
            r = t[12],
            o = t[1],
            a = t[5],
            s = t[9],
            c = t[13],
            l = t[2],
            u = t[6],
            h = t[10],
            p = t[14];
          return (
            t[3] *
              (+r * s * u -
                i * c * u -
                r * a * h +
                n * c * h +
                i * a * p -
                n * s * p) +
            t[7] *
              (+e * s * p -
                e * c * h +
                r * o * h -
                i * o * p +
                i * c * l -
                r * s * l) +
            t[11] *
              (+e * c * u -
                e * a * p -
                r * o * u +
                n * o * p +
                r * a * l -
                n * c * l) +
            t[15] *
              (-i * a * l -
                e * s * u +
                e * a * h +
                i * o * u -
                n * o * h +
                n * s * l)
          );
        },
        transpose: function () {
          var t,
            e = this.elements;
          return (
            (t = e[1]),
            (e[1] = e[4]),
            (e[4] = t),
            (t = e[2]),
            (e[2] = e[8]),
            (e[8] = t),
            (t = e[6]),
            (e[6] = e[9]),
            (e[9] = t),
            (t = e[3]),
            (e[3] = e[12]),
            (e[12] = t),
            (t = e[7]),
            (e[7] = e[13]),
            (e[13] = t),
            (t = e[11]),
            (e[11] = e[14]),
            (e[14] = t),
            this
          );
        },
        setPosition: function (t) {
          var e = this.elements;
          return (e[12] = t.x), (e[13] = t.y), (e[14] = t.z), this;
        },
        getInverse: function (t, e) {
          var n = this.elements,
            i = t.elements,
            r = i[0],
            o = i[1],
            a = i[2],
            s = i[3],
            c = i[4],
            l = i[5],
            u = i[6],
            h = i[7],
            p = i[8],
            d = i[9],
            f = i[10],
            m = i[11],
            g = i[12],
            v = i[13],
            y = i[14],
            x = i[15],
            b =
              d * y * h -
              v * f * h +
              v * u * m -
              l * y * m -
              d * u * x +
              l * f * x,
            _ =
              g * f * h -
              p * y * h -
              g * u * m +
              c * y * m +
              p * u * x -
              c * f * x,
            w =
              p * v * h -
              g * d * h +
              g * l * m -
              c * v * m -
              p * l * x +
              c * d * x,
            M =
              g * d * u -
              p * v * u -
              g * l * f +
              c * v * f +
              p * l * y -
              c * d * y,
            E = r * b + o * _ + a * w + s * M;
          if (0 === E) {
            var T =
              "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
            if (!0 === e) throw new Error(T);
            return console.warn(T), this.identity();
          }
          var S = 1 / E;
          return (
            (n[0] = b * S),
            (n[1] =
              (v * f * s -
                d * y * s -
                v * a * m +
                o * y * m +
                d * a * x -
                o * f * x) *
              S),
            (n[2] =
              (l * y * s -
                v * u * s +
                v * a * h -
                o * y * h -
                l * a * x +
                o * u * x) *
              S),
            (n[3] =
              (d * u * s -
                l * f * s -
                d * a * h +
                o * f * h +
                l * a * m -
                o * u * m) *
              S),
            (n[4] = _ * S),
            (n[5] =
              (p * y * s -
                g * f * s +
                g * a * m -
                r * y * m -
                p * a * x +
                r * f * x) *
              S),
            (n[6] =
              (g * u * s -
                c * y * s -
                g * a * h +
                r * y * h +
                c * a * x -
                r * u * x) *
              S),
            (n[7] =
              (c * f * s -
                p * u * s +
                p * a * h -
                r * f * h -
                c * a * m +
                r * u * m) *
              S),
            (n[8] = w * S),
            (n[9] =
              (g * d * s -
                p * v * s -
                g * o * m +
                r * v * m +
                p * o * x -
                r * d * x) *
              S),
            (n[10] =
              (c * v * s -
                g * l * s +
                g * o * h -
                r * v * h -
                c * o * x +
                r * l * x) *
              S),
            (n[11] =
              (p * l * s -
                c * d * s -
                p * o * h +
                r * d * h +
                c * o * m -
                r * l * m) *
              S),
            (n[12] = M * S),
            (n[13] =
              (p * v * a -
                g * d * a +
                g * o * f -
                r * v * f -
                p * o * y +
                r * d * y) *
              S),
            (n[14] =
              (g * l * a -
                c * v * a -
                g * o * u +
                r * v * u +
                c * o * y -
                r * l * y) *
              S),
            (n[15] =
              (c * d * a -
                p * l * a +
                p * o * u -
                r * d * u -
                c * o * f +
                r * l * f) *
              S),
            this
          );
        },
        scale: function (t) {
          var e = this.elements,
            n = t.x,
            i = t.y,
            r = t.z;
          return (
            (e[0] *= n),
            (e[4] *= i),
            (e[8] *= r),
            (e[1] *= n),
            (e[5] *= i),
            (e[9] *= r),
            (e[2] *= n),
            (e[6] *= i),
            (e[10] *= r),
            (e[3] *= n),
            (e[7] *= i),
            (e[11] *= r),
            this
          );
        },
        getMaxScaleOnAxis: function () {
          var t = this.elements,
            e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
            n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
            i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
          return Math.sqrt(Math.max(e, n, i));
        },
        makeTranslation: function (t, e, n) {
          return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this;
        },
        makeRotationX: function (t) {
          var e = Math.cos(t),
            n = Math.sin(t);
          return (
            this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
          );
        },
        makeRotationY: function (t) {
          var e = Math.cos(t),
            n = Math.sin(t);
          return (
            this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
          );
        },
        makeRotationZ: function (t) {
          var e = Math.cos(t),
            n = Math.sin(t);
          return (
            this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
          );
        },
        makeRotationAxis: function (t, e) {
          var n = Math.cos(e),
            i = Math.sin(e),
            r = 1 - n,
            o = t.x,
            a = t.y,
            s = t.z,
            c = r * o,
            l = r * a;
          return (
            this.set(
              c * o + n,
              c * a - i * s,
              c * s + i * a,
              0,
              c * a + i * s,
              l * a + n,
              l * s - i * o,
              0,
              c * s - i * a,
              l * s + i * o,
              r * s * s + n,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        },
        makeScale: function (t, e, n) {
          return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
        },
        makeShear: function (t, e, n) {
          return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this;
        },
        compose: function (t, e, n) {
          return (
            this.makeRotationFromQuaternion(e),
            this.scale(n),
            this.setPosition(t),
            this
          );
        },
        decompose: (function () {
          var t = new o(),
            e = new i();
          return function (n, i, r) {
            var o = this.elements,
              a = t.set(o[0], o[1], o[2]).length(),
              s = t.set(o[4], o[5], o[6]).length(),
              c = t.set(o[8], o[9], o[10]).length();
            this.determinant() < 0 && (a = -a),
              (n.x = o[12]),
              (n.y = o[13]),
              (n.z = o[14]),
              e.copy(this);
            var l = 1 / a,
              u = 1 / s,
              h = 1 / c;
            return (
              (e.elements[0] *= l),
              (e.elements[1] *= l),
              (e.elements[2] *= l),
              (e.elements[4] *= u),
              (e.elements[5] *= u),
              (e.elements[6] *= u),
              (e.elements[8] *= h),
              (e.elements[9] *= h),
              (e.elements[10] *= h),
              i.setFromRotationMatrix(e),
              (r.x = a),
              (r.y = s),
              (r.z = c),
              this
            );
          };
        })(),
        makePerspective: function (t, e, n, i, r, o) {
          void 0 === o &&
            console.warn(
              "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
            );
          var a = this.elements,
            s = (2 * r) / (e - t),
            c = (2 * r) / (n - i),
            l = (e + t) / (e - t),
            u = (n + i) / (n - i),
            h = -(o + r) / (o - r),
            p = (-2 * o * r) / (o - r);
          return (
            (a[0] = s),
            (a[4] = 0),
            (a[8] = l),
            (a[12] = 0),
            (a[1] = 0),
            (a[5] = c),
            (a[9] = u),
            (a[13] = 0),
            (a[2] = 0),
            (a[6] = 0),
            (a[10] = h),
            (a[14] = p),
            (a[3] = 0),
            (a[7] = 0),
            (a[11] = -1),
            (a[15] = 0),
            this
          );
        },
        makeOrthographic: function (t, e, n, i, r, o) {
          var a = this.elements,
            s = 1 / (e - t),
            c = 1 / (n - i),
            l = 1 / (o - r),
            u = (e + t) * s,
            h = (n + i) * c,
            p = (o + r) * l;
          return (
            (a[0] = 2 * s),
            (a[4] = 0),
            (a[8] = 0),
            (a[12] = -u),
            (a[1] = 0),
            (a[5] = 2 * c),
            (a[9] = 0),
            (a[13] = -h),
            (a[2] = 0),
            (a[6] = 0),
            (a[10] = -2 * l),
            (a[14] = -p),
            (a[3] = 0),
            (a[7] = 0),
            (a[11] = 0),
            (a[15] = 1),
            this
          );
        },
        equals: function (t) {
          for (var e = this.elements, n = t.elements, i = 0; i < 16; i++)
            if (e[i] !== n[i]) return !1;
          return !0;
        },
        fromArray: function (t, e) {
          void 0 === e && (e = 0);
          for (var n = 0; n < 16; n++) this.elements[n] = t[n + e];
          return this;
        },
        toArray: function (t, e) {
          void 0 === t && (t = []), void 0 === e && (e = 0);
          var n = this.elements;
          return (
            (t[e] = n[0]),
            (t[e + 1] = n[1]),
            (t[e + 2] = n[2]),
            (t[e + 3] = n[3]),
            (t[e + 4] = n[4]),
            (t[e + 5] = n[5]),
            (t[e + 6] = n[6]),
            (t[e + 7] = n[7]),
            (t[e + 8] = n[8]),
            (t[e + 9] = n[9]),
            (t[e + 10] = n[10]),
            (t[e + 11] = n[11]),
            (t[e + 12] = n[12]),
            (t[e + 13] = n[13]),
            (t[e + 14] = n[14]),
            (t[e + 15] = n[15]),
            t
          );
        },
      }),
      Object.assign(r, {
        slerp: function (t, e, n, i) {
          return n.copy(t).slerp(e, i);
        },
        slerpFlat: function (t, e, n, i, r, o, a) {
          var s = n[i + 0],
            c = n[i + 1],
            l = n[i + 2],
            u = n[i + 3],
            h = r[o + 0],
            p = r[o + 1],
            d = r[o + 2],
            f = r[o + 3];
          if (u !== f || s !== h || c !== p || l !== d) {
            var m = 1 - a,
              g = s * h + c * p + l * d + u * f,
              v = g >= 0 ? 1 : -1,
              y = 1 - g * g;
            if (y > Number.EPSILON) {
              var x = Math.sqrt(y),
                b = Math.atan2(x, g * v);
              (m = Math.sin(m * b) / x), (a = Math.sin(a * b) / x);
            }
            var _ = a * v;
            if (
              ((s = s * m + h * _),
              (c = c * m + p * _),
              (l = l * m + d * _),
              (u = u * m + f * _),
              m === 1 - a)
            ) {
              var w = 1 / Math.sqrt(s * s + c * c + l * l + u * u);
              (s *= w), (c *= w), (l *= w), (u *= w);
            }
          }
          (t[e] = s), (t[e + 1] = c), (t[e + 2] = l), (t[e + 3] = u);
        },
      }),
      Object.defineProperties(r.prototype, {
        x: {
          get: function () {
            return this._x;
          },
          set: function (t) {
            (this._x = t), this.onChangeCallback();
          },
        },
        y: {
          get: function () {
            return this._y;
          },
          set: function (t) {
            (this._y = t), this.onChangeCallback();
          },
        },
        z: {
          get: function () {
            return this._z;
          },
          set: function (t) {
            (this._z = t), this.onChangeCallback();
          },
        },
        w: {
          get: function () {
            return this._w;
          },
          set: function (t) {
            (this._w = t), this.onChangeCallback();
          },
        },
      }),
      Object.assign(r.prototype, {
        set: function (t, e, n, i) {
          return (
            (this._x = t),
            (this._y = e),
            (this._z = n),
            (this._w = i),
            this.onChangeCallback(),
            this
          );
        },
        clone: function () {
          return new this.constructor(this._x, this._y, this._z, this._w);
        },
        copy: function (t) {
          return (
            (this._x = t.x),
            (this._y = t.y),
            (this._z = t.z),
            (this._w = t.w),
            this.onChangeCallback(),
            this
          );
        },
        setFromEuler: function (t, e) {
          if (!t || !t.isEuler)
            throw new Error(
              "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
            );
          var n = t._x,
            i = t._y,
            r = t._z,
            o = t.order,
            a = Math.cos,
            s = Math.sin,
            c = a(n / 2),
            l = a(i / 2),
            u = a(r / 2),
            h = s(n / 2),
            p = s(i / 2),
            d = s(r / 2);
          return (
            "XYZ" === o
              ? ((this._x = h * l * u + c * p * d),
                (this._y = c * p * u - h * l * d),
                (this._z = c * l * d + h * p * u),
                (this._w = c * l * u - h * p * d))
              : "YXZ" === o
              ? ((this._x = h * l * u + c * p * d),
                (this._y = c * p * u - h * l * d),
                (this._z = c * l * d - h * p * u),
                (this._w = c * l * u + h * p * d))
              : "ZXY" === o
              ? ((this._x = h * l * u - c * p * d),
                (this._y = c * p * u + h * l * d),
                (this._z = c * l * d + h * p * u),
                (this._w = c * l * u - h * p * d))
              : "ZYX" === o
              ? ((this._x = h * l * u - c * p * d),
                (this._y = c * p * u + h * l * d),
                (this._z = c * l * d - h * p * u),
                (this._w = c * l * u + h * p * d))
              : "YZX" === o
              ? ((this._x = h * l * u + c * p * d),
                (this._y = c * p * u + h * l * d),
                (this._z = c * l * d - h * p * u),
                (this._w = c * l * u - h * p * d))
              : "XZY" === o &&
                ((this._x = h * l * u - c * p * d),
                (this._y = c * p * u - h * l * d),
                (this._z = c * l * d + h * p * u),
                (this._w = c * l * u + h * p * d)),
            !1 !== e && this.onChangeCallback(),
            this
          );
        },
        setFromAxisAngle: function (t, e) {
          var n = e / 2,
            i = Math.sin(n);
          return (
            (this._x = t.x * i),
            (this._y = t.y * i),
            (this._z = t.z * i),
            (this._w = Math.cos(n)),
            this.onChangeCallback(),
            this
          );
        },
        setFromRotationMatrix: function (t) {
          var e,
            n = t.elements,
            i = n[0],
            r = n[4],
            o = n[8],
            a = n[1],
            s = n[5],
            c = n[9],
            l = n[2],
            u = n[6],
            h = n[10],
            p = i + s + h;
          return (
            p > 0
              ? ((e = 0.5 / Math.sqrt(p + 1)),
                (this._w = 0.25 / e),
                (this._x = (u - c) * e),
                (this._y = (o - l) * e),
                (this._z = (a - r) * e))
              : i > s && i > h
              ? ((e = 2 * Math.sqrt(1 + i - s - h)),
                (this._w = (u - c) / e),
                (this._x = 0.25 * e),
                (this._y = (r + a) / e),
                (this._z = (o + l) / e))
              : s > h
              ? ((e = 2 * Math.sqrt(1 + s - i - h)),
                (this._w = (o - l) / e),
                (this._x = (r + a) / e),
                (this._y = 0.25 * e),
                (this._z = (c + u) / e))
              : ((e = 2 * Math.sqrt(1 + h - i - s)),
                (this._w = (a - r) / e),
                (this._x = (o + l) / e),
                (this._y = (c + u) / e),
                (this._z = 0.25 * e)),
            this.onChangeCallback(),
            this
          );
        },
        setFromUnitVectors: (function () {
          var t,
            e = new o();
          return function (n, i) {
            return (
              void 0 === e && (e = new o()),
              (t = n.dot(i) + 1) < 1e-6
                ? ((t = 0),
                  Math.abs(n.x) > Math.abs(n.z)
                    ? e.set(-n.y, n.x, 0)
                    : e.set(0, -n.z, n.y))
                : e.crossVectors(n, i),
              (this._x = e.x),
              (this._y = e.y),
              (this._z = e.z),
              (this._w = t),
              this.normalize()
            );
          };
        })(),
        inverse: function () {
          return this.conjugate().normalize();
        },
        conjugate: function () {
          return (
            (this._x *= -1),
            (this._y *= -1),
            (this._z *= -1),
            this.onChangeCallback(),
            this
          );
        },
        dot: function (t) {
          return (
            this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
          );
        },
        lengthSq: function () {
          return (
            this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
          );
        },
        length: function () {
          return Math.sqrt(
            this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
          );
        },
        normalize: function () {
          var t = this.length();
          return (
            0 === t
              ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
              : ((t = 1 / t),
                (this._x = this._x * t),
                (this._y = this._y * t),
                (this._z = this._z * t),
                (this._w = this._w * t)),
            this.onChangeCallback(),
            this
          );
        },
        multiply: function (t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
              ),
              this.multiplyQuaternions(t, e))
            : this.multiplyQuaternions(this, t);
        },
        premultiply: function (t) {
          return this.multiplyQuaternions(t, this);
        },
        multiplyQuaternions: function (t, e) {
          var n = t._x,
            i = t._y,
            r = t._z,
            o = t._w,
            a = e._x,
            s = e._y,
            c = e._z,
            l = e._w;
          return (
            (this._x = n * l + o * a + i * c - r * s),
            (this._y = i * l + o * s + r * a - n * c),
            (this._z = r * l + o * c + n * s - i * a),
            (this._w = o * l - n * a - i * s - r * c),
            this.onChangeCallback(),
            this
          );
        },
        slerp: function (t, e) {
          if (0 === e) return this;
          if (1 === e) return this.copy(t);
          var n = this._x,
            i = this._y,
            r = this._z,
            o = this._w,
            a = o * t._w + n * t._x + i * t._y + r * t._z;
          if (
            (a < 0
              ? ((this._w = -t._w),
                (this._x = -t._x),
                (this._y = -t._y),
                (this._z = -t._z),
                (a = -a))
              : this.copy(t),
            a >= 1)
          )
            return (
              (this._w = o), (this._x = n), (this._y = i), (this._z = r), this
            );
          var s = Math.sqrt(1 - a * a);
          if (Math.abs(s) < 0.001)
            return (
              (this._w = 0.5 * (o + this._w)),
              (this._x = 0.5 * (n + this._x)),
              (this._y = 0.5 * (i + this._y)),
              (this._z = 0.5 * (r + this._z)),
              this
            );
          var c = Math.atan2(s, a),
            l = Math.sin((1 - e) * c) / s,
            u = Math.sin(e * c) / s;
          return (
            (this._w = o * l + this._w * u),
            (this._x = n * l + this._x * u),
            (this._y = i * l + this._y * u),
            (this._z = r * l + this._z * u),
            this.onChangeCallback(),
            this
          );
        },
        equals: function (t) {
          return (
            t._x === this._x &&
            t._y === this._y &&
            t._z === this._z &&
            t._w === this._w
          );
        },
        fromArray: function (t, e) {
          return (
            void 0 === e && (e = 0),
            (this._x = t[e]),
            (this._y = t[e + 1]),
            (this._z = t[e + 2]),
            (this._w = t[e + 3]),
            this.onChangeCallback(),
            this
          );
        },
        toArray: function (t, e) {
          return (
            void 0 === t && (t = []),
            void 0 === e && (e = 0),
            (t[e] = this._x),
            (t[e + 1] = this._y),
            (t[e + 2] = this._z),
            (t[e + 3] = this._w),
            t
          );
        },
        onChange: function (t) {
          return (this.onChangeCallback = t), this;
        },
        onChangeCallback: function () {},
      }),
      Object.assign(o.prototype, {
        isVector3: !0,
        set: function (t, e, n) {
          return (this.x = t), (this.y = e), (this.z = n), this;
        },
        setScalar: function (t) {
          return (this.x = t), (this.y = t), (this.z = t), this;
        },
        setX: function (t) {
          return (this.x = t), this;
        },
        setY: function (t) {
          return (this.y = t), this;
        },
        setZ: function (t) {
          return (this.z = t), this;
        },
        setComponent: function (t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            case 2:
              this.z = e;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        },
        getComponent: function (t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + t);
          }
        },
        clone: function () {
          return new this.constructor(this.x, this.y, this.z);
        },
        copy: function (t) {
          return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
        },
        add: function (t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(t, e))
            : ((this.x += t.x), (this.y += t.y), (this.z += t.z), this);
        },
        addScalar: function (t) {
          return (this.x += t), (this.y += t), (this.z += t), this;
        },
        addVectors: function (t, e) {
          return (
            (this.x = t.x + e.x),
            (this.y = t.y + e.y),
            (this.z = t.z + e.z),
            this
          );
        },
        addScaledVector: function (t, e) {
          return (
            (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this
          );
        },
        sub: function (t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(t, e))
            : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this);
        },
        subScalar: function (t) {
          return (this.x -= t), (this.y -= t), (this.z -= t), this;
        },
        subVectors: function (t, e) {
          return (
            (this.x = t.x - e.x),
            (this.y = t.y - e.y),
            (this.z = t.z - e.z),
            this
          );
        },
        multiply: function (t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
              ),
              this.multiplyVectors(t, e))
            : ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this);
        },
        multiplyScalar: function (t) {
          return (this.x *= t), (this.y *= t), (this.z *= t), this;
        },
        multiplyVectors: function (t, e) {
          return (
            (this.x = t.x * e.x),
            (this.y = t.y * e.y),
            (this.z = t.z * e.z),
            this
          );
        },
        applyEuler: (function () {
          var t = new r();
          return function (e) {
            return (
              (e && e.isEuler) ||
                console.error(
                  "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
                ),
              this.applyQuaternion(t.setFromEuler(e))
            );
          };
        })(),
        applyAxisAngle: (function () {
          var t = new r();
          return function (e, n) {
            return this.applyQuaternion(t.setFromAxisAngle(e, n));
          };
        })(),
        applyMatrix3: function (t) {
          var e = this.x,
            n = this.y,
            i = this.z,
            r = t.elements;
          return (
            (this.x = r[0] * e + r[3] * n + r[6] * i),
            (this.y = r[1] * e + r[4] * n + r[7] * i),
            (this.z = r[2] * e + r[5] * n + r[8] * i),
            this
          );
        },
        applyMatrix4: function (t) {
          var e = this.x,
            n = this.y,
            i = this.z,
            r = t.elements,
            o = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
          return (
            (this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * o),
            (this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * o),
            (this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * o),
            this
          );
        },
        applyQuaternion: function (t) {
          var e = this.x,
            n = this.y,
            i = this.z,
            r = t.x,
            o = t.y,
            a = t.z,
            s = t.w,
            c = s * e + o * i - a * n,
            l = s * n + a * e - r * i,
            u = s * i + r * n - o * e,
            h = -r * e - o * n - a * i;
          return (
            (this.x = c * s + h * -r + l * -a - u * -o),
            (this.y = l * s + h * -o + u * -r - c * -a),
            (this.z = u * s + h * -a + c * -o - l * -r),
            this
          );
        },
        project: (function () {
          var t = new i();
          return function (e) {
            return (
              t.multiplyMatrices(
                e.projectionMatrix,
                t.getInverse(e.matrixWorld)
              ),
              this.applyMatrix4(t)
            );
          };
        })(),
        unproject: (function () {
          var t = new i();
          return function (e) {
            return (
              t.multiplyMatrices(
                e.matrixWorld,
                t.getInverse(e.projectionMatrix)
              ),
              this.applyMatrix4(t)
            );
          };
        })(),
        transformDirection: function (t) {
          var e = this.x,
            n = this.y,
            i = this.z,
            r = t.elements;
          return (
            (this.x = r[0] * e + r[4] * n + r[8] * i),
            (this.y = r[1] * e + r[5] * n + r[9] * i),
            (this.z = r[2] * e + r[6] * n + r[10] * i),
            this.normalize()
          );
        },
        divide: function (t) {
          return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
        },
        divideScalar: function (t) {
          return this.multiplyScalar(1 / t);
        },
        min: function (t) {
          return (
            (this.x = Math.min(this.x, t.x)),
            (this.y = Math.min(this.y, t.y)),
            (this.z = Math.min(this.z, t.z)),
            this
          );
        },
        max: function (t) {
          return (
            (this.x = Math.max(this.x, t.x)),
            (this.y = Math.max(this.y, t.y)),
            (this.z = Math.max(this.z, t.z)),
            this
          );
        },
        clamp: function (t, e) {
          return (
            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
            (this.z = Math.max(t.z, Math.min(e.z, this.z))),
            this
          );
        },
        clampScalar: (function () {
          var t = new o(),
            e = new o();
          return function (n, i) {
            return t.set(n, n, n), e.set(i, i, i), this.clamp(t, e);
          };
        })(),
        clampLength: function (t, e) {
          var n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(t, Math.min(e, n))
          );
        },
        floor: function () {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            this
          );
        },
        ceil: function () {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            this
          );
        },
        round: function () {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            this
          );
        },
        roundToZero: function () {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            this
          );
        },
        negate: function () {
          return (
            (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
          );
        },
        dot: function (t) {
          return this.x * t.x + this.y * t.y + this.z * t.z;
        },
        lengthSq: function () {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        },
        length: function () {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        },
        manhattanLength: function () {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        },
        normalize: function () {
          return this.divideScalar(this.length() || 1);
        },
        setLength: function (t) {
          return this.normalize().multiplyScalar(t);
        },
        lerp: function (t, e) {
          return (
            (this.x += (t.x - this.x) * e),
            (this.y += (t.y - this.y) * e),
            (this.z += (t.z - this.z) * e),
            this
          );
        },
        lerpVectors: function (t, e, n) {
          return this.subVectors(e, t).multiplyScalar(n).add(t);
        },
        cross: function (t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
              ),
              this.crossVectors(t, e))
            : this.crossVectors(this, t);
        },
        crossVectors: function (t, e) {
          var n = t.x,
            i = t.y,
            r = t.z,
            o = e.x,
            a = e.y,
            s = e.z;
          return (
            (this.x = i * s - r * a),
            (this.y = r * o - n * s),
            (this.z = n * a - i * o),
            this
          );
        },
        projectOnVector: function (t) {
          var e = t.dot(this) / t.lengthSq();
          return this.copy(t).multiplyScalar(e);
        },
        projectOnPlane: (function () {
          var t = new o();
          return function (e) {
            return t.copy(this).projectOnVector(e), this.sub(t);
          };
        })(),
        reflect: (function () {
          var t = new o();
          return function (e) {
            return this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)));
          };
        })(),
        angleTo: function (t) {
          var e = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq());
          return Math.acos(sa.clamp(e, -1, 1));
        },
        distanceTo: function (t) {
          return Math.sqrt(this.distanceToSquared(t));
        },
        distanceToSquared: function (t) {
          var e = this.x - t.x,
            n = this.y - t.y,
            i = this.z - t.z;
          return e * e + n * n + i * i;
        },
        manhattanDistanceTo: function (t) {
          return (
            Math.abs(this.x - t.x) +
            Math.abs(this.y - t.y) +
            Math.abs(this.z - t.z)
          );
        },
        setFromSpherical: function (t) {
          var e = Math.sin(t.phi) * t.radius;
          return (
            (this.x = e * Math.sin(t.theta)),
            (this.y = Math.cos(t.phi) * t.radius),
            (this.z = e * Math.cos(t.theta)),
            this
          );
        },
        setFromCylindrical: function (t) {
          return (
            (this.x = t.radius * Math.sin(t.theta)),
            (this.y = t.y),
            (this.z = t.radius * Math.cos(t.theta)),
            this
          );
        },
        setFromMatrixPosition: function (t) {
          var e = t.elements;
          return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
        },
        setFromMatrixScale: function (t) {
          var e = this.setFromMatrixColumn(t, 0).length(),
            n = this.setFromMatrixColumn(t, 1).length(),
            i = this.setFromMatrixColumn(t, 2).length();
          return (this.x = e), (this.y = n), (this.z = i), this;
        },
        setFromMatrixColumn: function (t, e) {
          return this.fromArray(t.elements, 4 * e);
        },
        equals: function (t) {
          return t.x === this.x && t.y === this.y && t.z === this.z;
        },
        fromArray: function (t, e) {
          return (
            void 0 === e && (e = 0),
            (this.x = t[e]),
            (this.y = t[e + 1]),
            (this.z = t[e + 2]),
            this
          );
        },
        toArray: function (t, e) {
          return (
            void 0 === t && (t = []),
            void 0 === e && (e = 0),
            (t[e] = this.x),
            (t[e + 1] = this.y),
            (t[e + 2] = this.z),
            t
          );
        },
        fromBufferAttribute: function (t, e, n) {
          return (
            void 0 !== n &&
              console.warn(
                "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = t.getX(e)),
            (this.y = t.getY(e)),
            (this.z = t.getZ(e)),
            this
          );
        },
      }),
      Object.assign(a.prototype, {
        isMatrix3: !0,
        set: function (t, e, n, i, r, o, a, s, c) {
          var l = this.elements;
          return (
            (l[0] = t),
            (l[1] = i),
            (l[2] = a),
            (l[3] = e),
            (l[4] = r),
            (l[5] = s),
            (l[6] = n),
            (l[7] = o),
            (l[8] = c),
            this
          );
        },
        identity: function () {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        },
        clone: function () {
          return new this.constructor().fromArray(this.elements);
        },
        copy: function (t) {
          var e = this.elements,
            n = t.elements;
          return (
            (e[0] = n[0]),
            (e[1] = n[1]),
            (e[2] = n[2]),
            (e[3] = n[3]),
            (e[4] = n[4]),
            (e[5] = n[5]),
            (e[6] = n[6]),
            (e[7] = n[7]),
            (e[8] = n[8]),
            this
          );
        },
        setFromMatrix4: function (t) {
          var e = t.elements;
          return (
            this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
            this
          );
        },
        applyToBufferAttribute: (function () {
          var t = new o();
          return function (e) {
            for (var n = 0, i = e.count; n < i; n++)
              (t.x = e.getX(n)),
                (t.y = e.getY(n)),
                (t.z = e.getZ(n)),
                t.applyMatrix3(this),
                e.setXYZ(n, t.x, t.y, t.z);
            return e;
          };
        })(),
        multiply: function (t) {
          return this.multiplyMatrices(this, t);
        },
        premultiply: function (t) {
          return this.multiplyMatrices(t, this);
        },
        multiplyMatrices: function (t, e) {
          var n = t.elements,
            i = e.elements,
            r = this.elements,
            o = n[0],
            a = n[3],
            s = n[6],
            c = n[1],
            l = n[4],
            u = n[7],
            h = n[2],
            p = n[5],
            d = n[8],
            f = i[0],
            m = i[3],
            g = i[6],
            v = i[1],
            y = i[4],
            x = i[7],
            b = i[2],
            _ = i[5],
            w = i[8];
          return (
            (r[0] = o * f + a * v + s * b),
            (r[3] = o * m + a * y + s * _),
            (r[6] = o * g + a * x + s * w),
            (r[1] = c * f + l * v + u * b),
            (r[4] = c * m + l * y + u * _),
            (r[7] = c * g + l * x + u * w),
            (r[2] = h * f + p * v + d * b),
            (r[5] = h * m + p * y + d * _),
            (r[8] = h * g + p * x + d * w),
            this
          );
        },
        multiplyScalar: function (t) {
          var e = this.elements;
          return (
            (e[0] *= t),
            (e[3] *= t),
            (e[6] *= t),
            (e[1] *= t),
            (e[4] *= t),
            (e[7] *= t),
            (e[2] *= t),
            (e[5] *= t),
            (e[8] *= t),
            this
          );
        },
        determinant: function () {
          var t = this.elements,
            e = t[0],
            n = t[1],
            i = t[2],
            r = t[3],
            o = t[4],
            a = t[5],
            s = t[6],
            c = t[7],
            l = t[8];
          return (
            e * o * l -
            e * a * c -
            n * r * l +
            n * a * s +
            i * r * c -
            i * o * s
          );
        },
        getInverse: function (t, e) {
          t &&
            t.isMatrix4 &&
            console.error(
              "THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument."
            );
          var n = t.elements,
            i = this.elements,
            r = n[0],
            o = n[1],
            a = n[2],
            s = n[3],
            c = n[4],
            l = n[5],
            u = n[6],
            h = n[7],
            p = n[8],
            d = p * c - l * h,
            f = l * u - p * s,
            m = h * s - c * u,
            g = r * d + o * f + a * m;
          if (0 === g) {
            var v =
              "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
            if (!0 === e) throw new Error(v);
            return console.warn(v), this.identity();
          }
          var y = 1 / g;
          return (
            (i[0] = d * y),
            (i[1] = (a * h - p * o) * y),
            (i[2] = (l * o - a * c) * y),
            (i[3] = f * y),
            (i[4] = (p * r - a * u) * y),
            (i[5] = (a * s - l * r) * y),
            (i[6] = m * y),
            (i[7] = (o * u - h * r) * y),
            (i[8] = (c * r - o * s) * y),
            this
          );
        },
        transpose: function () {
          var t,
            e = this.elements;
          return (
            (t = e[1]),
            (e[1] = e[3]),
            (e[3] = t),
            (t = e[2]),
            (e[2] = e[6]),
            (e[6] = t),
            (t = e[5]),
            (e[5] = e[7]),
            (e[7] = t),
            this
          );
        },
        getNormalMatrix: function (t) {
          return this.setFromMatrix4(t).getInverse(this).transpose();
        },
        transposeIntoArray: function (t) {
          var e = this.elements;
          return (
            (t[0] = e[0]),
            (t[1] = e[3]),
            (t[2] = e[6]),
            (t[3] = e[1]),
            (t[4] = e[4]),
            (t[5] = e[7]),
            (t[6] = e[2]),
            (t[7] = e[5]),
            (t[8] = e[8]),
            this
          );
        },
        setUvTransform: function (t, e, n, i, r, o, a) {
          var s = Math.cos(r),
            c = Math.sin(r);
          this.set(
            n * s,
            n * c,
            -n * (s * o + c * a) + o + t,
            -i * c,
            i * s,
            -i * (-c * o + s * a) + a + e,
            0,
            0,
            1
          );
        },
        scale: function (t, e) {
          var n = this.elements;
          return (
            (n[0] *= t),
            (n[3] *= t),
            (n[6] *= t),
            (n[1] *= e),
            (n[4] *= e),
            (n[7] *= e),
            this
          );
        },
        rotate: function (t) {
          var e = Math.cos(t),
            n = Math.sin(t),
            i = this.elements,
            r = i[0],
            o = i[3],
            a = i[6],
            s = i[1],
            c = i[4],
            l = i[7];
          return (
            (i[0] = e * r + n * s),
            (i[3] = e * o + n * c),
            (i[6] = e * a + n * l),
            (i[1] = -n * r + e * s),
            (i[4] = -n * o + e * c),
            (i[7] = -n * a + e * l),
            this
          );
        },
        translate: function (t, e) {
          var n = this.elements;
          return (
            (n[0] += t * n[2]),
            (n[3] += t * n[5]),
            (n[6] += t * n[8]),
            (n[1] += e * n[2]),
            (n[4] += e * n[5]),
            (n[7] += e * n[8]),
            this
          );
        },
        equals: function (t) {
          for (var e = this.elements, n = t.elements, i = 0; i < 9; i++)
            if (e[i] !== n[i]) return !1;
          return !0;
        },
        fromArray: function (t, e) {
          void 0 === e && (e = 0);
          for (var n = 0; n < 9; n++) this.elements[n] = t[n + e];
          return this;
        },
        toArray: function (t, e) {
          void 0 === t && (t = []), void 0 === e && (e = 0);
          var n = this.elements;
          return (
            (t[e] = n[0]),
            (t[e + 1] = n[1]),
            (t[e + 2] = n[2]),
            (t[e + 3] = n[3]),
            (t[e + 4] = n[4]),
            (t[e + 5] = n[5]),
            (t[e + 6] = n[6]),
            (t[e + 7] = n[7]),
            (t[e + 8] = n[8]),
            t
          );
        },
      });
    var ca = 0;
    (s.DEFAULT_IMAGE = void 0),
      (s.DEFAULT_MAPPING = 300),
      Object.defineProperty(s.prototype, "needsUpdate", {
        set: function (t) {
          !0 === t && this.version++;
        },
      }),
      Object.assign(s.prototype, e.prototype, {
        constructor: s,
        isTexture: !0,
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          return (
            (this.name = t.name),
            (this.image = t.image),
            (this.mipmaps = t.mipmaps.slice(0)),
            (this.mapping = t.mapping),
            (this.wrapS = t.wrapS),
            (this.wrapT = t.wrapT),
            (this.magFilter = t.magFilter),
            (this.minFilter = t.minFilter),
            (this.anisotropy = t.anisotropy),
            (this.format = t.format),
            (this.type = t.type),
            this.offset.copy(t.offset),
            this.repeat.copy(t.repeat),
            this.center.copy(t.center),
            (this.rotation = t.rotation),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            this.matrix.copy(t.matrix),
            (this.generateMipmaps = t.generateMipmaps),
            (this.premultiplyAlpha = t.premultiplyAlpha),
            (this.flipY = t.flipY),
            (this.unpackAlignment = t.unpackAlignment),
            (this.encoding = t.encoding),
            this
          );
        },
        toJSON: function (t) {
          var e = void 0 === t || "string" == typeof t;
          if (!e && void 0 !== t.textures[this.uuid])
            return t.textures[this.uuid];
          var n = {
            metadata: {
              version: 4.5,
              type: "Texture",
              generator: "Texture.toJSON",
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
          };
          if (void 0 !== this.image) {
            var i = this.image;
            void 0 === i.uuid && (i.uuid = sa.generateUUID()),
              e ||
                void 0 !== t.images[i.uuid] ||
                (t.images[i.uuid] = {
                  uuid: i.uuid,
                  url: (function (t) {
                    var e;
                    if (t instanceof HTMLCanvasElement) e = t;
                    else {
                      ((e = document.createElementNS(
                        "http://www.w3.org/1999/xhtml",
                        "canvas"
                      )).width = t.width),
                        (e.height = t.height);
                      var n = e.getContext("2d");
                      t instanceof ImageData
                        ? n.putImageData(t, 0, 0)
                        : n.drawImage(t, 0, 0, t.width, t.height);
                    }
                    return e.width > 2048 || e.height > 2048
                      ? e.toDataURL("image/jpeg", 0.6)
                      : e.toDataURL("image/png");
                  })(i),
                }),
              (n.image = i.uuid);
          }
          return e || (t.textures[this.uuid] = n), n;
        },
        dispose: function () {
          this.dispatchEvent({ type: "dispose" });
        },
        transformUv: function (t) {
          if (300 === this.mapping) {
            if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
              switch (this.wrapS) {
                case lo:
                  t.x = t.x - Math.floor(t.x);
                  break;
                case uo:
                  t.x = t.x < 0 ? 0 : 1;
                  break;
                case ho:
                  1 === Math.abs(Math.floor(t.x) % 2)
                    ? (t.x = Math.ceil(t.x) - t.x)
                    : (t.x = t.x - Math.floor(t.x));
              }
            if (t.y < 0 || t.y > 1)
              switch (this.wrapT) {
                case lo:
                  t.y = t.y - Math.floor(t.y);
                  break;
                case uo:
                  t.y = t.y < 0 ? 0 : 1;
                  break;
                case ho:
                  1 === Math.abs(Math.floor(t.y) % 2)
                    ? (t.y = Math.ceil(t.y) - t.y)
                    : (t.y = t.y - Math.floor(t.y));
              }
            this.flipY && (t.y = 1 - t.y);
          }
        },
      }),
      Object.assign(c.prototype, {
        isVector4: !0,
        set: function (t, e, n, i) {
          return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this;
        },
        setScalar: function (t) {
          return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
        },
        setX: function (t) {
          return (this.x = t), this;
        },
        setY: function (t) {
          return (this.y = t), this;
        },
        setZ: function (t) {
          return (this.z = t), this;
        },
        setW: function (t) {
          return (this.w = t), this;
        },
        setComponent: function (t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            case 2:
              this.z = e;
              break;
            case 3:
              this.w = e;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        },
        getComponent: function (t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + t);
          }
        },
        clone: function () {
          return new this.constructor(this.x, this.y, this.z, this.w);
        },
        copy: function (t) {
          return (
            (this.x = t.x),
            (this.y = t.y),
            (this.z = t.z),
            (this.w = void 0 !== t.w ? t.w : 1),
            this
          );
        },
        add: function (t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
              this.addVectors(t, e))
            : ((this.x += t.x),
              (this.y += t.y),
              (this.z += t.z),
              (this.w += t.w),
              this);
        },
        addScalar: function (t) {
          return (
            (this.x += t), (this.y += t), (this.z += t), (this.w += t), this
          );
        },
        addVectors: function (t, e) {
          return (
            (this.x = t.x + e.x),
            (this.y = t.y + e.y),
            (this.z = t.z + e.z),
            (this.w = t.w + e.w),
            this
          );
        },
        addScaledVector: function (t, e) {
          return (
            (this.x += t.x * e),
            (this.y += t.y * e),
            (this.z += t.z * e),
            (this.w += t.w * e),
            this
          );
        },
        sub: function (t, e) {
          return void 0 !== e
            ? (console.warn(
                "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
              this.subVectors(t, e))
            : ((this.x -= t.x),
              (this.y -= t.y),
              (this.z -= t.z),
              (this.w -= t.w),
              this);
        },
        subScalar: function (t) {
          return (
            (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this
          );
        },
        subVectors: function (t, e) {
          return (
            (this.x = t.x - e.x),
            (this.y = t.y - e.y),
            (this.z = t.z - e.z),
            (this.w = t.w - e.w),
            this
          );
        },
        multiplyScalar: function (t) {
          return (
            (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this
          );
        },
        applyMatrix4: function (t) {
          var e = this.x,
            n = this.y,
            i = this.z,
            r = this.w,
            o = t.elements;
          return (
            (this.x = o[0] * e + o[4] * n + o[8] * i + o[12] * r),
            (this.y = o[1] * e + o[5] * n + o[9] * i + o[13] * r),
            (this.z = o[2] * e + o[6] * n + o[10] * i + o[14] * r),
            (this.w = o[3] * e + o[7] * n + o[11] * i + o[15] * r),
            this
          );
        },
        divideScalar: function (t) {
          return this.multiplyScalar(1 / t);
        },
        setAxisAngleFromQuaternion: function (t) {
          this.w = 2 * Math.acos(t.w);
          var e = Math.sqrt(1 - t.w * t.w);
          return (
            e < 1e-4
              ? ((this.x = 1), (this.y = 0), (this.z = 0))
              : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
            this
          );
        },
        setAxisAngleFromRotationMatrix: function (t) {
          var e,
            n,
            i,
            r,
            o = t.elements,
            a = o[0],
            s = o[4],
            c = o[8],
            l = o[1],
            u = o[5],
            h = o[9],
            p = o[2],
            d = o[6],
            f = o[10];
          if (
            Math.abs(s - l) < 0.01 &&
            Math.abs(c - p) < 0.01 &&
            Math.abs(h - d) < 0.01
          ) {
            if (
              Math.abs(s + l) < 0.1 &&
              Math.abs(c + p) < 0.1 &&
              Math.abs(h + d) < 0.1 &&
              Math.abs(a + u + f - 3) < 0.1
            )
              return this.set(1, 0, 0, 0), this;
            e = Math.PI;
            var m = (a + 1) / 2,
              g = (u + 1) / 2,
              v = (f + 1) / 2,
              y = (s + l) / 4,
              x = (c + p) / 4,
              b = (h + d) / 4;
            return (
              m > g && m > v
                ? m < 0.01
                  ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
                  : ((i = y / (n = Math.sqrt(m))), (r = x / n))
                : g > v
                ? g < 0.01
                  ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
                  : ((n = y / (i = Math.sqrt(g))), (r = b / i))
                : v < 0.01
                ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
                : ((n = x / (r = Math.sqrt(v))), (i = b / r)),
              this.set(n, i, r, e),
              this
            );
          }
          var _ = Math.sqrt(
            (d - h) * (d - h) + (c - p) * (c - p) + (l - s) * (l - s)
          );
          return (
            Math.abs(_) < 0.001 && (_ = 1),
            (this.x = (d - h) / _),
            (this.y = (c - p) / _),
            (this.z = (l - s) / _),
            (this.w = Math.acos((a + u + f - 1) / 2)),
            this
          );
        },
        min: function (t) {
          return (
            (this.x = Math.min(this.x, t.x)),
            (this.y = Math.min(this.y, t.y)),
            (this.z = Math.min(this.z, t.z)),
            (this.w = Math.min(this.w, t.w)),
            this
          );
        },
        max: function (t) {
          return (
            (this.x = Math.max(this.x, t.x)),
            (this.y = Math.max(this.y, t.y)),
            (this.z = Math.max(this.z, t.z)),
            (this.w = Math.max(this.w, t.w)),
            this
          );
        },
        clamp: function (t, e) {
          return (
            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
            (this.z = Math.max(t.z, Math.min(e.z, this.z))),
            (this.w = Math.max(t.w, Math.min(e.w, this.w))),
            this
          );
        },
        clampScalar: (function () {
          var t, e;
          return function (n, i) {
            return (
              void 0 === t && ((t = new c()), (e = new c())),
              t.set(n, n, n, n),
              e.set(i, i, i, i),
              this.clamp(t, e)
            );
          };
        })(),
        clampLength: function (t, e) {
          var n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(t, Math.min(e, n))
          );
        },
        floor: function () {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            (this.w = Math.floor(this.w)),
            this
          );
        },
        ceil: function () {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            (this.w = Math.ceil(this.w)),
            this
          );
        },
        round: function () {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            (this.w = Math.round(this.w)),
            this
          );
        },
        roundToZero: function () {
          return (
            (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
            (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
            (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
            (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
            this
          );
        },
        negate: function () {
          return (
            (this.x = -this.x),
            (this.y = -this.y),
            (this.z = -this.z),
            (this.w = -this.w),
            this
          );
        },
        dot: function (t) {
          return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
        },
        lengthSq: function () {
          return (
            this.x * this.x +
            this.y * this.y +
            this.z * this.z +
            this.w * this.w
          );
        },
        length: function () {
          return Math.sqrt(
            this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
          );
        },
        manhattanLength: function () {
          return (
            Math.abs(this.x) +
            Math.abs(this.y) +
            Math.abs(this.z) +
            Math.abs(this.w)
          );
        },
        normalize: function () {
          return this.divideScalar(this.length() || 1);
        },
        setLength: function (t) {
          return this.normalize().multiplyScalar(t);
        },
        lerp: function (t, e) {
          return (
            (this.x += (t.x - this.x) * e),
            (this.y += (t.y - this.y) * e),
            (this.z += (t.z - this.z) * e),
            (this.w += (t.w - this.w) * e),
            this
          );
        },
        lerpVectors: function (t, e, n) {
          return this.subVectors(e, t).multiplyScalar(n).add(t);
        },
        equals: function (t) {
          return (
            t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
          );
        },
        fromArray: function (t, e) {
          return (
            void 0 === e && (e = 0),
            (this.x = t[e]),
            (this.y = t[e + 1]),
            (this.z = t[e + 2]),
            (this.w = t[e + 3]),
            this
          );
        },
        toArray: function (t, e) {
          return (
            void 0 === t && (t = []),
            void 0 === e && (e = 0),
            (t[e] = this.x),
            (t[e + 1] = this.y),
            (t[e + 2] = this.z),
            (t[e + 3] = this.w),
            t
          );
        },
        fromBufferAttribute: function (t, e, n) {
          return (
            void 0 !== n &&
              console.warn(
                "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
              ),
            (this.x = t.getX(e)),
            (this.y = t.getY(e)),
            (this.z = t.getZ(e)),
            (this.w = t.getW(e)),
            this
          );
        },
      }),
      Object.assign(l.prototype, e.prototype, {
        isWebGLRenderTarget: !0,
        setSize: function (t, e) {
          (this.width === t && this.height === e) ||
            ((this.width = t), (this.height = e), this.dispose()),
            this.viewport.set(0, 0, t, e),
            this.scissor.set(0, 0, t, e);
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          return (
            (this.width = t.width),
            (this.height = t.height),
            this.viewport.copy(t.viewport),
            (this.texture = t.texture.clone()),
            (this.depthBuffer = t.depthBuffer),
            (this.stencilBuffer = t.stencilBuffer),
            (this.depthTexture = t.depthTexture),
            this
          );
        },
        dispose: function () {
          this.dispatchEvent({ type: "dispose" });
        },
      }),
      ((u.prototype = Object.create(l.prototype)).constructor = u),
      (u.prototype.isWebGLRenderTargetCube = !0),
      ((h.prototype = Object.create(s.prototype)).constructor = h),
      (h.prototype.isDataTexture = !0),
      ((p.prototype = Object.create(s.prototype)).constructor = p),
      (p.prototype.isCubeTexture = !0),
      Object.defineProperty(p.prototype, "images", {
        get: function () {
          return this.image;
        },
        set: function (t) {
          this.image = t;
        },
      });
    var la = new s(),
      ua = new p(),
      ha = [],
      pa = [],
      da = new Float32Array(16),
      fa = new Float32Array(9);
    H.prototype.setValue = function (t, e) {
      for (var n = this.seq, i = 0, r = n.length; i !== r; ++i) {
        var o = n[i];
        o.setValue(t, e[o.id]);
      }
    };
    var ma = /([\w\d_]+)(\])?(\[|\.)?/g;
    (V.prototype.setValue = function (t, e, n) {
      var i = this.map[e];
      void 0 !== i && i.setValue(t, n, this.renderer);
    }),
      (V.prototype.setOptional = function (t, e, n) {
        var i = e[n];
        void 0 !== i && this.setValue(t, n, i);
      }),
      (V.upload = function (t, e, n, i) {
        for (var r = 0, o = e.length; r !== o; ++r) {
          var a = e[r],
            s = n[a.id];
          !1 !== s.needsUpdate && a.setValue(t, s.value, i);
        }
      }),
      (V.seqWithValue = function (t, e) {
        for (var n = [], i = 0, r = t.length; i !== r; ++i) {
          var o = t[i];
          o.id in e && n.push(o);
        }
        return n;
      });
    var ga = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074,
    };
    Object.assign(W.prototype, {
      isColor: !0,
      r: 1,
      g: 1,
      b: 1,
      set: function (t) {
        return (
          t && t.isColor
            ? this.copy(t)
            : "number" == typeof t
            ? this.setHex(t)
            : "string" == typeof t && this.setStyle(t),
          this
        );
      },
      setScalar: function (t) {
        return (this.r = t), (this.g = t), (this.b = t), this;
      },
      setHex: function (t) {
        return (
          (t = Math.floor(t)),
          (this.r = ((t >> 16) & 255) / 255),
          (this.g = ((t >> 8) & 255) / 255),
          (this.b = (255 & t) / 255),
          this
        );
      },
      setRGB: function (t, e, n) {
        return (this.r = t), (this.g = e), (this.b = n), this;
      },
      setHSL: (function () {
        function t(t, e, n) {
          return (
            n < 0 && (n += 1),
            n > 1 && (n -= 1),
            n < 1 / 6
              ? t + 6 * (e - t) * n
              : n < 0.5
              ? e
              : n < 2 / 3
              ? t + 6 * (e - t) * (2 / 3 - n)
              : t
          );
        }
        return function (e, n, i) {
          if (
            ((e = sa.euclideanModulo(e, 1)),
            (n = sa.clamp(n, 0, 1)),
            (i = sa.clamp(i, 0, 1)),
            0 === n)
          )
            this.r = this.g = this.b = i;
          else {
            var r = i <= 0.5 ? i * (1 + n) : i + n - i * n,
              o = 2 * i - r;
            (this.r = t(o, r, e + 1 / 3)),
              (this.g = t(o, r, e)),
              (this.b = t(o, r, e - 1 / 3));
          }
          return this;
        };
      })(),
      setStyle: function (t) {
        function e(e) {
          void 0 !== e &&
            parseFloat(e) < 1 &&
            console.warn(
              "THREE.Color: Alpha component of " + t + " will be ignored."
            );
        }
        var n;
        if ((n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t))) {
          var i,
            r = n[1],
            o = n[2];
          switch (r) {
            case "rgb":
            case "rgba":
              if (
                (i =
                  /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                    o
                  ))
              )
                return (
                  (this.r = Math.min(255, parseInt(i[1], 10)) / 255),
                  (this.g = Math.min(255, parseInt(i[2], 10)) / 255),
                  (this.b = Math.min(255, parseInt(i[3], 10)) / 255),
                  e(i[5]),
                  this
                );
              if (
                (i =
                  /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                    o
                  ))
              )
                return (
                  (this.r = Math.min(100, parseInt(i[1], 10)) / 100),
                  (this.g = Math.min(100, parseInt(i[2], 10)) / 100),
                  (this.b = Math.min(100, parseInt(i[3], 10)) / 100),
                  e(i[5]),
                  this
                );
              break;
            case "hsl":
            case "hsla":
              if (
                (i =
                  /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                    o
                  ))
              ) {
                var a = parseFloat(i[1]) / 360,
                  s = parseInt(i[2], 10) / 100,
                  c = parseInt(i[3], 10) / 100;
                return e(i[5]), this.setHSL(a, s, c);
              }
          }
        } else if ((n = /^\#([A-Fa-f0-9]+)$/.exec(t))) {
          var l = (u = n[1]).length;
          if (3 === l)
            return (
              (this.r = parseInt(u.charAt(0) + u.charAt(0), 16) / 255),
              (this.g = parseInt(u.charAt(1) + u.charAt(1), 16) / 255),
              (this.b = parseInt(u.charAt(2) + u.charAt(2), 16) / 255),
              this
            );
          if (6 === l)
            return (
              (this.r = parseInt(u.charAt(0) + u.charAt(1), 16) / 255),
              (this.g = parseInt(u.charAt(2) + u.charAt(3), 16) / 255),
              (this.b = parseInt(u.charAt(4) + u.charAt(5), 16) / 255),
              this
            );
        }
        if (t && t.length > 0) {
          var u = ga[t];
          void 0 !== u
            ? this.setHex(u)
            : console.warn("THREE.Color: Unknown color " + t);
        }
        return this;
      },
      clone: function () {
        return new this.constructor(this.r, this.g, this.b);
      },
      copy: function (t) {
        return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
      },
      copyGammaToLinear: function (t, e) {
        return (
          void 0 === e && (e = 2),
          (this.r = Math.pow(t.r, e)),
          (this.g = Math.pow(t.g, e)),
          (this.b = Math.pow(t.b, e)),
          this
        );
      },
      copyLinearToGamma: function (t, e) {
        void 0 === e && (e = 2);
        var n = e > 0 ? 1 / e : 1;
        return (
          (this.r = Math.pow(t.r, n)),
          (this.g = Math.pow(t.g, n)),
          (this.b = Math.pow(t.b, n)),
          this
        );
      },
      convertGammaToLinear: function () {
        var t = this.r,
          e = this.g,
          n = this.b;
        return (this.r = t * t), (this.g = e * e), (this.b = n * n), this;
      },
      convertLinearToGamma: function () {
        return (
          (this.r = Math.sqrt(this.r)),
          (this.g = Math.sqrt(this.g)),
          (this.b = Math.sqrt(this.b)),
          this
        );
      },
      getHex: function () {
        return (
          ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ ((255 * this.b) << 0)
        );
      },
      getHexString: function () {
        return ("000000" + this.getHex().toString(16)).slice(-6);
      },
      getHSL: function (t) {
        var e,
          n,
          i = t || { h: 0, s: 0, l: 0 },
          r = this.r,
          o = this.g,
          a = this.b,
          s = Math.max(r, o, a),
          c = Math.min(r, o, a),
          l = (c + s) / 2;
        if (c === s) (e = 0), (n = 0);
        else {
          var u = s - c;
          switch (((n = l <= 0.5 ? u / (s + c) : u / (2 - s - c)), s)) {
            case r:
              e = (o - a) / u + (o < a ? 6 : 0);
              break;
            case o:
              e = (a - r) / u + 2;
              break;
            case a:
              e = (r - o) / u + 4;
          }
          e /= 6;
        }
        return (i.h = e), (i.s = n), (i.l = l), i;
      },
      getStyle: function () {
        return (
          "rgb(" +
          ((255 * this.r) | 0) +
          "," +
          ((255 * this.g) | 0) +
          "," +
          ((255 * this.b) | 0) +
          ")"
        );
      },
      offsetHSL: function (t, e, n) {
        var i = this.getHSL();
        return (
          (i.h += t), (i.s += e), (i.l += n), this.setHSL(i.h, i.s, i.l), this
        );
      },
      add: function (t) {
        return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
      },
      addColors: function (t, e) {
        return (
          (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this
        );
      },
      addScalar: function (t) {
        return (this.r += t), (this.g += t), (this.b += t), this;
      },
      sub: function (t) {
        return (
          (this.r = Math.max(0, this.r - t.r)),
          (this.g = Math.max(0, this.g - t.g)),
          (this.b = Math.max(0, this.b - t.b)),
          this
        );
      },
      multiply: function (t) {
        return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
      },
      multiplyScalar: function (t) {
        return (this.r *= t), (this.g *= t), (this.b *= t), this;
      },
      lerp: function (t, e) {
        return (
          (this.r += (t.r - this.r) * e),
          (this.g += (t.g - this.g) * e),
          (this.b += (t.b - this.b) * e),
          this
        );
      },
      equals: function (t) {
        return t.r === this.r && t.g === this.g && t.b === this.b;
      },
      fromArray: function (t, e) {
        return (
          void 0 === e && (e = 0),
          (this.r = t[e]),
          (this.g = t[e + 1]),
          (this.b = t[e + 2]),
          this
        );
      },
      toArray: function (t, e) {
        return (
          void 0 === t && (t = []),
          void 0 === e && (e = 0),
          (t[e] = this.r),
          (t[e + 1] = this.g),
          (t[e + 2] = this.b),
          t
        );
      },
      toJSON: function () {
        return this.getHex();
      },
    });
    var va = {
        common: {
          diffuse: { value: new W(15658734) },
          opacity: { value: 1 },
          map: { value: null },
          uvTransform: { value: new a() },
          alphaMap: { value: null },
        },
        specularmap: { specularMap: { value: null } },
        envmap: {
          envMap: { value: null },
          flipEnvMap: { value: -1 },
          reflectivity: { value: 1 },
          refractionRatio: { value: 0.98 },
        },
        aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
        lightmap: {
          lightMap: { value: null },
          lightMapIntensity: { value: 1 },
        },
        emissivemap: { emissiveMap: { value: null } },
        bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
        normalmap: {
          normalMap: { value: null },
          normalScale: { value: new n(1, 1) },
        },
        displacementmap: {
          displacementMap: { value: null },
          displacementScale: { value: 1 },
          displacementBias: { value: 0 },
        },
        roughnessmap: { roughnessMap: { value: null } },
        metalnessmap: { metalnessMap: { value: null } },
        gradientmap: { gradientMap: { value: null } },
        fog: {
          fogDensity: { value: 25e-5 },
          fogNear: { value: 1 },
          fogFar: { value: 2e3 },
          fogColor: { value: new W(16777215) },
        },
        lights: {
          ambientLightColor: { value: [] },
          directionalLights: {
            value: [],
            properties: {
              direction: {},
              color: {},
              shadow: {},
              shadowBias: {},
              shadowRadius: {},
              shadowMapSize: {},
            },
          },
          directionalShadowMap: { value: [] },
          directionalShadowMatrix: { value: [] },
          spotLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              direction: {},
              distance: {},
              coneCos: {},
              penumbraCos: {},
              decay: {},
              shadow: {},
              shadowBias: {},
              shadowRadius: {},
              shadowMapSize: {},
            },
          },
          spotShadowMap: { value: [] },
          spotShadowMatrix: { value: [] },
          pointLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              decay: {},
              distance: {},
              shadow: {},
              shadowBias: {},
              shadowRadius: {},
              shadowMapSize: {},
              shadowCameraNear: {},
              shadowCameraFar: {},
            },
          },
          pointShadowMap: { value: [] },
          pointShadowMatrix: { value: [] },
          hemisphereLights: {
            value: [],
            properties: { direction: {}, skyColor: {}, groundColor: {} },
          },
          rectAreaLights: {
            value: [],
            properties: { color: {}, position: {}, width: {}, height: {} },
          },
        },
        points: {
          diffuse: { value: new W(15658734) },
          opacity: { value: 1 },
          size: { value: 1 },
          scale: { value: 1 },
          map: { value: null },
          uvTransform: { value: new a() },
        },
      },
      ya = {
        merge: function (t) {
          for (var e = {}, n = 0; n < t.length; n++) {
            var i = this.clone(t[n]);
            for (var r in i) e[r] = i[r];
          }
          return e;
        },
        clone: function (t) {
          var e = {};
          for (var n in t) {
            e[n] = {};
            for (var i in t[n]) {
              var r = t[n][i];
              r &&
              (r.isColor ||
                r.isMatrix3 ||
                r.isMatrix4 ||
                r.isVector2 ||
                r.isVector3 ||
                r.isVector4 ||
                r.isTexture)
                ? (e[n][i] = r.clone())
                : Array.isArray(r)
                ? (e[n][i] = r.slice())
                : (e[n][i] = r);
            }
          }
          return e;
        },
      },
      xa = {
        alphamap_fragment:
          "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
        alphamap_pars_fragment:
          "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
        alphatest_fragment:
          "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
        aomap_fragment:
          "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
        aomap_pars_fragment:
          "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        begin_vertex: "\nvec3 transformed = vec3( position );\n",
        beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n",
        bsdfs:
          "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\n\tfloat b = 3.45068 + (4.18814 + y) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\n\treturn result;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
        bumpmap_pars_fragment:
          "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
        clipping_planes_fragment:
          "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n",
        clipping_planes_pars_fragment:
          "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
        clipping_planes_pars_vertex:
          "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n",
        clipping_planes_vertex:
          "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
        color_fragment:
          "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment:
          "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
        color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
        common:
          "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n",
        cube_uv_reflection_fragment:
          "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
        defaultnormal_vertex:
          "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n",
        displacementmap_pars_vertex:
          "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
        displacementmap_vertex:
          "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
        emissivemap_fragment:
          "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
        emissivemap_pars_fragment:
          "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
        encodings_fragment:
          "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
        encodings_pars_fragment:
          "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n",
        envmap_fragment:
          "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
        envmap_pars_fragment:
          "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
        envmap_pars_vertex:
          "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",
        envmap_vertex:
          "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
        fog_vertex: "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n",
        fog_fragment:
          "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
        fog_pars_fragment:
          "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",
        gradientmap_pars_fragment:
          "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n",
        lightmap_fragment:
          "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
        lightmap_pars_fragment:
          "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_vertex:
          "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
        lights_pars:
          "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
        lights_phong_fragment:
          "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
        lights_phong_pars_fragment:
          "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
        lights_physical_fragment:
          "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
        lights_physical_pars_fragment:
          "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
        lights_template:
          "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
        logdepthbuf_fragment:
          "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment:
          "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n",
        logdepthbuf_pars_vertex:
          "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif",
        logdepthbuf_vertex:
          "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n",
        map_fragment:
          "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",
        map_particle_fragment:
          "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
        map_particle_pars_fragment:
          "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n",
        metalnessmap_fragment:
          "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n",
        metalnessmap_pars_fragment:
          "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphnormal_vertex:
          "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
        morphtarget_pars_vertex:
          "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
        morphtarget_vertex:
          "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
        normal_fragment:
          "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
        normalmap_pars_fragment:
          "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n",
        packing:
          "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
        premultiplied_alpha_fragment:
          "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
        project_vertex:
          "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n",
        dithering_fragment:
          "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",
        dithering_pars_fragment:
          "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n",
        roughnessmap_fragment:
          "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n",
        roughnessmap_pars_fragment:
          "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment:
          "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
        shadowmap_pars_vertex:
          "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
        shadowmap_vertex:
          "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
        shadowmask_pars_fragment:
          "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
        skinbase_vertex:
          "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex:
          "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
        skinning_vertex:
          "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n",
        skinnormal_vertex:
          "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
        specularmap_fragment:
          "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment:
          "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment:
          "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
        tonemapping_pars_fragment:
          "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
        uv_pars_fragment:
          "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
        uv_pars_vertex:
          "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n",
        uv_vertex:
          "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
        uv2_pars_fragment:
          "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        uv2_pars_vertex:
          "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
        uv2_vertex:
          "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
        worldpos_vertex:
          "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n",
        cube_frag:
          "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",
        cube_vert:
          "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n",
        depth_frag:
          "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
        depth_vert:
          "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
        distanceRGBA_frag:
          "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n",
        distanceRGBA_vert:
          "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n",
        equirect_frag:
          "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
        equirect_vert:
          "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
        linedashed_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        linedashed_vert:
          "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
        meshbasic_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        meshbasic_vert:
          "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",
        meshlambert_frag:
          "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
        meshlambert_vert:
          "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        meshphong_frag:
          "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
        meshphong_vert:
          "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        meshphysical_frag:
          "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
        meshphysical_vert:
          "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        normal_frag:
          "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
        normal_vert:
          "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",
        points_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        points_vert:
          "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        shadow_frag:
          "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n",
        shadow_vert:
          "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
      },
      ba = {
        basic: {
          uniforms: ya.merge([
            va.common,
            va.specularmap,
            va.envmap,
            va.aomap,
            va.lightmap,
            va.fog,
          ]),
          vertexShader: xa.meshbasic_vert,
          fragmentShader: xa.meshbasic_frag,
        },
        lambert: {
          uniforms: ya.merge([
            va.common,
            va.specularmap,
            va.envmap,
            va.aomap,
            va.lightmap,
            va.emissivemap,
            va.fog,
            va.lights,
            { emissive: { value: new W(0) } },
          ]),
          vertexShader: xa.meshlambert_vert,
          fragmentShader: xa.meshlambert_frag,
        },
        phong: {
          uniforms: ya.merge([
            va.common,
            va.specularmap,
            va.envmap,
            va.aomap,
            va.lightmap,
            va.emissivemap,
            va.bumpmap,
            va.normalmap,
            va.displacementmap,
            va.gradientmap,
            va.fog,
            va.lights,
            {
              emissive: { value: new W(0) },
              specular: { value: new W(1118481) },
              shininess: { value: 30 },
            },
          ]),
          vertexShader: xa.meshphong_vert,
          fragmentShader: xa.meshphong_frag,
        },
        standard: {
          uniforms: ya.merge([
            va.common,
            va.envmap,
            va.aomap,
            va.lightmap,
            va.emissivemap,
            va.bumpmap,
            va.normalmap,
            va.displacementmap,
            va.roughnessmap,
            va.metalnessmap,
            va.fog,
            va.lights,
            {
              emissive: { value: new W(0) },
              roughness: { value: 0.5 },
              metalness: { value: 0.5 },
              envMapIntensity: { value: 1 },
            },
          ]),
          vertexShader: xa.meshphysical_vert,
          fragmentShader: xa.meshphysical_frag,
        },
        points: {
          uniforms: ya.merge([va.points, va.fog]),
          vertexShader: xa.points_vert,
          fragmentShader: xa.points_frag,
        },
        dashed: {
          uniforms: ya.merge([
            va.common,
            va.fog,
            {
              scale: { value: 1 },
              dashSize: { value: 1 },
              totalSize: { value: 2 },
            },
          ]),
          vertexShader: xa.linedashed_vert,
          fragmentShader: xa.linedashed_frag,
        },
        depth: {
          uniforms: ya.merge([va.common, va.displacementmap]),
          vertexShader: xa.depth_vert,
          fragmentShader: xa.depth_frag,
        },
        normal: {
          uniforms: ya.merge([
            va.common,
            va.bumpmap,
            va.normalmap,
            va.displacementmap,
            { opacity: { value: 1 } },
          ]),
          vertexShader: xa.normal_vert,
          fragmentShader: xa.normal_frag,
        },
        cube: {
          uniforms: {
            tCube: { value: null },
            tFlip: { value: -1 },
            opacity: { value: 1 },
          },
          vertexShader: xa.cube_vert,
          fragmentShader: xa.cube_frag,
        },
        equirect: {
          uniforms: { tEquirect: { value: null } },
          vertexShader: xa.equirect_vert,
          fragmentShader: xa.equirect_frag,
        },
        distanceRGBA: {
          uniforms: ya.merge([
            va.common,
            va.displacementmap,
            {
              referencePosition: { value: new o() },
              nearDistance: { value: 1 },
              farDistance: { value: 1e3 },
            },
          ]),
          vertexShader: xa.distanceRGBA_vert,
          fragmentShader: xa.distanceRGBA_frag,
        },
        shadow: {
          uniforms: ya.merge([
            va.lights,
            va.fog,
            { color: { value: new W(0) }, opacity: { value: 1 } },
          ]),
          vertexShader: xa.shadow_vert,
          fragmentShader: xa.shadow_frag,
        },
      };
    (ba.physical = {
      uniforms: ya.merge([
        ba.standard.uniforms,
        { clearCoat: { value: 0 }, clearCoatRoughness: { value: 0 } },
      ]),
      vertexShader: xa.meshphysical_vert,
      fragmentShader: xa.meshphysical_frag,
    }),
      Object.assign(X.prototype, {
        set: function (t, e) {
          return this.min.copy(t), this.max.copy(e), this;
        },
        setFromPoints: function (t) {
          this.makeEmpty();
          for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
          return this;
        },
        setFromCenterAndSize: (function () {
          var t = new n();
          return function (e, n) {
            var i = t.copy(n).multiplyScalar(0.5);
            return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
          };
        })(),
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          return this.min.copy(t.min), this.max.copy(t.max), this;
        },
        makeEmpty: function () {
          return (
            (this.min.x = this.min.y = 1 / 0),
            (this.max.x = this.max.y = -1 / 0),
            this
          );
        },
        isEmpty: function () {
          return this.max.x < this.min.x || this.max.y < this.min.y;
        },
        getCenter: function (t) {
          var e = t || new n();
          return this.isEmpty()
            ? e.set(0, 0)
            : e.addVectors(this.min, this.max).multiplyScalar(0.5);
        },
        getSize: function (t) {
          var e = t || new n();
          return this.isEmpty()
            ? e.set(0, 0)
            : e.subVectors(this.max, this.min);
        },
        expandByPoint: function (t) {
          return this.min.min(t), this.max.max(t), this;
        },
        expandByVector: function (t) {
          return this.min.sub(t), this.max.add(t), this;
        },
        expandByScalar: function (t) {
          return this.min.addScalar(-t), this.max.addScalar(t), this;
        },
        containsPoint: function (t) {
          return !(
            t.x < this.min.x ||
            t.x > this.max.x ||
            t.y < this.min.y ||
            t.y > this.max.y
          );
        },
        containsBox: function (t) {
          return (
            this.min.x <= t.min.x &&
            t.max.x <= this.max.x &&
            this.min.y <= t.min.y &&
            t.max.y <= this.max.y
          );
        },
        getParameter: function (t, e) {
          return (e || new n()).set(
            (t.x - this.min.x) / (this.max.x - this.min.x),
            (t.y - this.min.y) / (this.max.y - this.min.y)
          );
        },
        intersectsBox: function (t) {
          return !(
            t.max.x < this.min.x ||
            t.min.x > this.max.x ||
            t.max.y < this.min.y ||
            t.min.y > this.max.y
          );
        },
        clampPoint: function (t, e) {
          return (e || new n()).copy(t).clamp(this.min, this.max);
        },
        distanceToPoint: (function () {
          var t = new n();
          return function (e) {
            return t.copy(e).clamp(this.min, this.max).sub(e).length();
          };
        })(),
        intersect: function (t) {
          return this.min.max(t.min), this.max.min(t.max), this;
        },
        union: function (t) {
          return this.min.min(t.min), this.max.max(t.max), this;
        },
        translate: function (t) {
          return this.min.add(t), this.max.add(t), this;
        },
        equals: function (t) {
          return t.min.equals(this.min) && t.max.equals(this.max);
        },
      }),
      ((q.prototype = Object.create(s.prototype)).constructor = q);
    var _a = 0;
    Object.assign(Z.prototype, e.prototype, {
      isMaterial: !0,
      onBeforeCompile: function () {},
      setValues: function (t) {
        if (void 0 !== t)
          for (var e in t) {
            var n = t[e];
            if (void 0 !== n)
              if ("shading" !== e) {
                var i = this[e];
                void 0 !== i
                  ? i && i.isColor
                    ? i.set(n)
                    : i && i.isVector3 && n && n.isVector3
                    ? i.copy(n)
                    : (this[e] = "overdraw" === e ? Number(n) : n)
                  : console.warn(
                      "THREE." +
                        this.type +
                        ": '" +
                        e +
                        "' is not a property of this material."
                    );
              } else
                console.warn(
                  "THREE." +
                    this.type +
                    ": .shading has been removed. Use the boolean .flatShading instead."
                ),
                  (this.flatShading = 1 === n);
            else
              console.warn(
                "THREE.Material: '" + e + "' parameter is undefined."
              );
          }
      },
      toJSON: function (t) {
        function e(t) {
          var e = [];
          for (var n in t) {
            var i = t[n];
            delete i.metadata, e.push(i);
          }
          return e;
        }
        var n = void 0 === t || "string" == typeof t;
        n && (t = { textures: {}, images: {} });
        var i = {
          metadata: {
            version: 4.5,
            type: "Material",
            generator: "Material.toJSON",
          },
        };
        if (
          ((i.uuid = this.uuid),
          (i.type = this.type),
          "" !== this.name && (i.name = this.name),
          this.color && this.color.isColor && (i.color = this.color.getHex()),
          void 0 !== this.roughness && (i.roughness = this.roughness),
          void 0 !== this.metalness && (i.metalness = this.metalness),
          this.emissive &&
            this.emissive.isColor &&
            (i.emissive = this.emissive.getHex()),
          1 !== this.emissiveIntensity &&
            (i.emissiveIntensity = this.emissiveIntensity),
          this.specular &&
            this.specular.isColor &&
            (i.specular = this.specular.getHex()),
          void 0 !== this.shininess && (i.shininess = this.shininess),
          void 0 !== this.clearCoat && (i.clearCoat = this.clearCoat),
          void 0 !== this.clearCoatRoughness &&
            (i.clearCoatRoughness = this.clearCoatRoughness),
          this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid),
          this.alphaMap &&
            this.alphaMap.isTexture &&
            (i.alphaMap = this.alphaMap.toJSON(t).uuid),
          this.lightMap &&
            this.lightMap.isTexture &&
            (i.lightMap = this.lightMap.toJSON(t).uuid),
          this.bumpMap &&
            this.bumpMap.isTexture &&
            ((i.bumpMap = this.bumpMap.toJSON(t).uuid),
            (i.bumpScale = this.bumpScale)),
          this.normalMap &&
            this.normalMap.isTexture &&
            ((i.normalMap = this.normalMap.toJSON(t).uuid),
            (i.normalScale = this.normalScale.toArray())),
          this.displacementMap &&
            this.displacementMap.isTexture &&
            ((i.displacementMap = this.displacementMap.toJSON(t).uuid),
            (i.displacementScale = this.displacementScale),
            (i.displacementBias = this.displacementBias)),
          this.roughnessMap &&
            this.roughnessMap.isTexture &&
            (i.roughnessMap = this.roughnessMap.toJSON(t).uuid),
          this.metalnessMap &&
            this.metalnessMap.isTexture &&
            (i.metalnessMap = this.metalnessMap.toJSON(t).uuid),
          this.emissiveMap &&
            this.emissiveMap.isTexture &&
            (i.emissiveMap = this.emissiveMap.toJSON(t).uuid),
          this.specularMap &&
            this.specularMap.isTexture &&
            (i.specularMap = this.specularMap.toJSON(t).uuid),
          this.envMap &&
            this.envMap.isTexture &&
            ((i.envMap = this.envMap.toJSON(t).uuid),
            (i.reflectivity = this.reflectivity)),
          this.gradientMap &&
            this.gradientMap.isTexture &&
            (i.gradientMap = this.gradientMap.toJSON(t).uuid),
          void 0 !== this.size && (i.size = this.size),
          void 0 !== this.sizeAttenuation &&
            (i.sizeAttenuation = this.sizeAttenuation),
          this.blending !== xr && (i.blending = this.blending),
          !0 === this.flatShading && (i.flatShading = this.flatShading),
          this.side !== pr && (i.side = this.side),
          this.vertexColors !== mr && (i.vertexColors = this.vertexColors),
          this.opacity < 1 && (i.opacity = this.opacity),
          !0 === this.transparent && (i.transparent = this.transparent),
          (i.depthFunc = this.depthFunc),
          (i.depthTest = this.depthTest),
          (i.depthWrite = this.depthWrite),
          0 !== this.rotation && (i.rotation = this.rotation),
          1 !== this.linewidth && (i.linewidth = this.linewidth),
          void 0 !== this.dashSize && (i.dashSize = this.dashSize),
          void 0 !== this.gapSize && (i.gapSize = this.gapSize),
          void 0 !== this.scale && (i.scale = this.scale),
          !0 === this.dithering && (i.dithering = !0),
          this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
          !0 === this.premultipliedAlpha &&
            (i.premultipliedAlpha = this.premultipliedAlpha),
          !0 === this.wireframe && (i.wireframe = this.wireframe),
          this.wireframeLinewidth > 1 &&
            (i.wireframeLinewidth = this.wireframeLinewidth),
          "round" !== this.wireframeLinecap &&
            (i.wireframeLinecap = this.wireframeLinecap),
          "round" !== this.wireframeLinejoin &&
            (i.wireframeLinejoin = this.wireframeLinejoin),
          !0 === this.morphTargets && (i.morphTargets = !0),
          !0 === this.skinning && (i.skinning = !0),
          !1 === this.visible && (i.visible = !1),
          "{}" !== JSON.stringify(this.userData) &&
            (i.userData = this.userData),
          n)
        ) {
          var r = e(t.textures),
            o = e(t.images);
          r.length > 0 && (i.textures = r), o.length > 0 && (i.images = o);
        }
        return i;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        (this.name = t.name),
          (this.fog = t.fog),
          (this.lights = t.lights),
          (this.blending = t.blending),
          (this.side = t.side),
          (this.flatShading = t.flatShading),
          (this.vertexColors = t.vertexColors),
          (this.opacity = t.opacity),
          (this.transparent = t.transparent),
          (this.blendSrc = t.blendSrc),
          (this.blendDst = t.blendDst),
          (this.blendEquation = t.blendEquation),
          (this.blendSrcAlpha = t.blendSrcAlpha),
          (this.blendDstAlpha = t.blendDstAlpha),
          (this.blendEquationAlpha = t.blendEquationAlpha),
          (this.depthFunc = t.depthFunc),
          (this.depthTest = t.depthTest),
          (this.depthWrite = t.depthWrite),
          (this.colorWrite = t.colorWrite),
          (this.precision = t.precision),
          (this.polygonOffset = t.polygonOffset),
          (this.polygonOffsetFactor = t.polygonOffsetFactor),
          (this.polygonOffsetUnits = t.polygonOffsetUnits),
          (this.dithering = t.dithering),
          (this.alphaTest = t.alphaTest),
          (this.premultipliedAlpha = t.premultipliedAlpha),
          (this.overdraw = t.overdraw),
          (this.visible = t.visible),
          (this.userData = JSON.parse(JSON.stringify(t.userData))),
          (this.clipShadows = t.clipShadows),
          (this.clipIntersection = t.clipIntersection);
        var e = t.clippingPlanes,
          n = null;
        if (null !== e) {
          var i = e.length;
          n = new Array(i);
          for (var r = 0; r !== i; ++r) n[r] = e[r].clone();
        }
        return (this.clippingPlanes = n), this;
      },
      dispose: function () {
        this.dispatchEvent({ type: "dispose" });
      },
    }),
      ((J.prototype = Object.create(Z.prototype)).constructor = J),
      (J.prototype.isMeshDepthMaterial = !0),
      (J.prototype.copy = function (t) {
        return (
          Z.prototype.copy.call(this, t),
          (this.depthPacking = t.depthPacking),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.map = t.map),
          (this.alphaMap = t.alphaMap),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          this
        );
      }),
      ((Q.prototype = Object.create(Z.prototype)).constructor = Q),
      (Q.prototype.isMeshDistanceMaterial = !0),
      (Q.prototype.copy = function (t) {
        return (
          Z.prototype.copy.call(this, t),
          this.referencePosition.copy(t.referencePosition),
          (this.nearDistance = t.nearDistance),
          (this.farDistance = t.farDistance),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.map = t.map),
          (this.alphaMap = t.alphaMap),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          this
        );
      }),
      Object.assign(K.prototype, {
        isBox3: !0,
        set: function (t, e) {
          return this.min.copy(t), this.max.copy(e), this;
        },
        setFromArray: function (t) {
          for (
            var e = 1 / 0,
              n = 1 / 0,
              i = 1 / 0,
              r = -1 / 0,
              o = -1 / 0,
              a = -1 / 0,
              s = 0,
              c = t.length;
            s < c;
            s += 3
          ) {
            var l = t[s],
              u = t[s + 1],
              h = t[s + 2];
            l < e && (e = l),
              u < n && (n = u),
              h < i && (i = h),
              l > r && (r = l),
              u > o && (o = u),
              h > a && (a = h);
          }
          return this.min.set(e, n, i), this.max.set(r, o, a), this;
        },
        setFromBufferAttribute: function (t) {
          for (
            var e = 1 / 0,
              n = 1 / 0,
              i = 1 / 0,
              r = -1 / 0,
              o = -1 / 0,
              a = -1 / 0,
              s = 0,
              c = t.count;
            s < c;
            s++
          ) {
            var l = t.getX(s),
              u = t.getY(s),
              h = t.getZ(s);
            l < e && (e = l),
              u < n && (n = u),
              h < i && (i = h),
              l > r && (r = l),
              u > o && (o = u),
              h > a && (a = h);
          }
          return this.min.set(e, n, i), this.max.set(r, o, a), this;
        },
        setFromPoints: function (t) {
          this.makeEmpty();
          for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
          return this;
        },
        setFromCenterAndSize: (function () {
          var t = new o();
          return function (e, n) {
            var i = t.copy(n).multiplyScalar(0.5);
            return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
          };
        })(),
        setFromObject: function (t) {
          return this.makeEmpty(), this.expandByObject(t);
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          return this.min.copy(t.min), this.max.copy(t.max), this;
        },
        makeEmpty: function () {
          return (
            (this.min.x = this.min.y = this.min.z = 1 / 0),
            (this.max.x = this.max.y = this.max.z = -1 / 0),
            this
          );
        },
        isEmpty: function () {
          return (
            this.max.x < this.min.x ||
            this.max.y < this.min.y ||
            this.max.z < this.min.z
          );
        },
        getCenter: function (t) {
          var e = t || new o();
          return this.isEmpty()
            ? e.set(0, 0, 0)
            : e.addVectors(this.min, this.max).multiplyScalar(0.5);
        },
        getSize: function (t) {
          var e = t || new o();
          return this.isEmpty()
            ? e.set(0, 0, 0)
            : e.subVectors(this.max, this.min);
        },
        expandByPoint: function (t) {
          return this.min.min(t), this.max.max(t), this;
        },
        expandByVector: function (t) {
          return this.min.sub(t), this.max.add(t), this;
        },
        expandByScalar: function (t) {
          return this.min.addScalar(-t), this.max.addScalar(t), this;
        },
        expandByObject: (function () {
          function t(t) {
            var o = t.geometry;
            if (void 0 !== o)
              if (o.isGeometry) {
                var a = o.vertices;
                for (n = 0, i = a.length; n < i; n++)
                  r.copy(a[n]),
                    r.applyMatrix4(t.matrixWorld),
                    e.expandByPoint(r);
              } else if (o.isBufferGeometry) {
                var s = o.attributes.position;
                if (void 0 !== s)
                  for (n = 0, i = s.count; n < i; n++)
                    r.fromBufferAttribute(s, n).applyMatrix4(t.matrixWorld),
                      e.expandByPoint(r);
              }
          }
          var e,
            n,
            i,
            r = new o();
          return function (n) {
            return (e = this), n.updateMatrixWorld(!0), n.traverse(t), this;
          };
        })(),
        containsPoint: function (t) {
          return !(
            t.x < this.min.x ||
            t.x > this.max.x ||
            t.y < this.min.y ||
            t.y > this.max.y ||
            t.z < this.min.z ||
            t.z > this.max.z
          );
        },
        containsBox: function (t) {
          return (
            this.min.x <= t.min.x &&
            t.max.x <= this.max.x &&
            this.min.y <= t.min.y &&
            t.max.y <= this.max.y &&
            this.min.z <= t.min.z &&
            t.max.z <= this.max.z
          );
        },
        getParameter: function (t, e) {
          return (e || new o()).set(
            (t.x - this.min.x) / (this.max.x - this.min.x),
            (t.y - this.min.y) / (this.max.y - this.min.y),
            (t.z - this.min.z) / (this.max.z - this.min.z)
          );
        },
        intersectsBox: function (t) {
          return !(
            t.max.x < this.min.x ||
            t.min.x > this.max.x ||
            t.max.y < this.min.y ||
            t.min.y > this.max.y ||
            t.max.z < this.min.z ||
            t.min.z > this.max.z
          );
        },
        intersectsSphere: (function () {
          var t = new o();
          return function (e) {
            return (
              this.clampPoint(e.center, t),
              t.distanceToSquared(e.center) <= e.radius * e.radius
            );
          };
        })(),
        intersectsPlane: function (t) {
          var e, n;
          return (
            t.normal.x > 0
              ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
              : ((e = t.normal.x * this.max.x), (n = t.normal.x * this.min.x)),
            t.normal.y > 0
              ? ((e += t.normal.y * this.min.y), (n += t.normal.y * this.max.y))
              : ((e += t.normal.y * this.max.y),
                (n += t.normal.y * this.min.y)),
            t.normal.z > 0
              ? ((e += t.normal.z * this.min.z), (n += t.normal.z * this.max.z))
              : ((e += t.normal.z * this.max.z),
                (n += t.normal.z * this.min.z)),
            e <= t.constant && n >= t.constant
          );
        },
        clampPoint: function (t, e) {
          return (e || new o()).copy(t).clamp(this.min, this.max);
        },
        distanceToPoint: (function () {
          var t = new o();
          return function (e) {
            return t.copy(e).clamp(this.min, this.max).sub(e).length();
          };
        })(),
        getBoundingSphere: (function () {
          var t = new o();
          return function (e) {
            var n = e || new tt();
            return (
              this.getCenter(n.center),
              (n.radius = 0.5 * this.getSize(t).length()),
              n
            );
          };
        })(),
        intersect: function (t) {
          return (
            this.min.max(t.min),
            this.max.min(t.max),
            this.isEmpty() && this.makeEmpty(),
            this
          );
        },
        union: function (t) {
          return this.min.min(t.min), this.max.max(t.max), this;
        },
        applyMatrix4: (function () {
          var t = [
            new o(),
            new o(),
            new o(),
            new o(),
            new o(),
            new o(),
            new o(),
            new o(),
          ];
          return function (e) {
            return this.isEmpty()
              ? this
              : (t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
                t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
                t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
                t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
                t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
                t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
                t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
                t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
                this.setFromPoints(t),
                this);
          };
        })(),
        translate: function (t) {
          return this.min.add(t), this.max.add(t), this;
        },
        equals: function (t) {
          return t.min.equals(this.min) && t.max.equals(this.max);
        },
      }),
      Object.assign(tt.prototype, {
        set: function (t, e) {
          return this.center.copy(t), (this.radius = e), this;
        },
        setFromPoints: (function () {
          var t = new K();
          return function (e, n) {
            var i = this.center;
            void 0 !== n ? i.copy(n) : t.setFromPoints(e).getCenter(i);
            for (var r = 0, o = 0, a = e.length; o < a; o++)
              r = Math.max(r, i.distanceToSquared(e[o]));
            return (this.radius = Math.sqrt(r)), this;
          };
        })(),
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          return this.center.copy(t.center), (this.radius = t.radius), this;
        },
        empty: function () {
          return this.radius <= 0;
        },
        containsPoint: function (t) {
          return t.distanceToSquared(this.center) <= this.radius * this.radius;
        },
        distanceToPoint: function (t) {
          return t.distanceTo(this.center) - this.radius;
        },
        intersectsSphere: function (t) {
          var e = this.radius + t.radius;
          return t.center.distanceToSquared(this.center) <= e * e;
        },
        intersectsBox: function (t) {
          return t.intersectsSphere(this);
        },
        intersectsPlane: function (t) {
          return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
        },
        clampPoint: function (t, e) {
          var n = this.center.distanceToSquared(t),
            i = e || new o();
          return (
            i.copy(t),
            n > this.radius * this.radius &&
              (i.sub(this.center).normalize(),
              i.multiplyScalar(this.radius).add(this.center)),
            i
          );
        },
        getBoundingBox: function (t) {
          var e = t || new K();
          return (
            e.set(this.center, this.center), e.expandByScalar(this.radius), e
          );
        },
        applyMatrix4: function (t) {
          return (
            this.center.applyMatrix4(t),
            (this.radius = this.radius * t.getMaxScaleOnAxis()),
            this
          );
        },
        translate: function (t) {
          return this.center.add(t), this;
        },
        equals: function (t) {
          return t.center.equals(this.center) && t.radius === this.radius;
        },
      }),
      Object.assign(et.prototype, {
        set: function (t, e) {
          return this.normal.copy(t), (this.constant = e), this;
        },
        setComponents: function (t, e, n, i) {
          return this.normal.set(t, e, n), (this.constant = i), this;
        },
        setFromNormalAndCoplanarPoint: function (t, e) {
          return (
            this.normal.copy(t), (this.constant = -e.dot(this.normal)), this
          );
        },
        setFromCoplanarPoints: (function () {
          var t = new o(),
            e = new o();
          return function (n, i, r) {
            var o = t.subVectors(r, i).cross(e.subVectors(n, i)).normalize();
            return this.setFromNormalAndCoplanarPoint(o, n), this;
          };
        })(),
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          return this.normal.copy(t.normal), (this.constant = t.constant), this;
        },
        normalize: function () {
          var t = 1 / this.normal.length();
          return this.normal.multiplyScalar(t), (this.constant *= t), this;
        },
        negate: function () {
          return (this.constant *= -1), this.normal.negate(), this;
        },
        distanceToPoint: function (t) {
          return this.normal.dot(t) + this.constant;
        },
        distanceToSphere: function (t) {
          return this.distanceToPoint(t.center) - t.radius;
        },
        projectPoint: function (t, e) {
          return (e || new o())
            .copy(this.normal)
            .multiplyScalar(-this.distanceToPoint(t))
            .add(t);
        },
        intersectLine: (function () {
          var t = new o();
          return function (e, n) {
            var i = n || new o(),
              r = e.delta(t),
              a = this.normal.dot(r);
            if (0 !== a) {
              var s = -(e.start.dot(this.normal) + this.constant) / a;
              if (!(s < 0 || s > 1))
                return i.copy(r).multiplyScalar(s).add(e.start);
            } else if (0 === this.distanceToPoint(e.start))
              return i.copy(e.start);
          };
        })(),
        intersectsLine: function (t) {
          var e = this.distanceToPoint(t.start),
            n = this.distanceToPoint(t.end);
          return (e < 0 && n > 0) || (n < 0 && e > 0);
        },
        intersectsBox: function (t) {
          return t.intersectsPlane(this);
        },
        intersectsSphere: function (t) {
          return t.intersectsPlane(this);
        },
        coplanarPoint: function (t) {
          return (t || new o())
            .copy(this.normal)
            .multiplyScalar(-this.constant);
        },
        applyMatrix4: (function () {
          var t = new o(),
            e = new a();
          return function (n, i) {
            var r = i || e.getNormalMatrix(n),
              o = this.coplanarPoint(t).applyMatrix4(n),
              a = this.normal.applyMatrix3(r).normalize();
            return (this.constant = -o.dot(a)), this;
          };
        })(),
        translate: function (t) {
          return (this.constant -= t.dot(this.normal)), this;
        },
        equals: function (t) {
          return t.normal.equals(this.normal) && t.constant === this.constant;
        },
      }),
      Object.assign(nt.prototype, {
        set: function (t, e, n, i, r, o) {
          var a = this.planes;
          return (
            a[0].copy(t),
            a[1].copy(e),
            a[2].copy(n),
            a[3].copy(i),
            a[4].copy(r),
            a[5].copy(o),
            this
          );
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          for (var e = this.planes, n = 0; n < 6; n++) e[n].copy(t.planes[n]);
          return this;
        },
        setFromMatrix: function (t) {
          var e = this.planes,
            n = t.elements,
            i = n[0],
            r = n[1],
            o = n[2],
            a = n[3],
            s = n[4],
            c = n[5],
            l = n[6],
            u = n[7],
            h = n[8],
            p = n[9],
            d = n[10],
            f = n[11],
            m = n[12],
            g = n[13],
            v = n[14],
            y = n[15];
          return (
            e[0].setComponents(a - i, u - s, f - h, y - m).normalize(),
            e[1].setComponents(a + i, u + s, f + h, y + m).normalize(),
            e[2].setComponents(a + r, u + c, f + p, y + g).normalize(),
            e[3].setComponents(a - r, u - c, f - p, y - g).normalize(),
            e[4].setComponents(a - o, u - l, f - d, y - v).normalize(),
            e[5].setComponents(a + o, u + l, f + d, y + v).normalize(),
            this
          );
        },
        intersectsObject: (function () {
          var t = new tt();
          return function (e) {
            var n = e.geometry;
            return (
              null === n.boundingSphere && n.computeBoundingSphere(),
              t.copy(n.boundingSphere).applyMatrix4(e.matrixWorld),
              this.intersectsSphere(t)
            );
          };
        })(),
        intersectsSprite: (function () {
          var t = new tt();
          return function (e) {
            return (
              t.center.set(0, 0, 0),
              (t.radius = 0.7071067811865476),
              t.applyMatrix4(e.matrixWorld),
              this.intersectsSphere(t)
            );
          };
        })(),
        intersectsSphere: function (t) {
          for (
            var e = this.planes, n = t.center, i = -t.radius, r = 0;
            r < 6;
            r++
          )
            if (e[r].distanceToPoint(n) < i) return !1;
          return !0;
        },
        intersectsBox: (function () {
          var t = new o(),
            e = new o();
          return function (n) {
            for (var i = this.planes, r = 0; r < 6; r++) {
              var o = i[r];
              (t.x = o.normal.x > 0 ? n.min.x : n.max.x),
                (e.x = o.normal.x > 0 ? n.max.x : n.min.x),
                (t.y = o.normal.y > 0 ? n.min.y : n.max.y),
                (e.y = o.normal.y > 0 ? n.max.y : n.min.y),
                (t.z = o.normal.z > 0 ? n.min.z : n.max.z),
                (e.z = o.normal.z > 0 ? n.max.z : n.min.z);
              var a = o.distanceToPoint(t),
                s = o.distanceToPoint(e);
              if (a < 0 && s < 0) return !1;
            }
            return !0;
          };
        })(),
        containsPoint: function (t) {
          for (var e = this.planes, n = 0; n < 6; n++)
            if (e[n].distanceToPoint(t) < 0) return !1;
          return !0;
        },
      }),
      (rt.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]),
      (rt.DefaultOrder = "XYZ"),
      Object.defineProperties(rt.prototype, {
        x: {
          get: function () {
            return this._x;
          },
          set: function (t) {
            (this._x = t), this.onChangeCallback();
          },
        },
        y: {
          get: function () {
            return this._y;
          },
          set: function (t) {
            (this._y = t), this.onChangeCallback();
          },
        },
        z: {
          get: function () {
            return this._z;
          },
          set: function (t) {
            (this._z = t), this.onChangeCallback();
          },
        },
        order: {
          get: function () {
            return this._order;
          },
          set: function (t) {
            (this._order = t), this.onChangeCallback();
          },
        },
      }),
      Object.assign(rt.prototype, {
        isEuler: !0,
        set: function (t, e, n, i) {
          return (
            (this._x = t),
            (this._y = e),
            (this._z = n),
            (this._order = i || this._order),
            this.onChangeCallback(),
            this
          );
        },
        clone: function () {
          return new this.constructor(this._x, this._y, this._z, this._order);
        },
        copy: function (t) {
          return (
            (this._x = t._x),
            (this._y = t._y),
            (this._z = t._z),
            (this._order = t._order),
            this.onChangeCallback(),
            this
          );
        },
        setFromRotationMatrix: function (t, e, n) {
          var i = sa.clamp,
            r = t.elements,
            o = r[0],
            a = r[4],
            s = r[8],
            c = r[1],
            l = r[5],
            u = r[9],
            h = r[2],
            p = r[6],
            d = r[10];
          return (
            "XYZ" === (e = e || this._order)
              ? ((this._y = Math.asin(i(s, -1, 1))),
                Math.abs(s) < 0.99999
                  ? ((this._x = Math.atan2(-u, d)),
                    (this._z = Math.atan2(-a, o)))
                  : ((this._x = Math.atan2(p, l)), (this._z = 0)))
              : "YXZ" === e
              ? ((this._x = Math.asin(-i(u, -1, 1))),
                Math.abs(u) < 0.99999
                  ? ((this._y = Math.atan2(s, d)), (this._z = Math.atan2(c, l)))
                  : ((this._y = Math.atan2(-h, o)), (this._z = 0)))
              : "ZXY" === e
              ? ((this._x = Math.asin(i(p, -1, 1))),
                Math.abs(p) < 0.99999
                  ? ((this._y = Math.atan2(-h, d)),
                    (this._z = Math.atan2(-a, l)))
                  : ((this._y = 0), (this._z = Math.atan2(c, o))))
              : "ZYX" === e
              ? ((this._y = Math.asin(-i(h, -1, 1))),
                Math.abs(h) < 0.99999
                  ? ((this._x = Math.atan2(p, d)), (this._z = Math.atan2(c, o)))
                  : ((this._x = 0), (this._z = Math.atan2(-a, l))))
              : "YZX" === e
              ? ((this._z = Math.asin(i(c, -1, 1))),
                Math.abs(c) < 0.99999
                  ? ((this._x = Math.atan2(-u, l)),
                    (this._y = Math.atan2(-h, o)))
                  : ((this._x = 0), (this._y = Math.atan2(s, d))))
              : "XZY" === e
              ? ((this._z = Math.asin(-i(a, -1, 1))),
                Math.abs(a) < 0.99999
                  ? ((this._x = Math.atan2(p, l)), (this._y = Math.atan2(s, o)))
                  : ((this._x = Math.atan2(-u, d)), (this._y = 0)))
              : console.warn(
                  "THREE.Euler: .setFromRotationMatrix() given unsupported order: " +
                    e
                ),
            (this._order = e),
            !1 !== n && this.onChangeCallback(),
            this
          );
        },
        setFromQuaternion: (function () {
          var t = new i();
          return function (e, n, i) {
            return (
              t.makeRotationFromQuaternion(e),
              this.setFromRotationMatrix(t, n, i)
            );
          };
        })(),
        setFromVector3: function (t, e) {
          return this.set(t.x, t.y, t.z, e || this._order);
        },
        reorder: (function () {
          var t = new r();
          return function (e) {
            return t.setFromEuler(this), this.setFromQuaternion(t, e);
          };
        })(),
        equals: function (t) {
          return (
            t._x === this._x &&
            t._y === this._y &&
            t._z === this._z &&
            t._order === this._order
          );
        },
        fromArray: function (t) {
          return (
            (this._x = t[0]),
            (this._y = t[1]),
            (this._z = t[2]),
            void 0 !== t[3] && (this._order = t[3]),
            this.onChangeCallback(),
            this
          );
        },
        toArray: function (t, e) {
          return (
            void 0 === t && (t = []),
            void 0 === e && (e = 0),
            (t[e] = this._x),
            (t[e + 1] = this._y),
            (t[e + 2] = this._z),
            (t[e + 3] = this._order),
            t
          );
        },
        toVector3: function (t) {
          return t
            ? t.set(this._x, this._y, this._z)
            : new o(this._x, this._y, this._z);
        },
        onChange: function (t) {
          return (this.onChangeCallback = t), this;
        },
        onChangeCallback: function () {},
      }),
      Object.assign(ot.prototype, {
        set: function (t) {
          this.mask = (1 << t) | 0;
        },
        enable: function (t) {
          this.mask |= (1 << t) | 0;
        },
        toggle: function (t) {
          this.mask ^= (1 << t) | 0;
        },
        disable: function (t) {
          this.mask &= ~((1 << t) | 0);
        },
        test: function (t) {
          return 0 != (this.mask & t.mask);
        },
      });
    var wa = 0;
    (at.DefaultUp = new o(0, 1, 0)),
      (at.DefaultMatrixAutoUpdate = !0),
      Object.assign(at.prototype, e.prototype, {
        isObject3D: !0,
        onBeforeRender: function () {},
        onAfterRender: function () {},
        applyMatrix: function (t) {
          this.matrix.multiplyMatrices(t, this.matrix),
            this.matrix.decompose(this.position, this.quaternion, this.scale);
        },
        applyQuaternion: function (t) {
          return this.quaternion.premultiply(t), this;
        },
        setRotationFromAxisAngle: function (t, e) {
          this.quaternion.setFromAxisAngle(t, e);
        },
        setRotationFromEuler: function (t) {
          this.quaternion.setFromEuler(t, !0);
        },
        setRotationFromMatrix: function (t) {
          this.quaternion.setFromRotationMatrix(t);
        },
        setRotationFromQuaternion: function (t) {
          this.quaternion.copy(t);
        },
        rotateOnAxis: (function () {
          var t = new r();
          return function (e, n) {
            return t.setFromAxisAngle(e, n), this.quaternion.multiply(t), this;
          };
        })(),
        rotateOnWorldAxis: (function () {
          var t = new r();
          return function (e, n) {
            return (
              t.setFromAxisAngle(e, n), this.quaternion.premultiply(t), this
            );
          };
        })(),
        rotateX: (function () {
          var t = new o(1, 0, 0);
          return function (e) {
            return this.rotateOnAxis(t, e);
          };
        })(),
        rotateY: (function () {
          var t = new o(0, 1, 0);
          return function (e) {
            return this.rotateOnAxis(t, e);
          };
        })(),
        rotateZ: (function () {
          var t = new o(0, 0, 1);
          return function (e) {
            return this.rotateOnAxis(t, e);
          };
        })(),
        translateOnAxis: (function () {
          var t = new o();
          return function (e, n) {
            return (
              t.copy(e).applyQuaternion(this.quaternion),
              this.position.add(t.multiplyScalar(n)),
              this
            );
          };
        })(),
        translateX: (function () {
          var t = new o(1, 0, 0);
          return function (e) {
            return this.translateOnAxis(t, e);
          };
        })(),
        translateY: (function () {
          var t = new o(0, 1, 0);
          return function (e) {
            return this.translateOnAxis(t, e);
          };
        })(),
        translateZ: (function () {
          var t = new o(0, 0, 1);
          return function (e) {
            return this.translateOnAxis(t, e);
          };
        })(),
        localToWorld: function (t) {
          return t.applyMatrix4(this.matrixWorld);
        },
        worldToLocal: (function () {
          var t = new i();
          return function (e) {
            return e.applyMatrix4(t.getInverse(this.matrixWorld));
          };
        })(),
        lookAt: (function () {
          var t = new i(),
            e = new o();
          return function (n, i, r) {
            n.isVector3 ? e.copy(n) : e.set(n, i, r),
              this.isCamera
                ? t.lookAt(this.position, e, this.up)
                : t.lookAt(e, this.position, this.up),
              this.quaternion.setFromRotationMatrix(t);
          };
        })(),
        add: function (t) {
          if (arguments.length > 1) {
            for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
            return this;
          }
          return t === this
            ? (console.error(
                "THREE.Object3D.add: object can't be added as a child of itself.",
                t
              ),
              this)
            : (t && t.isObject3D
                ? (null !== t.parent && t.parent.remove(t),
                  (t.parent = this),
                  t.dispatchEvent({ type: "added" }),
                  this.children.push(t))
                : console.error(
                    "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                    t
                  ),
              this);
        },
        remove: function (t) {
          if (arguments.length > 1) {
            for (var e = 0; e < arguments.length; e++)
              this.remove(arguments[e]);
            return this;
          }
          var n = this.children.indexOf(t);
          return (
            -1 !== n &&
              ((t.parent = null),
              t.dispatchEvent({ type: "removed" }),
              this.children.splice(n, 1)),
            this
          );
        },
        getObjectById: function (t) {
          return this.getObjectByProperty("id", t);
        },
        getObjectByName: function (t) {
          return this.getObjectByProperty("name", t);
        },
        getObjectByProperty: function (t, e) {
          if (this[t] === e) return this;
          for (var n = 0, i = this.children.length; n < i; n++) {
            var r = this.children[n].getObjectByProperty(t, e);
            if (void 0 !== r) return r;
          }
        },
        getWorldPosition: function (t) {
          var e = t || new o();
          return (
            this.updateMatrixWorld(!0),
            e.setFromMatrixPosition(this.matrixWorld)
          );
        },
        getWorldQuaternion: (function () {
          var t = new o(),
            e = new o();
          return function (n) {
            var i = n || new r();
            return (
              this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, i, e), i
            );
          };
        })(),
        getWorldRotation: (function () {
          var t = new r();
          return function (e) {
            var n = e || new rt();
            return (
              this.getWorldQuaternion(t),
              n.setFromQuaternion(t, this.rotation.order, !1)
            );
          };
        })(),
        getWorldScale: (function () {
          var t = new o(),
            e = new r();
          return function (n) {
            var i = n || new o();
            return (
              this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, e, i), i
            );
          };
        })(),
        getWorldDirection: (function () {
          var t = new r();
          return function (e) {
            var n = e || new o();
            return (
              this.getWorldQuaternion(t), n.set(0, 0, 1).applyQuaternion(t)
            );
          };
        })(),
        raycast: function () {},
        traverse: function (t) {
          t(this);
          for (var e = this.children, n = 0, i = e.length; n < i; n++)
            e[n].traverse(t);
        },
        traverseVisible: function (t) {
          if (!1 !== this.visible) {
            t(this);
            for (var e = this.children, n = 0, i = e.length; n < i; n++)
              e[n].traverseVisible(t);
          }
        },
        traverseAncestors: function (t) {
          var e = this.parent;
          null !== e && (t(e), e.traverseAncestors(t));
        },
        updateMatrix: function () {
          this.matrix.compose(this.position, this.quaternion, this.scale),
            (this.matrixWorldNeedsUpdate = !0);
        },
        updateMatrixWorld: function (t) {
          this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || t) &&
              (null === this.parent
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix
                  ),
              (this.matrixWorldNeedsUpdate = !1),
              (t = !0));
          for (var e = this.children, n = 0, i = e.length; n < i; n++)
            e[n].updateMatrixWorld(t);
        },
        toJSON: function (t) {
          function e(e, n) {
            return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid;
          }
          function n(t) {
            var e = [];
            for (var n in t) {
              var i = t[n];
              delete i.metadata, e.push(i);
            }
            return e;
          }
          var i = void 0 === t || "string" == typeof t,
            r = {};
          i &&
            ((t = { geometries: {}, materials: {}, textures: {}, images: {} }),
            (r.metadata = {
              version: 4.5,
              type: "Object",
              generator: "Object3D.toJSON",
            }));
          var o = {};
          if (
            ((o.uuid = this.uuid),
            (o.type = this.type),
            "" !== this.name && (o.name = this.name),
            !0 === this.castShadow && (o.castShadow = !0),
            !0 === this.receiveShadow && (o.receiveShadow = !0),
            !1 === this.visible && (o.visible = !1),
            "{}" !== JSON.stringify(this.userData) &&
              (o.userData = this.userData),
            (o.matrix = this.matrix.toArray()),
            void 0 !== this.geometry &&
              (o.geometry = e(t.geometries, this.geometry)),
            void 0 !== this.material)
          )
            if (Array.isArray(this.material)) {
              for (var a = [], s = 0, c = this.material.length; s < c; s++)
                a.push(e(t.materials, this.material[s]));
              o.material = a;
            } else o.material = e(t.materials, this.material);
          if (this.children.length > 0)
            for (o.children = [], s = 0; s < this.children.length; s++)
              o.children.push(this.children[s].toJSON(t).object);
          if (i) {
            var l = n(t.geometries),
              u = n(t.materials),
              h = n(t.textures),
              p = n(t.images);
            l.length > 0 && (r.geometries = l),
              u.length > 0 && (r.materials = u),
              h.length > 0 && (r.textures = h),
              p.length > 0 && (r.images = p);
          }
          return (r.object = o), r;
        },
        clone: function (t) {
          return new this.constructor().copy(this, t);
        },
        copy: function (t, e) {
          if (
            (void 0 === e && (e = !0),
            (this.name = t.name),
            this.up.copy(t.up),
            this.position.copy(t.position),
            this.quaternion.copy(t.quaternion),
            this.scale.copy(t.scale),
            this.matrix.copy(t.matrix),
            this.matrixWorld.copy(t.matrixWorld),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
            (this.layers.mask = t.layers.mask),
            (this.visible = t.visible),
            (this.castShadow = t.castShadow),
            (this.receiveShadow = t.receiveShadow),
            (this.frustumCulled = t.frustumCulled),
            (this.renderOrder = t.renderOrder),
            (this.userData = JSON.parse(JSON.stringify(t.userData))),
            !0 === e)
          )
            for (var n = 0; n < t.children.length; n++) {
              var i = t.children[n];
              this.add(i.clone());
            }
          return this;
        },
      }),
      (st.prototype = Object.assign(Object.create(at.prototype), {
        constructor: st,
        isCamera: !0,
        copy: function (t, e) {
          return (
            at.prototype.copy.call(this, t, e),
            this.matrixWorldInverse.copy(t.matrixWorldInverse),
            this.projectionMatrix.copy(t.projectionMatrix),
            this
          );
        },
        getWorldDirection: (function () {
          var t = new r();
          return function (e) {
            var n = e || new o();
            return (
              this.getWorldQuaternion(t), n.set(0, 0, -1).applyQuaternion(t)
            );
          };
        })(),
        updateMatrixWorld: function (t) {
          at.prototype.updateMatrixWorld.call(this, t),
            this.matrixWorldInverse.getInverse(this.matrixWorld);
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
      })),
      (ct.prototype = Object.assign(Object.create(st.prototype), {
        constructor: ct,
        isOrthographicCamera: !0,
        copy: function (t, e) {
          return (
            st.prototype.copy.call(this, t, e),
            (this.left = t.left),
            (this.right = t.right),
            (this.top = t.top),
            (this.bottom = t.bottom),
            (this.near = t.near),
            (this.far = t.far),
            (this.zoom = t.zoom),
            (this.view = null === t.view ? null : Object.assign({}, t.view)),
            this
          );
        },
        setViewOffset: function (t, e, n, i, r, o) {
          null === this.view &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
            (this.view.enabled = !0),
            (this.view.fullWidth = t),
            (this.view.fullHeight = e),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = r),
            (this.view.height = o),
            this.updateProjectionMatrix();
        },
        clearViewOffset: function () {
          null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        },
        updateProjectionMatrix: function () {
          var t = (this.right - this.left) / (2 * this.zoom),
            e = (this.top - this.bottom) / (2 * this.zoom),
            n = (this.right + this.left) / 2,
            i = (this.top + this.bottom) / 2,
            r = n - t,
            o = n + t,
            a = i + e,
            s = i - e;
          if (null !== this.view && this.view.enabled) {
            var c = this.zoom / (this.view.width / this.view.fullWidth),
              l = this.zoom / (this.view.height / this.view.fullHeight),
              u = (this.right - this.left) / this.view.width,
              h = (this.top - this.bottom) / this.view.height;
            (o =
              (r += u * (this.view.offsetX / c)) + u * (this.view.width / c)),
              (s =
                (a -= h * (this.view.offsetY / l)) -
                h * (this.view.height / l));
          }
          this.projectionMatrix.makeOrthographic(
            r,
            o,
            a,
            s,
            this.near,
            this.far
          );
        },
        toJSON: function (t) {
          var e = at.prototype.toJSON.call(this, t);
          return (
            (e.object.zoom = this.zoom),
            (e.object.left = this.left),
            (e.object.right = this.right),
            (e.object.top = this.top),
            (e.object.bottom = this.bottom),
            (e.object.near = this.near),
            (e.object.far = this.far),
            null !== this.view &&
              (e.object.view = Object.assign({}, this.view)),
            e
          );
        },
      })),
      Object.assign(lt.prototype, {
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          (this.a = t.a),
            (this.b = t.b),
            (this.c = t.c),
            this.normal.copy(t.normal),
            this.color.copy(t.color),
            (this.materialIndex = t.materialIndex);
          for (var e = 0, n = t.vertexNormals.length; e < n; e++)
            this.vertexNormals[e] = t.vertexNormals[e].clone();
          for (var e = 0, n = t.vertexColors.length; e < n; e++)
            this.vertexColors[e] = t.vertexColors[e].clone();
          return this;
        },
      });
    var Ma = 0;
    Object.assign(ut.prototype, e.prototype, {
      isGeometry: !0,
      applyMatrix: function (t) {
        for (
          var e = new a().getNormalMatrix(t), n = 0, i = this.vertices.length;
          n < i;
          n++
        )
          this.vertices[n].applyMatrix4(t);
        for (var n = 0, i = this.faces.length; n < i; n++) {
          var r = this.faces[n];
          r.normal.applyMatrix3(e).normalize();
          for (var o = 0, s = r.vertexNormals.length; o < s; o++)
            r.vertexNormals[o].applyMatrix3(e).normalize();
        }
        return (
          null !== this.boundingBox && this.computeBoundingBox(),
          null !== this.boundingSphere && this.computeBoundingSphere(),
          (this.verticesNeedUpdate = !0),
          (this.normalsNeedUpdate = !0),
          this
        );
      },
      rotateX: (function () {
        var t = new i();
        return function (e) {
          return t.makeRotationX(e), this.applyMatrix(t), this;
        };
      })(),
      rotateY: (function () {
        var t = new i();
        return function (e) {
          return t.makeRotationY(e), this.applyMatrix(t), this;
        };
      })(),
      rotateZ: (function () {
        var t = new i();
        return function (e) {
          return t.makeRotationZ(e), this.applyMatrix(t), this;
        };
      })(),
      translate: (function () {
        var t = new i();
        return function (e, n, i) {
          return t.makeTranslation(e, n, i), this.applyMatrix(t), this;
        };
      })(),
      scale: (function () {
        var t = new i();
        return function (e, n, i) {
          return t.makeScale(e, n, i), this.applyMatrix(t), this;
        };
      })(),
      lookAt: (function () {
        var t = new at();
        return function (e) {
          t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix);
        };
      })(),
      fromBufferGeometry: function (t) {
        function e(t, e, n, r) {
          var o = new lt(
            t,
            e,
            n,
            void 0 !== c ? [p[t].clone(), p[e].clone(), p[n].clone()] : [],
            void 0 !== l
              ? [i.colors[t].clone(), i.colors[e].clone(), i.colors[n].clone()]
              : [],
            r
          );
          i.faces.push(o),
            void 0 !== u &&
              i.faceVertexUvs[0].push([
                d[t].clone(),
                d[e].clone(),
                d[n].clone(),
              ]),
            void 0 !== h &&
              i.faceVertexUvs[1].push([
                f[t].clone(),
                f[e].clone(),
                f[n].clone(),
              ]);
        }
        var i = this,
          r = null !== t.index ? t.index.array : void 0,
          a = t.attributes,
          s = a.position.array,
          c = void 0 !== a.normal ? a.normal.array : void 0,
          l = void 0 !== a.color ? a.color.array : void 0,
          u = void 0 !== a.uv ? a.uv.array : void 0,
          h = void 0 !== a.uv2 ? a.uv2.array : void 0;
        void 0 !== h && (this.faceVertexUvs[1] = []);
        for (
          var p = [], d = [], f = [], m = 0, g = 0;
          m < s.length;
          m += 3, g += 2
        )
          i.vertices.push(new o(s[m], s[m + 1], s[m + 2])),
            void 0 !== c && p.push(new o(c[m], c[m + 1], c[m + 2])),
            void 0 !== l && i.colors.push(new W(l[m], l[m + 1], l[m + 2])),
            void 0 !== u && d.push(new n(u[g], u[g + 1])),
            void 0 !== h && f.push(new n(h[g], h[g + 1]));
        var v = t.groups;
        if (v.length > 0)
          for (m = 0; m < v.length; m++)
            for (
              var y = v[m], x = y.start, g = x, b = x + y.count;
              g < b;
              g += 3
            )
              void 0 !== r
                ? e(r[g], r[g + 1], r[g + 2], y.materialIndex)
                : e(g, g + 1, g + 2, y.materialIndex);
        else if (void 0 !== r)
          for (m = 0; m < r.length; m += 3) e(r[m], r[m + 1], r[m + 2]);
        else for (m = 0; m < s.length / 3; m += 3) e(m, m + 1, m + 2);
        return (
          this.computeFaceNormals(),
          null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
          null !== t.boundingSphere &&
            (this.boundingSphere = t.boundingSphere.clone()),
          this
        );
      },
      center: function () {
        this.computeBoundingBox();
        var t = this.boundingBox.getCenter().negate();
        return this.translate(t.x, t.y, t.z), t;
      },
      normalize: function () {
        this.computeBoundingSphere();
        var t = this.boundingSphere.center,
          e = this.boundingSphere.radius,
          n = 0 === e ? 1 : 1 / e,
          r = new i();
        return (
          r.set(
            n,
            0,
            0,
            -n * t.x,
            0,
            n,
            0,
            -n * t.y,
            0,
            0,
            n,
            -n * t.z,
            0,
            0,
            0,
            1
          ),
          this.applyMatrix(r),
          this
        );
      },
      computeFaceNormals: function () {
        for (
          var t = new o(), e = new o(), n = 0, i = this.faces.length;
          n < i;
          n++
        ) {
          var r = this.faces[n],
            a = this.vertices[r.a],
            s = this.vertices[r.b],
            c = this.vertices[r.c];
          t.subVectors(c, s),
            e.subVectors(a, s),
            t.cross(e),
            t.normalize(),
            r.normal.copy(t);
        }
      },
      computeVertexNormals: function (t) {
        void 0 === t && (t = !0);
        var e, n, i, r, a, s;
        for (
          s = new Array(this.vertices.length), e = 0, n = this.vertices.length;
          e < n;
          e++
        )
          s[e] = new o();
        if (t) {
          var c,
            l,
            u,
            h = new o(),
            p = new o();
          for (i = 0, r = this.faces.length; i < r; i++)
            (a = this.faces[i]),
              (c = this.vertices[a.a]),
              (l = this.vertices[a.b]),
              (u = this.vertices[a.c]),
              h.subVectors(u, l),
              p.subVectors(c, l),
              h.cross(p),
              s[a.a].add(h),
              s[a.b].add(h),
              s[a.c].add(h);
        } else
          for (
            this.computeFaceNormals(), i = 0, r = this.faces.length;
            i < r;
            i++
          )
            s[(a = this.faces[i]).a].add(a.normal),
              s[a.b].add(a.normal),
              s[a.c].add(a.normal);
        for (e = 0, n = this.vertices.length; e < n; e++) s[e].normalize();
        for (i = 0, r = this.faces.length; i < r; i++) {
          var d = (a = this.faces[i]).vertexNormals;
          3 === d.length
            ? (d[0].copy(s[a.a]), d[1].copy(s[a.b]), d[2].copy(s[a.c]))
            : ((d[0] = s[a.a].clone()),
              (d[1] = s[a.b].clone()),
              (d[2] = s[a.c].clone()));
        }
        this.faces.length > 0 && (this.normalsNeedUpdate = !0);
      },
      computeFlatVertexNormals: function () {
        var t, e, n;
        for (
          this.computeFaceNormals(), t = 0, e = this.faces.length;
          t < e;
          t++
        ) {
          var i = (n = this.faces[t]).vertexNormals;
          3 === i.length
            ? (i[0].copy(n.normal), i[1].copy(n.normal), i[2].copy(n.normal))
            : ((i[0] = n.normal.clone()),
              (i[1] = n.normal.clone()),
              (i[2] = n.normal.clone()));
        }
        this.faces.length > 0 && (this.normalsNeedUpdate = !0);
      },
      computeMorphNormals: function () {
        var t, e, n, i, r;
        for (n = 0, i = this.faces.length; n < i; n++)
          for (
            (r = this.faces[n]).__originalFaceNormal
              ? r.__originalFaceNormal.copy(r.normal)
              : (r.__originalFaceNormal = r.normal.clone()),
              r.__originalVertexNormals || (r.__originalVertexNormals = []),
              t = 0,
              e = r.vertexNormals.length;
            t < e;
            t++
          )
            r.__originalVertexNormals[t]
              ? r.__originalVertexNormals[t].copy(r.vertexNormals[t])
              : (r.__originalVertexNormals[t] = r.vertexNormals[t].clone());
        var a = new ut();
        for (
          a.faces = this.faces, t = 0, e = this.morphTargets.length;
          t < e;
          t++
        ) {
          if (!this.morphNormals[t]) {
            (this.morphNormals[t] = {}),
              (this.morphNormals[t].faceNormals = []),
              (this.morphNormals[t].vertexNormals = []);
            var s = this.morphNormals[t].faceNormals,
              c = this.morphNormals[t].vertexNormals;
            for (n = 0, i = this.faces.length; n < i; n++)
              (u = new o()),
                (h = { a: new o(), b: new o(), c: new o() }),
                s.push(u),
                c.push(h);
          }
          var l = this.morphNormals[t];
          (a.vertices = this.morphTargets[t].vertices),
            a.computeFaceNormals(),
            a.computeVertexNormals();
          var u, h;
          for (n = 0, i = this.faces.length; n < i; n++)
            (r = this.faces[n]),
              (u = l.faceNormals[n]),
              (h = l.vertexNormals[n]),
              u.copy(r.normal),
              h.a.copy(r.vertexNormals[0]),
              h.b.copy(r.vertexNormals[1]),
              h.c.copy(r.vertexNormals[2]);
        }
        for (n = 0, i = this.faces.length; n < i; n++)
          ((r = this.faces[n]).normal = r.__originalFaceNormal),
            (r.vertexNormals = r.__originalVertexNormals);
      },
      computeLineDistances: function () {
        for (var t = 0, e = this.vertices, n = 0, i = e.length; n < i; n++)
          n > 0 && (t += e[n].distanceTo(e[n - 1])),
            (this.lineDistances[n] = t);
      },
      computeBoundingBox: function () {
        null === this.boundingBox && (this.boundingBox = new K()),
          this.boundingBox.setFromPoints(this.vertices);
      },
      computeBoundingSphere: function () {
        null === this.boundingSphere && (this.boundingSphere = new tt()),
          this.boundingSphere.setFromPoints(this.vertices);
      },
      merge: function (t, e, n) {
        if (t && t.isGeometry) {
          var i,
            r = this.vertices.length,
            o = this.vertices,
            s = t.vertices,
            c = this.faces,
            l = t.faces,
            u = this.faceVertexUvs[0],
            h = t.faceVertexUvs[0],
            p = this.colors,
            d = t.colors;
          void 0 === n && (n = 0),
            void 0 !== e && (i = new a().getNormalMatrix(e));
          for (var f = 0, m = s.length; f < m; f++) {
            var g = s[f].clone();
            void 0 !== e && g.applyMatrix4(e), o.push(g);
          }
          for (var f = 0, m = d.length; f < m; f++) p.push(d[f].clone());
          for (f = 0, m = l.length; f < m; f++) {
            var v,
              y,
              x,
              b = l[f],
              _ = b.vertexNormals,
              w = b.vertexColors;
            (v = new lt(b.a + r, b.b + r, b.c + r)).normal.copy(b.normal),
              void 0 !== i && v.normal.applyMatrix3(i).normalize();
            for (var M = 0, E = _.length; M < E; M++)
              (y = _[M].clone()),
                void 0 !== i && y.applyMatrix3(i).normalize(),
                v.vertexNormals.push(y);
            v.color.copy(b.color);
            for (var M = 0, E = w.length; M < E; M++)
              (x = w[M]), v.vertexColors.push(x.clone());
            (v.materialIndex = b.materialIndex + n), c.push(v);
          }
          for (f = 0, m = h.length; f < m; f++) {
            var T = h[f],
              S = [];
            if (void 0 !== T) {
              for (var M = 0, E = T.length; M < E; M++) S.push(T[M].clone());
              u.push(S);
            }
          }
        } else
          console.error(
            "THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",
            t
          );
      },
      mergeMesh: function (t) {
        t && t.isMesh
          ? (t.matrixAutoUpdate && t.updateMatrix(),
            this.merge(t.geometry, t.matrix))
          : console.error(
              "THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",
              t
            );
      },
      mergeVertices: function () {
        var t,
          e,
          n,
          i,
          r,
          o,
          a,
          s,
          c = {},
          l = [],
          u = [],
          h = Math.pow(10, 4);
        for (n = 0, i = this.vertices.length; n < i; n++)
          (t = this.vertices[n]),
            void 0 ===
            c[
              (e =
                Math.round(t.x * h) +
                "_" +
                Math.round(t.y * h) +
                "_" +
                Math.round(t.z * h))
            ]
              ? ((c[e] = n), l.push(this.vertices[n]), (u[n] = l.length - 1))
              : (u[n] = u[c[e]]);
        var p = [];
        for (n = 0, i = this.faces.length; n < i; n++) {
          ((r = this.faces[n]).a = u[r.a]),
            (r.b = u[r.b]),
            (r.c = u[r.c]),
            (o = [r.a, r.b, r.c]);
          for (var d = 0; d < 3; d++)
            if (o[d] === o[(d + 1) % 3]) {
              p.push(n);
              break;
            }
        }
        for (n = p.length - 1; n >= 0; n--) {
          var f = p[n];
          for (
            this.faces.splice(f, 1), a = 0, s = this.faceVertexUvs.length;
            a < s;
            a++
          )
            this.faceVertexUvs[a].splice(f, 1);
        }
        var m = this.vertices.length - l.length;
        return (this.vertices = l), m;
      },
      setFromPoints: function (t) {
        this.vertices = [];
        for (var e = 0, n = t.length; e < n; e++) {
          var i = t[e];
          this.vertices.push(new o(i.x, i.y, i.z || 0));
        }
        return this;
      },
      sortFacesByMaterialIndex: function () {
        for (var t = this.faces, e = t.length, n = 0; n < e; n++) t[n]._id = n;
        t.sort(function (t, e) {
          return t.materialIndex - e.materialIndex;
        });
        var i,
          r,
          o = this.faceVertexUvs[0],
          a = this.faceVertexUvs[1];
        for (
          o && o.length === e && (i = []),
            a && a.length === e && (r = []),
            n = 0;
          n < e;
          n++
        ) {
          var s = t[n]._id;
          i && i.push(o[s]), r && r.push(a[s]);
        }
        i && (this.faceVertexUvs[0] = i), r && (this.faceVertexUvs[1] = r);
      },
      toJSON: function () {
        function t(t, e, n) {
          return n ? t | (1 << e) : t & ~(1 << e);
        }
        function e(t) {
          var e = t.x.toString() + t.y.toString() + t.z.toString();
          return void 0 !== p[e]
            ? p[e]
            : ((p[e] = h.length / 3), h.push(t.x, t.y, t.z), p[e]);
        }
        function n(t) {
          var e = t.r.toString() + t.g.toString() + t.b.toString();
          return void 0 !== f[e]
            ? f[e]
            : ((f[e] = d.length), d.push(t.getHex()), f[e]);
        }
        function i(t) {
          var e = t.x.toString() + t.y.toString();
          return void 0 !== g[e]
            ? g[e]
            : ((g[e] = m.length / 2), m.push(t.x, t.y), g[e]);
        }
        var r = {
          metadata: {
            version: 4.5,
            type: "Geometry",
            generator: "Geometry.toJSON",
          },
        };
        if (
          ((r.uuid = this.uuid),
          (r.type = this.type),
          "" !== this.name && (r.name = this.name),
          void 0 !== this.parameters)
        ) {
          var o = this.parameters;
          for (var a in o) void 0 !== o[a] && (r[a] = o[a]);
          return r;
        }
        for (var s = [], c = 0; c < this.vertices.length; c++) {
          var l = this.vertices[c];
          s.push(l.x, l.y, l.z);
        }
        for (
          var u = [], h = [], p = {}, d = [], f = {}, m = [], g = {}, c = 0;
          c < this.faces.length;
          c++
        ) {
          var v = this.faces[c],
            y = void 0 !== this.faceVertexUvs[0][c],
            x = v.normal.length() > 0,
            b = v.vertexNormals.length > 0,
            _ = 1 !== v.color.r || 1 !== v.color.g || 1 !== v.color.b,
            w = v.vertexColors.length > 0,
            M = 0;
          if (
            ((M = t(M, 0, 0)),
            (M = t(M, 1, !0)),
            (M = t(M, 2, !1)),
            (M = t(M, 3, y)),
            (M = t(M, 4, x)),
            (M = t(M, 5, b)),
            (M = t(M, 6, _)),
            (M = t(M, 7, w)),
            u.push(M),
            u.push(v.a, v.b, v.c),
            u.push(v.materialIndex),
            y)
          ) {
            var E = this.faceVertexUvs[0][c];
            u.push(i(E[0]), i(E[1]), i(E[2]));
          }
          if ((x && u.push(e(v.normal)), b)) {
            var T = v.vertexNormals;
            u.push(e(T[0]), e(T[1]), e(T[2]));
          }
          if ((_ && u.push(n(v.color)), w)) {
            var S = v.vertexColors;
            u.push(n(S[0]), n(S[1]), n(S[2]));
          }
        }
        return (
          (r.data = {}),
          (r.data.vertices = s),
          (r.data.normals = h),
          d.length > 0 && (r.data.colors = d),
          m.length > 0 && (r.data.uvs = [m]),
          (r.data.faces = u),
          r
        );
      },
      clone: function () {
        return new ut().copy(this);
      },
      copy: function (t) {
        var e, n, i, r, o, a;
        (this.vertices = []),
          (this.colors = []),
          (this.faces = []),
          (this.faceVertexUvs = [[]]),
          (this.morphTargets = []),
          (this.morphNormals = []),
          (this.skinWeights = []),
          (this.skinIndices = []),
          (this.lineDistances = []),
          (this.boundingBox = null),
          (this.boundingSphere = null),
          (this.name = t.name);
        var s = t.vertices;
        for (e = 0, n = s.length; e < n; e++) this.vertices.push(s[e].clone());
        var c = t.colors;
        for (e = 0, n = c.length; e < n; e++) this.colors.push(c[e].clone());
        var l = t.faces;
        for (e = 0, n = l.length; e < n; e++) this.faces.push(l[e].clone());
        for (e = 0, n = t.faceVertexUvs.length; e < n; e++) {
          var u = t.faceVertexUvs[e];
          for (
            void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []),
              i = 0,
              r = u.length;
            i < r;
            i++
          ) {
            var h = u[i],
              p = [];
            for (o = 0, a = h.length; o < a; o++) {
              var d = h[o];
              p.push(d.clone());
            }
            this.faceVertexUvs[e].push(p);
          }
        }
        var f = t.morphTargets;
        for (e = 0, n = f.length; e < n; e++) {
          var m = {};
          if (((m.name = f[e].name), void 0 !== f[e].vertices))
            for (m.vertices = [], i = 0, r = f[e].vertices.length; i < r; i++)
              m.vertices.push(f[e].vertices[i].clone());
          if (void 0 !== f[e].normals)
            for (m.normals = [], i = 0, r = f[e].normals.length; i < r; i++)
              m.normals.push(f[e].normals[i].clone());
          this.morphTargets.push(m);
        }
        var g = t.morphNormals;
        for (e = 0, n = g.length; e < n; e++) {
          var v = {};
          if (void 0 !== g[e].vertexNormals)
            for (
              v.vertexNormals = [], i = 0, r = g[e].vertexNormals.length;
              i < r;
              i++
            ) {
              var y = g[e].vertexNormals[i],
                x = {};
              (x.a = y.a.clone()),
                (x.b = y.b.clone()),
                (x.c = y.c.clone()),
                v.vertexNormals.push(x);
            }
          if (void 0 !== g[e].faceNormals)
            for (
              v.faceNormals = [], i = 0, r = g[e].faceNormals.length;
              i < r;
              i++
            )
              v.faceNormals.push(g[e].faceNormals[i].clone());
          this.morphNormals.push(v);
        }
        var b = t.skinWeights;
        for (e = 0, n = b.length; e < n; e++)
          this.skinWeights.push(b[e].clone());
        var _ = t.skinIndices;
        for (e = 0, n = _.length; e < n; e++)
          this.skinIndices.push(_[e].clone());
        var w = t.lineDistances;
        for (e = 0, n = w.length; e < n; e++) this.lineDistances.push(w[e]);
        var M = t.boundingBox;
        null !== M && (this.boundingBox = M.clone());
        var E = t.boundingSphere;
        return (
          null !== E && (this.boundingSphere = E.clone()),
          (this.elementsNeedUpdate = t.elementsNeedUpdate),
          (this.verticesNeedUpdate = t.verticesNeedUpdate),
          (this.uvsNeedUpdate = t.uvsNeedUpdate),
          (this.normalsNeedUpdate = t.normalsNeedUpdate),
          (this.colorsNeedUpdate = t.colorsNeedUpdate),
          (this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate),
          (this.groupsNeedUpdate = t.groupsNeedUpdate),
          this
        );
      },
      dispose: function () {
        this.dispatchEvent({ type: "dispose" });
      },
    }),
      Object.defineProperty(ht.prototype, "needsUpdate", {
        set: function (t) {
          !0 === t && this.version++;
        },
      }),
      Object.assign(ht.prototype, {
        isBufferAttribute: !0,
        setArray: function (t) {
          if (Array.isArray(t))
            throw new TypeError(
              "THREE.BufferAttribute: array should be a Typed Array."
            );
          (this.count = void 0 !== t ? t.length / this.itemSize : 0),
            (this.array = t);
        },
        setDynamic: function (t) {
          return (this.dynamic = t), this;
        },
        copy: function (t) {
          return (
            (this.array = new t.array.constructor(t.array)),
            (this.itemSize = t.itemSize),
            (this.count = t.count),
            (this.normalized = t.normalized),
            (this.dynamic = t.dynamic),
            this
          );
        },
        copyAt: function (t, e, n) {
          (t *= this.itemSize), (n *= e.itemSize);
          for (var i = 0, r = this.itemSize; i < r; i++)
            this.array[t + i] = e.array[n + i];
          return this;
        },
        copyArray: function (t) {
          return this.array.set(t), this;
        },
        copyColorsArray: function (t) {
          for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
            var o = t[i];
            void 0 === o &&
              (console.warn(
                "THREE.BufferAttribute.copyColorsArray(): color is undefined",
                i
              ),
              (o = new W())),
              (e[n++] = o.r),
              (e[n++] = o.g),
              (e[n++] = o.b);
          }
          return this;
        },
        copyIndicesArray: function (t) {
          for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
            var o = t[i];
            (e[n++] = o.a), (e[n++] = o.b), (e[n++] = o.c);
          }
          return this;
        },
        copyVector2sArray: function (t) {
          for (var e = this.array, i = 0, r = 0, o = t.length; r < o; r++) {
            var a = t[r];
            void 0 === a &&
              (console.warn(
                "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
                r
              ),
              (a = new n())),
              (e[i++] = a.x),
              (e[i++] = a.y);
          }
          return this;
        },
        copyVector3sArray: function (t) {
          for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
            var a = t[i];
            void 0 === a &&
              (console.warn(
                "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
                i
              ),
              (a = new o())),
              (e[n++] = a.x),
              (e[n++] = a.y),
              (e[n++] = a.z);
          }
          return this;
        },
        copyVector4sArray: function (t) {
          for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
            var o = t[i];
            void 0 === o &&
              (console.warn(
                "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
                i
              ),
              (o = new c())),
              (e[n++] = o.x),
              (e[n++] = o.y),
              (e[n++] = o.z),
              (e[n++] = o.w);
          }
          return this;
        },
        set: function (t, e) {
          return void 0 === e && (e = 0), this.array.set(t, e), this;
        },
        getX: function (t) {
          return this.array[t * this.itemSize];
        },
        setX: function (t, e) {
          return (this.array[t * this.itemSize] = e), this;
        },
        getY: function (t) {
          return this.array[t * this.itemSize + 1];
        },
        setY: function (t, e) {
          return (this.array[t * this.itemSize + 1] = e), this;
        },
        getZ: function (t) {
          return this.array[t * this.itemSize + 2];
        },
        setZ: function (t, e) {
          return (this.array[t * this.itemSize + 2] = e), this;
        },
        getW: function (t) {
          return this.array[t * this.itemSize + 3];
        },
        setW: function (t, e) {
          return (this.array[t * this.itemSize + 3] = e), this;
        },
        setXY: function (t, e, n) {
          return (
            (t *= this.itemSize),
            (this.array[t + 0] = e),
            (this.array[t + 1] = n),
            this
          );
        },
        setXYZ: function (t, e, n, i) {
          return (
            (t *= this.itemSize),
            (this.array[t + 0] = e),
            (this.array[t + 1] = n),
            (this.array[t + 2] = i),
            this
          );
        },
        setXYZW: function (t, e, n, i, r) {
          return (
            (t *= this.itemSize),
            (this.array[t + 0] = e),
            (this.array[t + 1] = n),
            (this.array[t + 2] = i),
            (this.array[t + 3] = r),
            this
          );
        },
        onUpload: function (t) {
          return (this.onUploadCallback = t), this;
        },
        clone: function () {
          return new this.constructor(this.array, this.itemSize).copy(this);
        },
      }),
      ((pt.prototype = Object.create(ht.prototype)).constructor = pt),
      ((dt.prototype = Object.create(ht.prototype)).constructor = dt),
      ((ft.prototype = Object.create(ht.prototype)).constructor = ft),
      ((mt.prototype = Object.create(ht.prototype)).constructor = mt),
      ((gt.prototype = Object.create(ht.prototype)).constructor = gt),
      ((vt.prototype = Object.create(ht.prototype)).constructor = vt),
      ((yt.prototype = Object.create(ht.prototype)).constructor = yt),
      ((xt.prototype = Object.create(ht.prototype)).constructor = xt),
      ((bt.prototype = Object.create(ht.prototype)).constructor = bt),
      Object.assign(_t.prototype, {
        computeGroups: function (t) {
          for (
            var e, n = [], i = void 0, r = t.faces, o = 0;
            o < r.length;
            o++
          ) {
            var a = r[o];
            a.materialIndex !== i &&
              ((i = a.materialIndex),
              void 0 !== e && ((e.count = 3 * o - e.start), n.push(e)),
              (e = { start: 3 * o, materialIndex: i }));
          }
          void 0 !== e && ((e.count = 3 * o - e.start), n.push(e)),
            (this.groups = n);
        },
        fromGeometry: function (t) {
          var e,
            i = t.faces,
            r = t.vertices,
            o = t.faceVertexUvs,
            a = o[0] && o[0].length > 0,
            s = o[1] && o[1].length > 0,
            c = t.morphTargets,
            l = c.length;
          if (l > 0) {
            for (e = [], v = 0; v < l; v++) e[v] = [];
            this.morphTargets.position = e;
          }
          var u,
            h = t.morphNormals,
            p = h.length;
          if (p > 0) {
            for (u = [], v = 0; v < p; v++) u[v] = [];
            this.morphTargets.normal = u;
          }
          for (
            var d = t.skinIndices,
              f = t.skinWeights,
              m = d.length === r.length,
              g = f.length === r.length,
              v = 0;
            v < i.length;
            v++
          ) {
            var y = i[v];
            this.vertices.push(r[y.a], r[y.b], r[y.c]);
            var x = y.vertexNormals;
            if (3 === x.length) this.normals.push(x[0], x[1], x[2]);
            else {
              var b = y.normal;
              this.normals.push(b, b, b);
            }
            var _ = y.vertexColors;
            if (3 === _.length) this.colors.push(_[0], _[1], _[2]);
            else {
              var w = y.color;
              this.colors.push(w, w, w);
            }
            if (
              (!0 === a &&
                (void 0 !== (M = o[0][v])
                  ? this.uvs.push(M[0], M[1], M[2])
                  : (console.warn(
                      "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",
                      v
                    ),
                    this.uvs.push(new n(), new n(), new n()))),
              !0 === s)
            ) {
              var M = o[1][v];
              void 0 !== M
                ? this.uvs2.push(M[0], M[1], M[2])
                : (console.warn(
                    "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",
                    v
                  ),
                  this.uvs2.push(new n(), new n(), new n()));
            }
            for (T = 0; T < l; T++) {
              var E = c[T].vertices;
              e[T].push(E[y.a], E[y.b], E[y.c]);
            }
            for (var T = 0; T < p; T++) {
              var S = h[T].vertexNormals[v];
              u[T].push(S.a, S.b, S.c);
            }
            m && this.skinIndices.push(d[y.a], d[y.b], d[y.c]),
              g && this.skinWeights.push(f[y.a], f[y.b], f[y.c]);
          }
          return (
            this.computeGroups(t),
            (this.verticesNeedUpdate = t.verticesNeedUpdate),
            (this.normalsNeedUpdate = t.normalsNeedUpdate),
            (this.colorsNeedUpdate = t.colorsNeedUpdate),
            (this.uvsNeedUpdate = t.uvsNeedUpdate),
            (this.groupsNeedUpdate = t.groupsNeedUpdate),
            this
          );
        },
      });
    var Ea = 1;
    Object.assign(Mt.prototype, e.prototype, {
      isBufferGeometry: !0,
      getIndex: function () {
        return this.index;
      },
      setIndex: function (t) {
        Array.isArray(t)
          ? (this.index = new (wt(t) > 65535 ? yt : gt)(t, 1))
          : (this.index = t);
      },
      addAttribute: function (t, e) {
        return (e && e.isBufferAttribute) ||
          (e && e.isInterleavedBufferAttribute)
          ? "index" === t
            ? (console.warn(
                "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
              ),
              void this.setIndex(e))
            : ((this.attributes[t] = e), this)
          : (console.warn(
              "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
            ),
            void this.addAttribute(t, new ht(arguments[1], arguments[2])));
      },
      getAttribute: function (t) {
        return this.attributes[t];
      },
      removeAttribute: function (t) {
        return delete this.attributes[t], this;
      },
      addGroup: function (t, e, n) {
        this.groups.push({
          start: t,
          count: e,
          materialIndex: void 0 !== n ? n : 0,
        });
      },
      clearGroups: function () {
        this.groups = [];
      },
      setDrawRange: function (t, e) {
        (this.drawRange.start = t), (this.drawRange.count = e);
      },
      applyMatrix: function (t) {
        var e = this.attributes.position;
        void 0 !== e && (t.applyToBufferAttribute(e), (e.needsUpdate = !0));
        var n = this.attributes.normal;
        return (
          void 0 !== n &&
            (new a().getNormalMatrix(t).applyToBufferAttribute(n),
            (n.needsUpdate = !0)),
          null !== this.boundingBox && this.computeBoundingBox(),
          null !== this.boundingSphere && this.computeBoundingSphere(),
          this
        );
      },
      rotateX: (function () {
        var t = new i();
        return function (e) {
          return t.makeRotationX(e), this.applyMatrix(t), this;
        };
      })(),
      rotateY: (function () {
        var t = new i();
        return function (e) {
          return t.makeRotationY(e), this.applyMatrix(t), this;
        };
      })(),
      rotateZ: (function () {
        var t = new i();
        return function (e) {
          return t.makeRotationZ(e), this.applyMatrix(t), this;
        };
      })(),
      translate: (function () {
        var t = new i();
        return function (e, n, i) {
          return t.makeTranslation(e, n, i), this.applyMatrix(t), this;
        };
      })(),
      scale: (function () {
        var t = new i();
        return function (e, n, i) {
          return t.makeScale(e, n, i), this.applyMatrix(t), this;
        };
      })(),
      lookAt: (function () {
        var t = new at();
        return function (e) {
          t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix);
        };
      })(),
      center: function () {
        this.computeBoundingBox();
        var t = this.boundingBox.getCenter().negate();
        return this.translate(t.x, t.y, t.z), t;
      },
      setFromObject: function (t) {
        var e = t.geometry;
        if (t.isPoints || t.isLine) {
          var n = new xt(3 * e.vertices.length, 3),
            i = new xt(3 * e.colors.length, 3);
          if (
            (this.addAttribute("position", n.copyVector3sArray(e.vertices)),
            this.addAttribute("color", i.copyColorsArray(e.colors)),
            e.lineDistances && e.lineDistances.length === e.vertices.length)
          ) {
            var r = new xt(e.lineDistances.length, 1);
            this.addAttribute("lineDistance", r.copyArray(e.lineDistances));
          }
          null !== e.boundingSphere &&
            (this.boundingSphere = e.boundingSphere.clone()),
            null !== e.boundingBox &&
              (this.boundingBox = e.boundingBox.clone());
        } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
        return this;
      },
      setFromPoints: function (t) {
        for (var e = [], n = 0, i = t.length; n < i; n++) {
          var r = t[n];
          e.push(r.x, r.y, r.z || 0);
        }
        return this.addAttribute("position", new xt(e, 3)), this;
      },
      updateFromObject: function (t) {
        var e = t.geometry;
        if (t.isMesh) {
          var n = e.__directGeometry;
          if (
            (!0 === e.elementsNeedUpdate &&
              ((n = void 0), (e.elementsNeedUpdate = !1)),
            void 0 === n)
          )
            return this.fromGeometry(e);
          (n.verticesNeedUpdate = e.verticesNeedUpdate),
            (n.normalsNeedUpdate = e.normalsNeedUpdate),
            (n.colorsNeedUpdate = e.colorsNeedUpdate),
            (n.uvsNeedUpdate = e.uvsNeedUpdate),
            (n.groupsNeedUpdate = e.groupsNeedUpdate),
            (e.verticesNeedUpdate = !1),
            (e.normalsNeedUpdate = !1),
            (e.colorsNeedUpdate = !1),
            (e.uvsNeedUpdate = !1),
            (e.groupsNeedUpdate = !1),
            (e = n);
        }
        var i;
        return (
          !0 === e.verticesNeedUpdate &&
            (void 0 !== (i = this.attributes.position) &&
              (i.copyVector3sArray(e.vertices), (i.needsUpdate = !0)),
            (e.verticesNeedUpdate = !1)),
          !0 === e.normalsNeedUpdate &&
            (void 0 !== (i = this.attributes.normal) &&
              (i.copyVector3sArray(e.normals), (i.needsUpdate = !0)),
            (e.normalsNeedUpdate = !1)),
          !0 === e.colorsNeedUpdate &&
            (void 0 !== (i = this.attributes.color) &&
              (i.copyColorsArray(e.colors), (i.needsUpdate = !0)),
            (e.colorsNeedUpdate = !1)),
          e.uvsNeedUpdate &&
            (void 0 !== (i = this.attributes.uv) &&
              (i.copyVector2sArray(e.uvs), (i.needsUpdate = !0)),
            (e.uvsNeedUpdate = !1)),
          e.lineDistancesNeedUpdate &&
            (void 0 !== (i = this.attributes.lineDistance) &&
              (i.copyArray(e.lineDistances), (i.needsUpdate = !0)),
            (e.lineDistancesNeedUpdate = !1)),
          e.groupsNeedUpdate &&
            (e.computeGroups(t.geometry),
            (this.groups = e.groups),
            (e.groupsNeedUpdate = !1)),
          this
        );
      },
      fromGeometry: function (t) {
        return (
          (t.__directGeometry = new _t().fromGeometry(t)),
          this.fromDirectGeometry(t.__directGeometry)
        );
      },
      fromDirectGeometry: function (t) {
        var e = new Float32Array(3 * t.vertices.length);
        if (
          (this.addAttribute(
            "position",
            new ht(e, 3).copyVector3sArray(t.vertices)
          ),
          t.normals.length > 0)
        ) {
          var n = new Float32Array(3 * t.normals.length);
          this.addAttribute(
            "normal",
            new ht(n, 3).copyVector3sArray(t.normals)
          );
        }
        if (t.colors.length > 0) {
          var i = new Float32Array(3 * t.colors.length);
          this.addAttribute("color", new ht(i, 3).copyColorsArray(t.colors));
        }
        if (t.uvs.length > 0) {
          var r = new Float32Array(2 * t.uvs.length);
          this.addAttribute("uv", new ht(r, 2).copyVector2sArray(t.uvs));
        }
        if (t.uvs2.length > 0) {
          var o = new Float32Array(2 * t.uvs2.length);
          this.addAttribute("uv2", new ht(o, 2).copyVector2sArray(t.uvs2));
        }
        if (t.indices.length > 0) {
          var a = new (wt(t.indices) > 65535 ? Uint32Array : Uint16Array)(
            3 * t.indices.length
          );
          this.setIndex(new ht(a, 1).copyIndicesArray(t.indices));
        }
        this.groups = t.groups;
        for (var s in t.morphTargets) {
          for (
            var c = [], l = t.morphTargets[s], u = 0, h = l.length;
            u < h;
            u++
          ) {
            var p = l[u],
              d = new xt(3 * p.length, 3);
            c.push(d.copyVector3sArray(p));
          }
          this.morphAttributes[s] = c;
        }
        if (t.skinIndices.length > 0) {
          var f = new xt(4 * t.skinIndices.length, 4);
          this.addAttribute("skinIndex", f.copyVector4sArray(t.skinIndices));
        }
        if (t.skinWeights.length > 0) {
          var m = new xt(4 * t.skinWeights.length, 4);
          this.addAttribute("skinWeight", m.copyVector4sArray(t.skinWeights));
        }
        return (
          null !== t.boundingSphere &&
            (this.boundingSphere = t.boundingSphere.clone()),
          null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
          this
        );
      },
      computeBoundingBox: function () {
        null === this.boundingBox && (this.boundingBox = new K());
        var t = this.attributes.position;
        void 0 !== t
          ? this.boundingBox.setFromBufferAttribute(t)
          : this.boundingBox.makeEmpty(),
          (isNaN(this.boundingBox.min.x) ||
            isNaN(this.boundingBox.min.y) ||
            isNaN(this.boundingBox.min.z)) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
              this
            );
      },
      computeBoundingSphere: (function () {
        var t = new K(),
          e = new o();
        return function () {
          null === this.boundingSphere && (this.boundingSphere = new tt());
          var n = this.attributes.position;
          if (n) {
            var i = this.boundingSphere.center;
            t.setFromBufferAttribute(n), t.getCenter(i);
            for (var r = 0, o = 0, a = n.count; o < a; o++)
              (e.x = n.getX(o)),
                (e.y = n.getY(o)),
                (e.z = n.getZ(o)),
                (r = Math.max(r, i.distanceToSquared(e)));
            (this.boundingSphere.radius = Math.sqrt(r)),
              isNaN(this.boundingSphere.radius) &&
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                  this
                );
          }
        };
      })(),
      computeFaceNormals: function () {},
      computeVertexNormals: function () {
        var t = this.index,
          e = this.attributes,
          n = this.groups;
        if (e.position) {
          var i = e.position.array;
          if (void 0 === e.normal)
            this.addAttribute("normal", new ht(new Float32Array(i.length), 3));
          else
            for (var r = e.normal.array, a = 0, s = r.length; a < s; a++)
              r[a] = 0;
          var c,
            l,
            u,
            h = e.normal.array,
            p = new o(),
            d = new o(),
            f = new o(),
            m = new o(),
            g = new o();
          if (t) {
            var v = t.array;
            0 === n.length && this.addGroup(0, v.length);
            for (var y = 0, x = n.length; y < x; ++y)
              for (
                var b = n[y], _ = b.start, a = _, s = _ + b.count;
                a < s;
                a += 3
              )
                (c = 3 * v[a + 0]),
                  (l = 3 * v[a + 1]),
                  (u = 3 * v[a + 2]),
                  p.fromArray(i, c),
                  d.fromArray(i, l),
                  f.fromArray(i, u),
                  m.subVectors(f, d),
                  g.subVectors(p, d),
                  m.cross(g),
                  (h[c] += m.x),
                  (h[c + 1] += m.y),
                  (h[c + 2] += m.z),
                  (h[l] += m.x),
                  (h[l + 1] += m.y),
                  (h[l + 2] += m.z),
                  (h[u] += m.x),
                  (h[u + 1] += m.y),
                  (h[u + 2] += m.z);
          } else
            for (var a = 0, s = i.length; a < s; a += 9)
              p.fromArray(i, a),
                d.fromArray(i, a + 3),
                f.fromArray(i, a + 6),
                m.subVectors(f, d),
                g.subVectors(p, d),
                m.cross(g),
                (h[a] = m.x),
                (h[a + 1] = m.y),
                (h[a + 2] = m.z),
                (h[a + 3] = m.x),
                (h[a + 4] = m.y),
                (h[a + 5] = m.z),
                (h[a + 6] = m.x),
                (h[a + 7] = m.y),
                (h[a + 8] = m.z);
          this.normalizeNormals(), (e.normal.needsUpdate = !0);
        }
      },
      merge: function (t, e) {
        if (t && t.isBufferGeometry) {
          void 0 === e && (e = 0);
          var n = this.attributes;
          for (var i in n)
            if (void 0 !== t.attributes[i])
              for (
                var r = n[i].array,
                  o = t.attributes[i],
                  a = o.array,
                  s = 0,
                  c = o.itemSize * e;
                s < a.length;
                s++, c++
              )
                r[c] = a[s];
          return this;
        }
        console.error(
          "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
          t
        );
      },
      normalizeNormals: (function () {
        var t = new o();
        return function () {
          for (var e = this.attributes.normal, n = 0, i = e.count; n < i; n++)
            (t.x = e.getX(n)),
              (t.y = e.getY(n)),
              (t.z = e.getZ(n)),
              t.normalize(),
              e.setXYZ(n, t.x, t.y, t.z);
        };
      })(),
      toNonIndexed: function () {
        if (null === this.index)
          return (
            console.warn(
              "THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."
            ),
            this
          );
        var t = new Mt(),
          e = this.index.array,
          n = this.attributes;
        for (var i in n) {
          for (
            var r = n[i],
              o = r.array,
              a = r.itemSize,
              s = new o.constructor(e.length * a),
              c = 0,
              l = 0,
              u = 0,
              h = e.length;
            u < h;
            u++
          ) {
            c = e[u] * a;
            for (var p = 0; p < a; p++) s[l++] = o[c++];
          }
          t.addAttribute(i, new ht(s, a));
        }
        return t;
      },
      toJSON: function () {
        var t = {
          metadata: {
            version: 4.5,
            type: "BufferGeometry",
            generator: "BufferGeometry.toJSON",
          },
        };
        if (
          ((t.uuid = this.uuid),
          (t.type = this.type),
          "" !== this.name && (t.name = this.name),
          void 0 !== this.parameters)
        ) {
          var e = this.parameters;
          for (var n in e) void 0 !== e[n] && (t[n] = e[n]);
          return t;
        }
        t.data = { attributes: {} };
        var i = this.index;
        null !== i &&
          ((a = Array.prototype.slice.call(i.array)),
          (t.data.index = { type: i.array.constructor.name, array: a }));
        var r = this.attributes;
        for (var n in r) {
          var o = r[n],
            a = Array.prototype.slice.call(o.array);
          t.data.attributes[n] = {
            itemSize: o.itemSize,
            type: o.array.constructor.name,
            array: a,
            normalized: o.normalized,
          };
        }
        var s = this.groups;
        s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
        var c = this.boundingSphere;
        return (
          null !== c &&
            (t.data.boundingSphere = {
              center: c.center.toArray(),
              radius: c.radius,
            }),
          t
        );
      },
      clone: function () {
        return new Mt().copy(this);
      },
      copy: function (t) {
        var e, n, i;
        (this.index = null),
          (this.attributes = {}),
          (this.morphAttributes = {}),
          (this.groups = []),
          (this.boundingBox = null),
          (this.boundingSphere = null),
          (this.name = t.name);
        var r = t.index;
        null !== r && this.setIndex(r.clone());
        var o = t.attributes;
        for (e in o) {
          var a = o[e];
          this.addAttribute(e, a.clone());
        }
        var s = t.morphAttributes;
        for (e in s) {
          var c = [],
            l = s[e];
          for (n = 0, i = l.length; n < i; n++) c.push(l[n].clone());
          this.morphAttributes[e] = c;
        }
        var u = t.groups;
        for (n = 0, i = u.length; n < i; n++) {
          var h = u[n];
          this.addGroup(h.start, h.count, h.materialIndex);
        }
        var p = t.boundingBox;
        null !== p && (this.boundingBox = p.clone());
        var d = t.boundingSphere;
        return (
          null !== d && (this.boundingSphere = d.clone()),
          (this.drawRange.start = t.drawRange.start),
          (this.drawRange.count = t.drawRange.count),
          this
        );
      },
      dispose: function () {
        this.dispatchEvent({ type: "dispose" });
      },
    }),
      ((Et.prototype = Object.create(ut.prototype)).constructor = Et),
      ((Tt.prototype = Object.create(Mt.prototype)).constructor = Tt),
      ((St.prototype = Object.create(ut.prototype)).constructor = St),
      ((At.prototype = Object.create(Mt.prototype)).constructor = At),
      ((Lt.prototype = Object.create(Z.prototype)).constructor = Lt),
      (Lt.prototype.isMeshBasicMaterial = !0),
      (Lt.prototype.copy = function (t) {
        return (
          Z.prototype.copy.call(this, t),
          this.color.copy(t.color),
          (this.map = t.map),
          (this.lightMap = t.lightMap),
          (this.lightMapIntensity = t.lightMapIntensity),
          (this.aoMap = t.aoMap),
          (this.aoMapIntensity = t.aoMapIntensity),
          (this.specularMap = t.specularMap),
          (this.alphaMap = t.alphaMap),
          (this.envMap = t.envMap),
          (this.combine = t.combine),
          (this.reflectivity = t.reflectivity),
          (this.refractionRatio = t.refractionRatio),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.wireframeLinecap = t.wireframeLinecap),
          (this.wireframeLinejoin = t.wireframeLinejoin),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          this
        );
      }),
      ((Rt.prototype = Object.create(Z.prototype)).constructor = Rt),
      (Rt.prototype.isShaderMaterial = !0),
      (Rt.prototype.copy = function (t) {
        return (
          Z.prototype.copy.call(this, t),
          (this.fragmentShader = t.fragmentShader),
          (this.vertexShader = t.vertexShader),
          (this.uniforms = ya.clone(t.uniforms)),
          (this.defines = t.defines),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.lights = t.lights),
          (this.clipping = t.clipping),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.morphNormals = t.morphNormals),
          (this.extensions = t.extensions),
          this
        );
      }),
      (Rt.prototype.toJSON = function (t) {
        var e = Z.prototype.toJSON.call(this, t);
        return (
          (e.uniforms = this.uniforms),
          (e.vertexShader = this.vertexShader),
          (e.fragmentShader = this.fragmentShader),
          e
        );
      }),
      Object.assign(Pt.prototype, {
        set: function (t, e) {
          return this.origin.copy(t), this.direction.copy(e), this;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          return (
            this.origin.copy(t.origin), this.direction.copy(t.direction), this
          );
        },
        at: function (t, e) {
          return (e || new o())
            .copy(this.direction)
            .multiplyScalar(t)
            .add(this.origin);
        },
        lookAt: function (t) {
          return this.direction.copy(t).sub(this.origin).normalize(), this;
        },
        recast: (function () {
          var t = new o();
          return function (e) {
            return this.origin.copy(this.at(e, t)), this;
          };
        })(),
        closestPointToPoint: function (t, e) {
          var n = e || new o();
          n.subVectors(t, this.origin);
          var i = n.dot(this.direction);
          return i < 0
            ? n.copy(this.origin)
            : n.copy(this.direction).multiplyScalar(i).add(this.origin);
        },
        distanceToPoint: function (t) {
          return Math.sqrt(this.distanceSqToPoint(t));
        },
        distanceSqToPoint: (function () {
          var t = new o();
          return function (e) {
            var n = t.subVectors(e, this.origin).dot(this.direction);
            return n < 0
              ? this.origin.distanceToSquared(e)
              : (t.copy(this.direction).multiplyScalar(n).add(this.origin),
                t.distanceToSquared(e));
          };
        })(),
        distanceSqToSegment: (function () {
          var t = new o(),
            e = new o(),
            n = new o();
          return function (i, r, o, a) {
            t.copy(i).add(r).multiplyScalar(0.5),
              e.copy(r).sub(i).normalize(),
              n.copy(this.origin).sub(t);
            var s,
              c,
              l,
              u,
              h = 0.5 * i.distanceTo(r),
              p = -this.direction.dot(e),
              d = n.dot(this.direction),
              f = -n.dot(e),
              m = n.lengthSq(),
              g = Math.abs(1 - p * p);
            if (g > 0)
              if (((s = p * f - d), (c = p * d - f), (u = h * g), s >= 0))
                if (c >= -u)
                  if (c <= u) {
                    var v = 1 / g;
                    l =
                      (s *= v) * (s + p * (c *= v) + 2 * d) +
                      c * (p * s + c + 2 * f) +
                      m;
                  } else
                    (c = h),
                      (l =
                        -(s = Math.max(0, -(p * c + d))) * s +
                        c * (c + 2 * f) +
                        m);
                else
                  (c = -h),
                    (l =
                      -(s = Math.max(0, -(p * c + d))) * s +
                      c * (c + 2 * f) +
                      m);
              else
                c <= -u
                  ? (l =
                      -(s = Math.max(0, -(-p * h + d))) * s +
                      (c = s > 0 ? -h : Math.min(Math.max(-h, -f), h)) *
                        (c + 2 * f) +
                      m)
                  : c <= u
                  ? ((s = 0),
                    (l = (c = Math.min(Math.max(-h, -f), h)) * (c + 2 * f) + m))
                  : (l =
                      -(s = Math.max(0, -(p * h + d))) * s +
                      (c = s > 0 ? h : Math.min(Math.max(-h, -f), h)) *
                        (c + 2 * f) +
                      m);
            else
              (c = p > 0 ? -h : h),
                (l =
                  -(s = Math.max(0, -(p * c + d))) * s + c * (c + 2 * f) + m);
            return (
              o && o.copy(this.direction).multiplyScalar(s).add(this.origin),
              a && a.copy(e).multiplyScalar(c).add(t),
              l
            );
          };
        })(),
        intersectSphere: (function () {
          var t = new o();
          return function (e, n) {
            t.subVectors(e.center, this.origin);
            var i = t.dot(this.direction),
              r = t.dot(t) - i * i,
              o = e.radius * e.radius;
            if (r > o) return null;
            var a = Math.sqrt(o - r),
              s = i - a,
              c = i + a;
            return s < 0 && c < 0
              ? null
              : s < 0
              ? this.at(c, n)
              : this.at(s, n);
          };
        })(),
        intersectsSphere: function (t) {
          return this.distanceToPoint(t.center) <= t.radius;
        },
        distanceToPlane: function (t) {
          var e = t.normal.dot(this.direction);
          if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
          var n = -(this.origin.dot(t.normal) + t.constant) / e;
          return n >= 0 ? n : null;
        },
        intersectPlane: function (t, e) {
          var n = this.distanceToPlane(t);
          return null === n ? null : this.at(n, e);
        },
        intersectsPlane: function (t) {
          var e = t.distanceToPoint(this.origin);
          return 0 === e || t.normal.dot(this.direction) * e < 0;
        },
        intersectBox: function (t, e) {
          var n,
            i,
            r,
            o,
            a,
            s,
            c = 1 / this.direction.x,
            l = 1 / this.direction.y,
            u = 1 / this.direction.z,
            h = this.origin;
          return (
            c >= 0
              ? ((n = (t.min.x - h.x) * c), (i = (t.max.x - h.x) * c))
              : ((n = (t.max.x - h.x) * c), (i = (t.min.x - h.x) * c)),
            l >= 0
              ? ((r = (t.min.y - h.y) * l), (o = (t.max.y - h.y) * l))
              : ((r = (t.max.y - h.y) * l), (o = (t.min.y - h.y) * l)),
            n > o || r > i
              ? null
              : ((r > n || n != n) && (n = r),
                (o < i || i != i) && (i = o),
                u >= 0
                  ? ((a = (t.min.z - h.z) * u), (s = (t.max.z - h.z) * u))
                  : ((a = (t.max.z - h.z) * u), (s = (t.min.z - h.z) * u)),
                n > s || a > i
                  ? null
                  : ((a > n || n != n) && (n = a),
                    (s < i || i != i) && (i = s),
                    i < 0 ? null : this.at(n >= 0 ? n : i, e)))
          );
        },
        intersectsBox: (function () {
          var t = new o();
          return function (e) {
            return null !== this.intersectBox(e, t);
          };
        })(),
        intersectTriangle: (function () {
          var t = new o(),
            e = new o(),
            n = new o(),
            i = new o();
          return function (r, o, a, s, c) {
            e.subVectors(o, r), n.subVectors(a, r), i.crossVectors(e, n);
            var l,
              u = this.direction.dot(i);
            if (u > 0) {
              if (s) return null;
              l = 1;
            } else {
              if (!(u < 0)) return null;
              (l = -1), (u = -u);
            }
            t.subVectors(this.origin, r);
            var h = l * this.direction.dot(n.crossVectors(t, n));
            if (h < 0) return null;
            var p = l * this.direction.dot(e.cross(t));
            if (p < 0) return null;
            if (h + p > u) return null;
            var d = -l * t.dot(i);
            return d < 0 ? null : this.at(d / u, c);
          };
        })(),
        applyMatrix4: function (t) {
          return (
            this.origin.applyMatrix4(t),
            this.direction.transformDirection(t),
            this
          );
        },
        equals: function (t) {
          return (
            t.origin.equals(this.origin) && t.direction.equals(this.direction)
          );
        },
      }),
      Object.assign(Ct.prototype, {
        set: function (t, e) {
          return this.start.copy(t), this.end.copy(e), this;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          return this.start.copy(t.start), this.end.copy(t.end), this;
        },
        getCenter: function (t) {
          return (t || new o())
            .addVectors(this.start, this.end)
            .multiplyScalar(0.5);
        },
        delta: function (t) {
          return (t || new o()).subVectors(this.end, this.start);
        },
        distanceSq: function () {
          return this.start.distanceToSquared(this.end);
        },
        distance: function () {
          return this.start.distanceTo(this.end);
        },
        at: function (t, e) {
          var n = e || new o();
          return this.delta(n).multiplyScalar(t).add(this.start);
        },
        closestPointToPointParameter: (function () {
          var t = new o(),
            e = new o();
          return function (n, i) {
            t.subVectors(n, this.start), e.subVectors(this.end, this.start);
            var r = e.dot(e),
              o = e.dot(t) / r;
            return i && (o = sa.clamp(o, 0, 1)), o;
          };
        })(),
        closestPointToPoint: function (t, e, n) {
          var i = this.closestPointToPointParameter(t, e),
            r = n || new o();
          return this.delta(r).multiplyScalar(i).add(this.start);
        },
        applyMatrix4: function (t) {
          return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
        },
        equals: function (t) {
          return t.start.equals(this.start) && t.end.equals(this.end);
        },
      }),
      Object.assign(Ot, {
        normal: (function () {
          var t = new o();
          return function (e, n, i, r) {
            var a = r || new o();
            a.subVectors(i, n), t.subVectors(e, n), a.cross(t);
            var s = a.lengthSq();
            return s > 0 ? a.multiplyScalar(1 / Math.sqrt(s)) : a.set(0, 0, 0);
          };
        })(),
        barycoordFromPoint: (function () {
          var t = new o(),
            e = new o(),
            n = new o();
          return function (i, r, a, s, c) {
            t.subVectors(s, r), e.subVectors(a, r), n.subVectors(i, r);
            var l = t.dot(t),
              u = t.dot(e),
              h = t.dot(n),
              p = e.dot(e),
              d = e.dot(n),
              f = l * p - u * u,
              m = c || new o();
            if (0 === f) return m.set(-2, -1, -1);
            var g = 1 / f,
              v = (p * h - u * d) * g,
              y = (l * d - u * h) * g;
            return m.set(1 - v - y, y, v);
          };
        })(),
        containsPoint: (function () {
          var t = new o();
          return function (e, n, i, r) {
            var o = Ot.barycoordFromPoint(e, n, i, r, t);
            return o.x >= 0 && o.y >= 0 && o.x + o.y <= 1;
          };
        })(),
      }),
      Object.assign(Ot.prototype, {
        set: function (t, e, n) {
          return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
        },
        setFromPointsAndIndices: function (t, e, n, i) {
          return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
        },
        area: (function () {
          var t = new o(),
            e = new o();
          return function () {
            return (
              t.subVectors(this.c, this.b),
              e.subVectors(this.a, this.b),
              0.5 * t.cross(e).length()
            );
          };
        })(),
        midpoint: function (t) {
          return (t || new o())
            .addVectors(this.a, this.b)
            .add(this.c)
            .multiplyScalar(1 / 3);
        },
        normal: function (t) {
          return Ot.normal(this.a, this.b, this.c, t);
        },
        plane: function (t) {
          return (t || new et()).setFromCoplanarPoints(this.a, this.b, this.c);
        },
        barycoordFromPoint: function (t, e) {
          return Ot.barycoordFromPoint(t, this.a, this.b, this.c, e);
        },
        containsPoint: function (t) {
          return Ot.containsPoint(t, this.a, this.b, this.c);
        },
        closestPointToPoint: (function () {
          var t = new et(),
            e = [new Ct(), new Ct(), new Ct()],
            n = new o(),
            i = new o();
          return function (r, a) {
            var s = a || new o(),
              c = 1 / 0;
            if (
              (t.setFromCoplanarPoints(this.a, this.b, this.c),
              t.projectPoint(r, n),
              !0 === this.containsPoint(n))
            )
              s.copy(n);
            else {
              e[0].set(this.a, this.b),
                e[1].set(this.b, this.c),
                e[2].set(this.c, this.a);
              for (var l = 0; l < e.length; l++) {
                e[l].closestPointToPoint(n, !0, i);
                var u = n.distanceToSquared(i);
                u < c && ((c = u), s.copy(i));
              }
            }
            return s;
          };
        })(),
        equals: function (t) {
          return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
        },
      }),
      (It.prototype = Object.assign(Object.create(at.prototype), {
        constructor: It,
        isMesh: !0,
        setDrawMode: function (t) {
          this.drawMode = t;
        },
        copy: function (t) {
          return (
            at.prototype.copy.call(this, t),
            (this.drawMode = t.drawMode),
            void 0 !== t.morphTargetInfluences &&
              (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
            void 0 !== t.morphTargetDictionary &&
              (this.morphTargetDictionary = Object.assign(
                {},
                t.morphTargetDictionary
              )),
            this
          );
        },
        updateMorphTargets: function () {
          var t,
            e,
            n,
            i = this.geometry;
          if (i.isBufferGeometry) {
            var r = i.morphAttributes,
              o = Object.keys(r);
            if (o.length > 0) {
              var a = r[o[0]];
              if (void 0 !== a)
                for (
                  this.morphTargetInfluences = [],
                    this.morphTargetDictionary = {},
                    t = 0,
                    e = a.length;
                  t < e;
                  t++
                )
                  (n = a[t].name || String(t)),
                    this.morphTargetInfluences.push(0),
                    (this.morphTargetDictionary[n] = t);
            }
          } else {
            var s = i.morphTargets;
            if (void 0 !== s && s.length > 0)
              for (
                this.morphTargetInfluences = [],
                  this.morphTargetDictionary = {},
                  t = 0,
                  e = s.length;
                t < e;
                t++
              )
                (n = s[t].name || String(t)),
                  this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[n] = t);
          }
        },
        raycast: (function () {
          function t(t, e, n, i, r, o, a) {
            return (
              Ot.barycoordFromPoint(t, e, n, i, y),
              r.multiplyScalar(y.x),
              o.multiplyScalar(y.y),
              a.multiplyScalar(y.z),
              r.add(o).add(a),
              r.clone()
            );
          }
          function e(t, e, n, i, r, o, a, s) {
            if (
              null ===
              (e.side === dr
                ? i.intersectTriangle(a, o, r, !0, s)
                : i.intersectTriangle(r, o, a, e.side !== fr, s))
            )
              return null;
            b.copy(s), b.applyMatrix4(t.matrixWorld);
            var c = n.ray.origin.distanceTo(b);
            return c < n.near || c > n.far
              ? null
              : { distance: c, point: b.clone(), object: t };
          }
          function r(n, i, r, o, a, s, c, p) {
            l.fromBufferAttribute(o, s),
              u.fromBufferAttribute(o, c),
              h.fromBufferAttribute(o, p);
            var d = e(n, n.material, i, r, l, u, h, x);
            return (
              d &&
                (a &&
                  (m.fromBufferAttribute(a, s),
                  g.fromBufferAttribute(a, c),
                  v.fromBufferAttribute(a, p),
                  (d.uv = t(x, l, u, h, m, g, v))),
                (d.face = new lt(s, c, p, Ot.normal(l, u, h))),
                (d.faceIndex = s)),
              d
            );
          }
          var a = new i(),
            s = new Pt(),
            c = new tt(),
            l = new o(),
            u = new o(),
            h = new o(),
            p = new o(),
            d = new o(),
            f = new o(),
            m = new n(),
            g = new n(),
            v = new n(),
            y = new o(),
            x = new o(),
            b = new o();
          return function (n, i) {
            var o = this.geometry,
              y = this.material,
              b = this.matrixWorld;
            if (
              void 0 !== y &&
              (null === o.boundingSphere && o.computeBoundingSphere(),
              c.copy(o.boundingSphere),
              c.applyMatrix4(b),
              !1 !== n.ray.intersectsSphere(c) &&
                (a.getInverse(b),
                s.copy(n.ray).applyMatrix4(a),
                null === o.boundingBox ||
                  !1 !== s.intersectsBox(o.boundingBox)))
            ) {
              var _;
              if (o.isBufferGeometry) {
                var w,
                  M,
                  E,
                  T,
                  S,
                  A = o.index,
                  L = o.attributes.position,
                  R = o.attributes.uv;
                if (null !== A)
                  for (T = 0, S = A.count; T < S; T += 3)
                    (w = A.getX(T)),
                      (M = A.getX(T + 1)),
                      (E = A.getX(T + 2)),
                      (_ = r(this, n, s, L, R, w, M, E)) &&
                        ((_.faceIndex = Math.floor(T / 3)), i.push(_));
                else if (void 0 !== L)
                  for (T = 0, S = L.count; T < S; T += 3)
                    (_ = r(
                      this,
                      n,
                      s,
                      L,
                      R,
                      (w = T),
                      (M = T + 1),
                      (E = T + 2)
                    )) && ((_.index = w), i.push(_));
              } else if (o.isGeometry) {
                var P,
                  C,
                  O,
                  I,
                  D = Array.isArray(y),
                  U = o.vertices,
                  N = o.faces,
                  z = o.faceVertexUvs[0];
                z.length > 0 && (I = z);
                for (var k = 0, F = N.length; k < F; k++) {
                  var B = N[k],
                    H = D ? y[B.materialIndex] : y;
                  if (void 0 !== H) {
                    if (
                      ((P = U[B.a]),
                      (C = U[B.b]),
                      (O = U[B.c]),
                      !0 === H.morphTargets)
                    ) {
                      var j = o.morphTargets,
                        G = this.morphTargetInfluences;
                      l.set(0, 0, 0), u.set(0, 0, 0), h.set(0, 0, 0);
                      for (var V = 0, W = j.length; V < W; V++) {
                        var X = G[V];
                        if (0 !== X) {
                          var Y = j[V].vertices;
                          l.addScaledVector(p.subVectors(Y[B.a], P), X),
                            u.addScaledVector(d.subVectors(Y[B.b], C), X),
                            h.addScaledVector(f.subVectors(Y[B.c], O), X);
                        }
                      }
                      l.add(P), u.add(C), h.add(O), (P = l), (C = u), (O = h);
                    }
                    if ((_ = e(this, H, n, s, P, C, O, x))) {
                      if (I && I[k]) {
                        var q = I[k];
                        m.copy(q[0]),
                          g.copy(q[1]),
                          v.copy(q[2]),
                          (_.uv = t(x, P, C, O, m, g, v));
                      }
                      (_.face = B), (_.faceIndex = k), i.push(_);
                    }
                  }
                }
              }
            }
          };
        })(),
        clone: function () {
          return new this.constructor(this.geometry, this.material).copy(this);
        },
      }));
    var Ta = 0;
    (Xt.prototype = Object.assign(Object.create(st.prototype), {
      constructor: Xt,
      isPerspectiveCamera: !0,
      copy: function (t, e) {
        return (
          st.prototype.copy.call(this, t, e),
          (this.fov = t.fov),
          (this.zoom = t.zoom),
          (this.near = t.near),
          (this.far = t.far),
          (this.focus = t.focus),
          (this.aspect = t.aspect),
          (this.view = null === t.view ? null : Object.assign({}, t.view)),
          (this.filmGauge = t.filmGauge),
          (this.filmOffset = t.filmOffset),
          this
        );
      },
      setFocalLength: function (t) {
        var e = (0.5 * this.getFilmHeight()) / t;
        (this.fov = 2 * sa.RAD2DEG * Math.atan(e)),
          this.updateProjectionMatrix();
      },
      getFocalLength: function () {
        var t = Math.tan(0.5 * sa.DEG2RAD * this.fov);
        return (0.5 * this.getFilmHeight()) / t;
      },
      getEffectiveFOV: function () {
        return (
          2 *
          sa.RAD2DEG *
          Math.atan(Math.tan(0.5 * sa.DEG2RAD * this.fov) / this.zoom)
        );
      },
      getFilmWidth: function () {
        return this.filmGauge * Math.min(this.aspect, 1);
      },
      getFilmHeight: function () {
        return this.filmGauge / Math.max(this.aspect, 1);
      },
      setViewOffset: function (t, e, n, i, r, o) {
        (this.aspect = t / e),
          null === this.view &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
          (this.view.enabled = !0),
          (this.view.fullWidth = t),
          (this.view.fullHeight = e),
          (this.view.offsetX = n),
          (this.view.offsetY = i),
          (this.view.width = r),
          (this.view.height = o),
          this.updateProjectionMatrix();
      },
      clearViewOffset: function () {
        null !== this.view && (this.view.enabled = !1),
          this.updateProjectionMatrix();
      },
      updateProjectionMatrix: function () {
        var t = this.near,
          e = (t * Math.tan(0.5 * sa.DEG2RAD * this.fov)) / this.zoom,
          n = 2 * e,
          i = this.aspect * n,
          r = -0.5 * i,
          o = this.view;
        if (null !== this.view && this.view.enabled) {
          var a = o.fullWidth,
            s = o.fullHeight;
          (r += (o.offsetX * i) / a),
            (e -= (o.offsetY * n) / s),
            (i *= o.width / a),
            (n *= o.height / s);
        }
        var c = this.filmOffset;
        0 !== c && (r += (t * c) / this.getFilmWidth()),
          this.projectionMatrix.makePerspective(
            r,
            r + i,
            e,
            e - n,
            t,
            this.far
          );
      },
      toJSON: function (t) {
        var e = at.prototype.toJSON.call(this, t);
        return (
          (e.object.fov = this.fov),
          (e.object.zoom = this.zoom),
          (e.object.near = this.near),
          (e.object.far = this.far),
          (e.object.focus = this.focus),
          (e.object.aspect = this.aspect),
          null !== this.view && (e.object.view = Object.assign({}, this.view)),
          (e.object.filmGauge = this.filmGauge),
          (e.object.filmOffset = this.filmOffset),
          e
        );
      },
    })),
      (Yt.prototype = Object.assign(Object.create(Xt.prototype), {
        constructor: Yt,
        isArrayCamera: !0,
      })),
      (Zt.prototype.isFogExp2 = !0),
      (Zt.prototype.clone = function () {
        return new Zt(this.color.getHex(), this.density);
      }),
      (Zt.prototype.toJSON = function () {
        return {
          type: "FogExp2",
          color: this.color.getHex(),
          density: this.density,
        };
      }),
      (Jt.prototype.isFog = !0),
      (Jt.prototype.clone = function () {
        return new Jt(this.color.getHex(), this.near, this.far);
      }),
      (Jt.prototype.toJSON = function () {
        return {
          type: "Fog",
          color: this.color.getHex(),
          near: this.near,
          far: this.far,
        };
      }),
      (Qt.prototype = Object.assign(Object.create(at.prototype), {
        constructor: Qt,
        copy: function (t, e) {
          return (
            at.prototype.copy.call(this, t, e),
            null !== t.background && (this.background = t.background.clone()),
            null !== t.fog && (this.fog = t.fog.clone()),
            null !== t.overrideMaterial &&
              (this.overrideMaterial = t.overrideMaterial.clone()),
            (this.autoUpdate = t.autoUpdate),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            this
          );
        },
        toJSON: function (t) {
          var e = at.prototype.toJSON.call(this, t);
          return (
            null !== this.background &&
              (e.object.background = this.background.toJSON(t)),
            null !== this.fog && (e.object.fog = this.fog.toJSON()),
            e
          );
        },
      })),
      (Kt.prototype = Object.assign(Object.create(at.prototype), {
        constructor: Kt,
        isLensFlare: !0,
        copy: function (t) {
          at.prototype.copy.call(this, t),
            this.positionScreen.copy(t.positionScreen),
            (this.customUpdateCallback = t.customUpdateCallback);
          for (var e = 0, n = t.lensFlares.length; e < n; e++)
            this.lensFlares.push(t.lensFlares[e]);
          return this;
        },
        add: function (t, e, n, i, r, o) {
          void 0 === e && (e = -1),
            void 0 === n && (n = 0),
            void 0 === o && (o = 1),
            void 0 === r && (r = new W(16777215)),
            void 0 === i && (i = xr),
            (n = Math.min(n, Math.max(0, n))),
            this.lensFlares.push({
              texture: t,
              size: e,
              distance: n,
              x: 0,
              y: 0,
              z: 0,
              scale: 1,
              rotation: 0,
              opacity: o,
              color: r,
              blending: i,
            });
        },
        updateLensFlares: function () {
          var t,
            e,
            n = this.lensFlares.length,
            i = 2 * -this.positionScreen.x,
            r = 2 * -this.positionScreen.y;
          for (t = 0; t < n; t++)
            ((e = this.lensFlares[t]).x =
              this.positionScreen.x + i * e.distance),
              (e.y = this.positionScreen.y + r * e.distance),
              (e.wantedRotation = e.x * Math.PI * 0.25),
              (e.rotation += 0.25 * (e.wantedRotation - e.rotation));
        },
      })),
      ((te.prototype = Object.create(Z.prototype)).constructor = te),
      (te.prototype.isSpriteMaterial = !0),
      (te.prototype.copy = function (t) {
        return (
          Z.prototype.copy.call(this, t),
          this.color.copy(t.color),
          (this.map = t.map),
          (this.rotation = t.rotation),
          this
        );
      }),
      (ee.prototype = Object.assign(Object.create(at.prototype), {
        constructor: ee,
        isSprite: !0,
        raycast: (function () {
          var t = new o(),
            e = new o(),
            n = new o();
          return function (i, r) {
            e.setFromMatrixPosition(this.matrixWorld),
              i.ray.closestPointToPoint(e, t),
              n.setFromMatrixScale(this.matrixWorld);
            var o = (n.x * n.y) / 4;
            if (!(e.distanceToSquared(t) > o)) {
              var a = i.ray.origin.distanceTo(t);
              a < i.near ||
                a > i.far ||
                r.push({
                  distance: a,
                  point: t.clone(),
                  face: null,
                  object: this,
                });
            }
          };
        })(),
        clone: function () {
          return new this.constructor(this.material).copy(this);
        },
      })),
      (ne.prototype = Object.assign(Object.create(at.prototype), {
        constructor: ne,
        copy: function (t) {
          at.prototype.copy.call(this, t, !1);
          for (var e = t.levels, n = 0, i = e.length; n < i; n++) {
            var r = e[n];
            this.addLevel(r.object.clone(), r.distance);
          }
          return this;
        },
        addLevel: function (t, e) {
          void 0 === e && (e = 0), (e = Math.abs(e));
          for (
            var n = this.levels, i = 0;
            i < n.length && !(e < n[i].distance);
            i++
          );
          n.splice(i, 0, { distance: e, object: t }), this.add(t);
        },
        getObjectForDistance: function (t) {
          for (
            var e = this.levels, n = 1, i = e.length;
            n < i && !(t < e[n].distance);
            n++
          );
          return e[n - 1].object;
        },
        raycast: (function () {
          var t = new o();
          return function (e, n) {
            t.setFromMatrixPosition(this.matrixWorld);
            var i = e.ray.origin.distanceTo(t);
            this.getObjectForDistance(i).raycast(e, n);
          };
        })(),
        update: (function () {
          var t = new o(),
            e = new o();
          return function (n) {
            var i = this.levels;
            if (i.length > 1) {
              t.setFromMatrixPosition(n.matrixWorld),
                e.setFromMatrixPosition(this.matrixWorld);
              var r = t.distanceTo(e);
              i[0].object.visible = !0;
              for (var o = 1, a = i.length; o < a && r >= i[o].distance; o++)
                (i[o - 1].object.visible = !1), (i[o].object.visible = !0);
              for (; o < a; o++) i[o].object.visible = !1;
            }
          };
        })(),
        toJSON: function (t) {
          var e = at.prototype.toJSON.call(this, t);
          e.object.levels = [];
          for (var n = this.levels, i = 0, r = n.length; i < r; i++) {
            var o = n[i];
            e.object.levels.push({
              object: o.object.uuid,
              distance: o.distance,
            });
          }
          return e;
        },
      })),
      Object.assign(ie.prototype, {
        calculateInverses: function () {
          this.boneInverses = [];
          for (var t = 0, e = this.bones.length; t < e; t++) {
            var n = new i();
            this.bones[t] && n.getInverse(this.bones[t].matrixWorld),
              this.boneInverses.push(n);
          }
        },
        pose: function () {
          var t, e, n;
          for (e = 0, n = this.bones.length; e < n; e++)
            (t = this.bones[e]) &&
              t.matrixWorld.getInverse(this.boneInverses[e]);
          for (e = 0, n = this.bones.length; e < n; e++)
            (t = this.bones[e]) &&
              (t.parent && t.parent.isBone
                ? (t.matrix.getInverse(t.parent.matrixWorld),
                  t.matrix.multiply(t.matrixWorld))
                : t.matrix.copy(t.matrixWorld),
              t.matrix.decompose(t.position, t.quaternion, t.scale));
        },
        update: (function () {
          var t = new i(),
            e = new i();
          return function () {
            for (
              var n = this.bones,
                i = this.boneInverses,
                r = this.boneMatrices,
                o = this.boneTexture,
                a = 0,
                s = n.length;
              a < s;
              a++
            ) {
              var c = n[a] ? n[a].matrixWorld : e;
              t.multiplyMatrices(c, i[a]), t.toArray(r, 16 * a);
            }
            void 0 !== o && (o.needsUpdate = !0);
          };
        })(),
        clone: function () {
          return new ie(this.bones, this.boneInverses);
        },
      }),
      (re.prototype = Object.assign(Object.create(at.prototype), {
        constructor: re,
        isBone: !0,
      })),
      (oe.prototype = Object.assign(Object.create(It.prototype), {
        constructor: oe,
        isSkinnedMesh: !0,
        initBones: function () {
          var t,
            e,
            n,
            i,
            r = [];
          if (this.geometry && void 0 !== this.geometry.bones) {
            for (n = 0, i = this.geometry.bones.length; n < i; n++)
              (e = this.geometry.bones[n]),
                (t = new re()),
                r.push(t),
                (t.name = e.name),
                t.position.fromArray(e.pos),
                t.quaternion.fromArray(e.rotq),
                void 0 !== e.scl && t.scale.fromArray(e.scl);
            for (n = 0, i = this.geometry.bones.length; n < i; n++)
              -1 !== (e = this.geometry.bones[n]).parent &&
              null !== e.parent &&
              void 0 !== r[e.parent]
                ? r[e.parent].add(r[n])
                : this.add(r[n]);
          }
          return this.updateMatrixWorld(!0), r;
        },
        bind: function (t, e) {
          (this.skeleton = t),
            void 0 === e &&
              (this.updateMatrixWorld(!0),
              this.skeleton.calculateInverses(),
              (e = this.matrixWorld)),
            this.bindMatrix.copy(e),
            this.bindMatrixInverse.getInverse(e);
        },
        pose: function () {
          this.skeleton.pose();
        },
        normalizeSkinWeights: function () {
          var t, e;
          if (this.geometry && this.geometry.isGeometry)
            for (e = 0; e < this.geometry.skinWeights.length; e++) {
              var n = this.geometry.skinWeights[e];
              (t = 1 / n.manhattanLength()) != 1 / 0
                ? n.multiplyScalar(t)
                : n.set(1, 0, 0, 0);
            }
          else if (this.geometry && this.geometry.isBufferGeometry) {
            var i = new c(),
              r = this.geometry.attributes.skinWeight;
            for (e = 0; e < r.count; e++)
              (i.x = r.getX(e)),
                (i.y = r.getY(e)),
                (i.z = r.getZ(e)),
                (i.w = r.getW(e)),
                (t = 1 / i.manhattanLength()) != 1 / 0
                  ? i.multiplyScalar(t)
                  : i.set(1, 0, 0, 0),
                r.setXYZW(e, i.x, i.y, i.z, i.w);
          }
        },
        updateMatrixWorld: function (t) {
          It.prototype.updateMatrixWorld.call(this, t),
            "attached" === this.bindMode
              ? this.bindMatrixInverse.getInverse(this.matrixWorld)
              : "detached" === this.bindMode
              ? this.bindMatrixInverse.getInverse(this.bindMatrix)
              : console.warn(
                  "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
                );
        },
        clone: function () {
          return new this.constructor(this.geometry, this.material).copy(this);
        },
      })),
      ((ae.prototype = Object.create(Z.prototype)).constructor = ae),
      (ae.prototype.isLineBasicMaterial = !0),
      (ae.prototype.copy = function (t) {
        return (
          Z.prototype.copy.call(this, t),
          this.color.copy(t.color),
          (this.linewidth = t.linewidth),
          (this.linecap = t.linecap),
          (this.linejoin = t.linejoin),
          this
        );
      }),
      (se.prototype = Object.assign(Object.create(at.prototype), {
        constructor: se,
        isLine: !0,
        raycast: (function () {
          var t = new i(),
            e = new Pt(),
            n = new tt();
          return function (i, r) {
            var a = i.linePrecision,
              s = a * a,
              c = this.geometry,
              l = this.matrixWorld;
            if (
              (null === c.boundingSphere && c.computeBoundingSphere(),
              n.copy(c.boundingSphere),
              n.applyMatrix4(l),
              !1 !== i.ray.intersectsSphere(n))
            ) {
              t.getInverse(l), e.copy(i.ray).applyMatrix4(t);
              var u = new o(),
                h = new o(),
                p = new o(),
                d = new o(),
                f = this && this.isLineSegments ? 2 : 1;
              if (c.isBufferGeometry) {
                var m = c.index,
                  g = c.attributes.position.array;
                if (null !== m)
                  for (
                    var v = m.array, y = 0, x = v.length - 1;
                    y < x;
                    y += f
                  ) {
                    var b = v[y],
                      _ = v[y + 1];
                    u.fromArray(g, 3 * b),
                      h.fromArray(g, 3 * _),
                      (E = e.distanceSqToSegment(u, h, d, p)) > s ||
                        (d.applyMatrix4(this.matrixWorld),
                        (T = i.ray.origin.distanceTo(d)) < i.near ||
                          T > i.far ||
                          r.push({
                            distance: T,
                            point: p.clone().applyMatrix4(this.matrixWorld),
                            index: y,
                            face: null,
                            faceIndex: null,
                            object: this,
                          }));
                  }
                else
                  for (var y = 0, x = g.length / 3 - 1; y < x; y += f)
                    u.fromArray(g, 3 * y),
                      h.fromArray(g, 3 * y + 3),
                      (E = e.distanceSqToSegment(u, h, d, p)) > s ||
                        (d.applyMatrix4(this.matrixWorld),
                        (T = i.ray.origin.distanceTo(d)) < i.near ||
                          T > i.far ||
                          r.push({
                            distance: T,
                            point: p.clone().applyMatrix4(this.matrixWorld),
                            index: y,
                            face: null,
                            faceIndex: null,
                            object: this,
                          }));
              } else if (c.isGeometry)
                for (
                  var w = c.vertices, M = w.length, y = 0;
                  y < M - 1;
                  y += f
                ) {
                  var E = e.distanceSqToSegment(w[y], w[y + 1], d, p);
                  if (!(E > s)) {
                    d.applyMatrix4(this.matrixWorld);
                    var T = i.ray.origin.distanceTo(d);
                    T < i.near ||
                      T > i.far ||
                      r.push({
                        distance: T,
                        point: p.clone().applyMatrix4(this.matrixWorld),
                        index: y,
                        face: null,
                        faceIndex: null,
                        object: this,
                      });
                  }
                }
            }
          };
        })(),
        clone: function () {
          return new this.constructor(this.geometry, this.material).copy(this);
        },
      })),
      (ce.prototype = Object.assign(Object.create(se.prototype), {
        constructor: ce,
        isLineSegments: !0,
      })),
      (le.prototype = Object.assign(Object.create(se.prototype), {
        constructor: le,
        isLineLoop: !0,
      })),
      ((ue.prototype = Object.create(Z.prototype)).constructor = ue),
      (ue.prototype.isPointsMaterial = !0),
      (ue.prototype.copy = function (t) {
        return (
          Z.prototype.copy.call(this, t),
          this.color.copy(t.color),
          (this.map = t.map),
          (this.size = t.size),
          (this.sizeAttenuation = t.sizeAttenuation),
          this
        );
      }),
      (he.prototype = Object.assign(Object.create(at.prototype), {
        constructor: he,
        isPoints: !0,
        raycast: (function () {
          var t = new i(),
            e = new Pt(),
            n = new tt();
          return function (i, r) {
            function a(t, n) {
              var o = e.distanceSqToPoint(t);
              if (o < p) {
                var a = e.closestPointToPoint(t);
                a.applyMatrix4(l);
                var c = i.ray.origin.distanceTo(a);
                if (c < i.near || c > i.far) return;
                r.push({
                  distance: c,
                  distanceToRay: Math.sqrt(o),
                  point: a.clone(),
                  index: n,
                  face: null,
                  object: s,
                });
              }
            }
            var s = this,
              c = this.geometry,
              l = this.matrixWorld,
              u = i.params.Points.threshold;
            if (
              (null === c.boundingSphere && c.computeBoundingSphere(),
              n.copy(c.boundingSphere),
              n.applyMatrix4(l),
              (n.radius += u),
              !1 !== i.ray.intersectsSphere(n))
            ) {
              t.getInverse(l), e.copy(i.ray).applyMatrix4(t);
              var h = u / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                p = h * h,
                d = new o();
              if (c.isBufferGeometry) {
                var f = c.index,
                  m = c.attributes.position.array;
                if (null !== f)
                  for (var g = f.array, v = 0, y = g.length; v < y; v++) {
                    var x = g[v];
                    d.fromArray(m, 3 * x), a(d, x);
                  }
                else
                  for (var v = 0, b = m.length / 3; v < b; v++)
                    d.fromArray(m, 3 * v), a(d, v);
              } else
                for (var _ = c.vertices, v = 0, b = _.length; v < b; v++)
                  a(_[v], v);
            }
          };
        })(),
        clone: function () {
          return new this.constructor(this.geometry, this.material).copy(this);
        },
      })),
      (pe.prototype = Object.assign(Object.create(at.prototype), {
        constructor: pe,
      })),
      ((de.prototype = Object.create(s.prototype)).constructor = de),
      ((fe.prototype = Object.create(s.prototype)).constructor = fe),
      (fe.prototype.isCompressedTexture = !0),
      ((me.prototype = Object.create(s.prototype)).constructor = me),
      (me.prototype.isDepthTexture = !0),
      ((ge.prototype = Object.create(Mt.prototype)).constructor = ge),
      ((ve.prototype = Object.create(ut.prototype)).constructor = ve),
      ((ye.prototype = Object.create(Mt.prototype)).constructor = ye),
      ((xe.prototype = Object.create(ut.prototype)).constructor = xe),
      ((be.prototype = Object.create(Mt.prototype)).constructor = be),
      ((_e.prototype = Object.create(ut.prototype)).constructor = _e),
      ((we.prototype = Object.create(be.prototype)).constructor = we),
      ((Me.prototype = Object.create(ut.prototype)).constructor = Me),
      ((Ee.prototype = Object.create(be.prototype)).constructor = Ee),
      ((Te.prototype = Object.create(ut.prototype)).constructor = Te),
      ((Se.prototype = Object.create(be.prototype)).constructor = Se),
      ((Ae.prototype = Object.create(ut.prototype)).constructor = Ae),
      ((Le.prototype = Object.create(be.prototype)).constructor = Le),
      ((Re.prototype = Object.create(ut.prototype)).constructor = Re),
      ((Pe.prototype = Object.create(Mt.prototype)).constructor = Pe),
      ((Ce.prototype = Object.create(ut.prototype)).constructor = Ce),
      ((Oe.prototype = Object.create(Mt.prototype)).constructor = Oe),
      ((Ie.prototype = Object.create(ut.prototype)).constructor = Ie),
      ((De.prototype = Object.create(Mt.prototype)).constructor = De);
    var Sa = {
      area: function (t) {
        for (var e = t.length, n = 0, i = e - 1, r = 0; r < e; i = r++)
          n += t[i].x * t[r].y - t[r].x * t[i].y;
        return 0.5 * n;
      },
      triangulate: (function () {
        function t(t, e, n, i, r, o) {
          var a, s, c, l, u, h, p, d, f;
          if (
            ((s = t[o[e]].x),
            (c = t[o[e]].y),
            (l = t[o[n]].x),
            (u = t[o[n]].y),
            (h = t[o[i]].x),
            (p = t[o[i]].y),
            (l - s) * (p - c) - (u - c) * (h - s) <= 0)
          )
            return !1;
          var m, g, v, y, x, b, _, w, M, E, T, S, A, L, R;
          for (
            m = h - l,
              g = p - u,
              v = s - h,
              y = c - p,
              x = l - s,
              b = u - c,
              a = 0;
            a < r;
            a++
          )
            if (
              ((d = t[o[a]].x),
              (f = t[o[a]].y),
              !(
                (d === s && f === c) ||
                (d === l && f === u) ||
                (d === h && f === p)
              ) &&
                ((_ = d - s),
                (w = f - c),
                (M = d - l),
                (E = f - u),
                (T = d - h),
                (S = f - p),
                (R = m * E - g * M),
                (A = x * w - b * _),
                (L = v * S - y * T),
                R >= -Number.EPSILON &&
                  L >= -Number.EPSILON &&
                  A >= -Number.EPSILON))
            )
              return !1;
          return !0;
        }
        return function (e, n) {
          var i = e.length;
          if (i < 3) return null;
          var r,
            o,
            a,
            s = [],
            c = [],
            l = [];
          if (Sa.area(e) > 0) for (o = 0; o < i; o++) c[o] = o;
          else for (o = 0; o < i; o++) c[o] = i - 1 - o;
          var u = i,
            h = 2 * u;
          for (o = u - 1; u > 2; ) {
            if (h-- <= 0)
              return (
                console.warn(
                  "THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()"
                ),
                n ? l : s
              );
            if (
              ((r = o),
              u <= r && (r = 0),
              (o = r + 1),
              u <= o && (o = 0),
              (a = o + 1),
              u <= a && (a = 0),
              t(e, r, o, a, u, c))
            ) {
              var p, d, f, m, g;
              for (
                p = c[r],
                  d = c[o],
                  f = c[a],
                  s.push([e[p], e[d], e[f]]),
                  l.push([c[r], c[o], c[a]]),
                  m = o,
                  g = o + 1;
                g < u;
                m++, g++
              )
                c[m] = c[g];
              h = 2 * --u;
            }
          }
          return n ? l : s;
        };
      })(),
      triangulateShape: function (t, e) {
        function n(t) {
          var e = t.length;
          e > 2 && t[e - 1].equals(t[0]) && t.pop();
        }
        function i(t, e, n) {
          return t.x !== e.x
            ? t.x < e.x
              ? t.x <= n.x && n.x <= e.x
              : e.x <= n.x && n.x <= t.x
            : t.y < e.y
            ? t.y <= n.y && n.y <= e.y
            : e.y <= n.y && n.y <= t.y;
        }
        function r(t, e, n, r, o) {
          var a = e.x - t.x,
            s = e.y - t.y,
            c = r.x - n.x,
            l = r.y - n.y,
            u = t.x - n.x,
            h = t.y - n.y,
            p = s * c - a * l,
            d = s * u - a * h;
          if (Math.abs(p) > Number.EPSILON) {
            var f;
            if (p > 0) {
              if (d < 0 || d > p) return [];
              if ((f = l * u - c * h) < 0 || f > p) return [];
            } else {
              if (d > 0 || d < p) return [];
              if ((f = l * u - c * h) > 0 || f < p) return [];
            }
            if (0 === f) return !o || (0 !== d && d !== p) ? [t] : [];
            if (f === p) return !o || (0 !== d && d !== p) ? [e] : [];
            if (0 === d) return [n];
            if (d === p) return [r];
            var m = f / p;
            return [{ x: t.x + m * a, y: t.y + m * s }];
          }
          if (0 !== d || l * u != c * h) return [];
          var g = 0 === a && 0 === s,
            v = 0 === c && 0 === l;
          if (g && v) return t.x !== n.x || t.y !== n.y ? [] : [t];
          if (g) return i(n, r, t) ? [t] : [];
          if (v) return i(t, e, n) ? [n] : [];
          var y, x, b, _, w, M, E, T;
          return (
            0 !== a
              ? (t.x < e.x
                  ? ((y = t), (b = t.x), (x = e), (_ = e.x))
                  : ((y = e), (b = e.x), (x = t), (_ = t.x)),
                n.x < r.x
                  ? ((w = n), (E = n.x), (M = r), (T = r.x))
                  : ((w = r), (E = r.x), (M = n), (T = n.x)))
              : (t.y < e.y
                  ? ((y = t), (b = t.y), (x = e), (_ = e.y))
                  : ((y = e), (b = e.y), (x = t), (_ = t.y)),
                n.y < r.y
                  ? ((w = n), (E = n.y), (M = r), (T = r.y))
                  : ((w = r), (E = r.y), (M = n), (T = n.y))),
            b <= E
              ? _ < E
                ? []
                : _ === E
                ? o
                  ? []
                  : [w]
                : _ <= T
                ? [w, x]
                : [w, M]
              : b > T
              ? []
              : b === T
              ? o
                ? []
                : [y]
              : _ <= T
              ? [y, x]
              : [y, M]
          );
        }
        function o(t, e, n, i) {
          var r = e.x - t.x,
            o = e.y - t.y,
            a = n.x - t.x,
            s = n.y - t.y,
            c = i.x - t.x,
            l = i.y - t.y,
            u = r * s - o * a,
            h = r * l - o * c;
          if (Math.abs(u) > Number.EPSILON) {
            var p = c * s - l * a;
            return u > 0 ? h >= 0 && p >= 0 : h >= 0 || p >= 0;
          }
          return h > 0;
        }
        n(t), e.forEach(n);
        for (
          var a, s, c, l, u, h, p = {}, d = t.concat(), f = 0, m = e.length;
          f < m;
          f++
        )
          Array.prototype.push.apply(d, e[f]);
        for (a = 0, s = d.length; a < s; a++)
          void 0 !== p[(u = d[a].x + ":" + d[a].y)] &&
            console.warn("THREE.ShapeUtils: Duplicate point", u, a),
            (p[u] = a);
        var g = (function (t, e) {
            function n(t, e) {
              var n = y.length - 1,
                i = t - 1;
              i < 0 && (i = n);
              var r = t + 1;
              r > n && (r = 0);
              var a = o(y[t], y[i], y[r], s[e]);
              if (!a) return !1;
              var c = s.length - 1,
                l = e - 1;
              l < 0 && (l = c);
              var u = e + 1;
              return u > c && (u = 0), !!(a = o(s[e], s[l], s[u], y[t]));
            }
            function i(t, e) {
              var n, i;
              for (n = 0; n < y.length; n++)
                if (
                  ((i = n + 1),
                  (i %= y.length),
                  r(t, e, y[n], y[i], !0).length > 0)
                )
                  return !0;
              return !1;
            }
            function a(t, n) {
              var i, o, a, s;
              for (i = 0; i < x.length; i++)
                for (o = e[x[i]], a = 0; a < o.length; a++)
                  if (
                    ((s = a + 1),
                    (s %= o.length),
                    r(t, n, o[a], o[s], !0).length > 0)
                  )
                    return !0;
              return !1;
            }
            for (
              var s,
                c,
                l,
                u,
                h,
                p,
                d,
                f,
                m,
                g,
                v,
                y = t.concat(),
                x = [],
                b = [],
                _ = 0,
                w = e.length;
              _ < w;
              _++
            )
              x.push(_);
            for (var M = 0, E = 2 * x.length; x.length > 0; ) {
              if (--E < 0) {
                console.log(
                  'THREE.ShapeUtils: Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!'
                );
                break;
              }
              for (l = M; l < y.length; l++) {
                for (u = y[l], c = -1, _ = 0; _ < x.length; _++)
                  if (
                    ((p = x[_]),
                    (d = u.x + ":" + u.y + ":" + p),
                    void 0 === b[d])
                  ) {
                    s = e[p];
                    for (var T = 0; T < s.length; T++)
                      if (((h = s[T]), n(l, T) && !i(u, h) && !a(u, h))) {
                        (c = T),
                          x.splice(_, 1),
                          (f = y.slice(0, l + 1)),
                          (m = y.slice(l)),
                          (g = s.slice(c)),
                          (v = s.slice(0, c + 1)),
                          (y = f.concat(g).concat(v).concat(m)),
                          (M = l);
                        break;
                      }
                    if (c >= 0) break;
                    b[d] = !0;
                  }
                if (c >= 0) break;
              }
            }
            return y;
          })(t, e),
          v = Sa.triangulate(g, !1);
        for (a = 0, s = v.length; a < s; a++)
          for (l = v[a], c = 0; c < 3; c++)
            void 0 !== (h = p[(u = l[c].x + ":" + l[c].y)]) && (l[c] = h);
        return v.concat();
      },
      isClockWise: function (t) {
        return Sa.area(t) < 0;
      },
    };
    ((Ue.prototype = Object.create(ut.prototype)).constructor = Ue),
      ((Ne.prototype = Object.create(Mt.prototype)).constructor = Ne),
      (Ne.prototype.getArrays = function () {
        var t = this.getAttribute("position"),
          e = t ? Array.prototype.slice.call(t.array) : [],
          n = this.getAttribute("uv"),
          i = n ? Array.prototype.slice.call(n.array) : [],
          r = this.index;
        return {
          position: e,
          uv: i,
          index: r ? Array.prototype.slice.call(r.array) : [],
        };
      }),
      (Ne.prototype.addShapeList = function (t, e) {
        var n = t.length;
        e.arrays = this.getArrays();
        for (var i = 0; i < n; i++) {
          var r = t[i];
          this.addShape(r, e);
        }
        this.setIndex(e.arrays.index),
          this.addAttribute("position", new xt(e.arrays.position, 3)),
          this.addAttribute("uv", new xt(e.arrays.uv, 2));
      }),
      (Ne.prototype.addShape = function (t, e) {
        function i(t, e, n) {
          return (
            e || console.error("THREE.ExtrudeGeometry: vec does not exist"),
            e.clone().multiplyScalar(n).add(t)
          );
        }
        function r(t, e, i) {
          var r,
            o,
            a,
            s = t.x - e.x,
            c = t.y - e.y,
            l = i.x - t.x,
            u = i.y - t.y,
            h = s * s + c * c,
            p = s * u - c * l;
          if (Math.abs(p) > Number.EPSILON) {
            var d = Math.sqrt(h),
              f = Math.sqrt(l * l + u * u),
              m = e.x - c / d,
              g = e.y + s / d,
              v =
                ((i.x - u / f - m) * u - (i.y + l / f - g) * l) /
                (s * u - c * l),
              y = (r = m + s * v - t.x) * r + (o = g + c * v - t.y) * o;
            if (y <= 2) return new n(r, o);
            a = Math.sqrt(y / 2);
          } else {
            var x = !1;
            s > Number.EPSILON
              ? l > Number.EPSILON && (x = !0)
              : s < -Number.EPSILON
              ? l < -Number.EPSILON && (x = !0)
              : Math.sign(c) === Math.sign(u) && (x = !0),
              x
                ? ((r = -c), (o = s), (a = Math.sqrt(h)))
                : ((r = s), (o = c), (a = Math.sqrt(h / 2)));
          }
          return new n(r / a, o / a);
        }
        function a(t, e) {
          var n, i;
          for ($ = t.length; --$ >= 0; ) {
            (n = $), (i = $ - 1) < 0 && (i = t.length - 1);
            var r = 0,
              o = A + 2 * E;
            for (r = 0; r < o; r++) {
              var a = X * r,
                s = X * (r + 1);
              !(function (t, i, r, o) {
                l(e + n + a), l(i), l(o), l(i), l(r), l(o);
                var s = v.length / 3,
                  c = P.generateSideWallUV(D, v, s - 6, s - 3, s - 2, s - 1);
                u(c[0]), u(c[1]), u(c[3]), u(c[1]), u(c[2]), u(c[3]);
              })(0, e + i + a, e + i + s, e + n + s);
            }
          }
        }
        function s(t, e, n) {
          b.push(t), b.push(e), b.push(n);
        }
        function c(t, e, n) {
          l(t), l(e), l(n);
          var i = v.length / 3,
            r = P.generateTopUV(D, v, i - 3, i - 2, i - 1);
          u(r[0]), u(r[1]), u(r[2]);
        }
        function l(t) {
          y.push(v.length / 3),
            v.push(b[3 * t + 0]),
            v.push(b[3 * t + 1]),
            v.push(b[3 * t + 2]);
        }
        function u(t) {
          x.push(t.x), x.push(t.y);
        }
        var h,
          p,
          d,
          f,
          m,
          g = e.arrays ? e.arrays : this.getArrays(),
          v = g.position,
          y = g.index,
          x = g.uv,
          b = [],
          _ = void 0 !== e.amount ? e.amount : 100,
          w = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
          M = void 0 !== e.bevelSize ? e.bevelSize : w - 2,
          E = void 0 !== e.bevelSegments ? e.bevelSegments : 3,
          T = void 0 === e.bevelEnabled || e.bevelEnabled,
          S = void 0 !== e.curveSegments ? e.curveSegments : 12,
          A = void 0 !== e.steps ? e.steps : 1,
          L = e.extrudePath,
          R = !1,
          P = void 0 !== e.UVGenerator ? e.UVGenerator : Ue.WorldUVGenerator;
        L &&
          ((h = L.getSpacedPoints(A)),
          (R = !0),
          (T = !1),
          (p = void 0 !== e.frames ? e.frames : L.computeFrenetFrames(A, !1)),
          (d = new o()),
          (f = new o()),
          (m = new o())),
          T || ((E = 0), (w = 0), (M = 0));
        var C,
          O,
          I,
          D = this,
          U = t.extractPoints(S),
          N = U.shape,
          z = U.holes;
        if (!Sa.isClockWise(N))
          for (N = N.reverse(), O = 0, I = z.length; O < I; O++)
            (C = z[O]), Sa.isClockWise(C) && (z[O] = C.reverse());
        var k = Sa.triangulateShape(N, z),
          F = N;
        for (O = 0, I = z.length; O < I; O++) (C = z[O]), (N = N.concat(C));
        for (
          var B,
            H,
            j,
            G,
            V,
            W,
            X = N.length,
            Y = k.length,
            q = [],
            $ = 0,
            Z = F.length,
            J = Z - 1,
            Q = $ + 1;
          $ < Z;
          $++, J++, Q++
        )
          J === Z && (J = 0), Q === Z && (Q = 0), (q[$] = r(F[$], F[J], F[Q]));
        var K,
          tt = [],
          et = q.concat();
        for (O = 0, I = z.length; O < I; O++) {
          for (
            C = z[O], K = [], $ = 0, J = (Z = C.length) - 1, Q = $ + 1;
            $ < Z;
            $++, J++, Q++
          )
            J === Z && (J = 0),
              Q === Z && (Q = 0),
              (K[$] = r(C[$], C[J], C[Q]));
          tt.push(K), (et = et.concat(K));
        }
        for (B = 0; B < E; B++) {
          for (
            j = B / E,
              G = w * Math.cos((j * Math.PI) / 2),
              H = M * Math.sin((j * Math.PI) / 2),
              $ = 0,
              Z = F.length;
            $ < Z;
            $++
          )
            s((V = i(F[$], q[$], H)).x, V.y, -G);
          for (O = 0, I = z.length; O < I; O++)
            for (C = z[O], K = tt[O], $ = 0, Z = C.length; $ < Z; $++)
              s((V = i(C[$], K[$], H)).x, V.y, -G);
        }
        for (H = M, $ = 0; $ < X; $++)
          (V = T ? i(N[$], et[$], H) : N[$]),
            R
              ? (f.copy(p.normals[0]).multiplyScalar(V.x),
                d.copy(p.binormals[0]).multiplyScalar(V.y),
                m.copy(h[0]).add(f).add(d),
                s(m.x, m.y, m.z))
              : s(V.x, V.y, 0);
        var nt;
        for (nt = 1; nt <= A; nt++)
          for ($ = 0; $ < X; $++)
            (V = T ? i(N[$], et[$], H) : N[$]),
              R
                ? (f.copy(p.normals[nt]).multiplyScalar(V.x),
                  d.copy(p.binormals[nt]).multiplyScalar(V.y),
                  m.copy(h[nt]).add(f).add(d),
                  s(m.x, m.y, m.z))
                : s(V.x, V.y, (_ / A) * nt);
        for (B = E - 1; B >= 0; B--) {
          for (
            j = B / E,
              G = w * Math.cos((j * Math.PI) / 2),
              H = M * Math.sin((j * Math.PI) / 2),
              $ = 0,
              Z = F.length;
            $ < Z;
            $++
          )
            s((V = i(F[$], q[$], H)).x, V.y, _ + G);
          for (O = 0, I = z.length; O < I; O++)
            for (C = z[O], K = tt[O], $ = 0, Z = C.length; $ < Z; $++)
              (V = i(C[$], K[$], H)),
                R
                  ? s(V.x, V.y + h[A - 1].y, h[A - 1].x + G)
                  : s(V.x, V.y, _ + G);
        }
        !(function () {
          var t = v.length / 3;
          if (T) {
            var n = 0,
              i = X * n;
            for ($ = 0; $ < Y; $++) c((W = k[$])[2] + i, W[1] + i, W[0] + i);
            for (i = X * (n = A + 2 * E), $ = 0; $ < Y; $++)
              c((W = k[$])[0] + i, W[1] + i, W[2] + i);
          } else {
            for ($ = 0; $ < Y; $++) c((W = k[$])[2], W[1], W[0]);
            for ($ = 0; $ < Y; $++)
              c((W = k[$])[0] + X * A, W[1] + X * A, W[2] + X * A);
          }
          D.addGroup(
            t,
            v.length / 3 - t,
            void 0 !== e.material ? e.material : 0
          );
        })(),
          (function () {
            var t = v.length / 3,
              n = 0;
            for (a(F, n), n += F.length, O = 0, I = z.length; O < I; O++)
              a((C = z[O]), n), (n += C.length);
            D.addGroup(
              t,
              v.length / 3 - t,
              void 0 !== e.extrudeMaterial ? e.extrudeMaterial : 1
            );
          })(),
          e.arrays ||
            (this.setIndex(y),
            this.addAttribute("position", new xt(v, 3)),
            this.addAttribute("uv", new xt(e.arrays.uv, 2)));
      }),
      (Ue.WorldUVGenerator = {
        generateTopUV: function (t, e, i, r, o) {
          var a = e[3 * i],
            s = e[3 * i + 1],
            c = e[3 * r],
            l = e[3 * r + 1],
            u = e[3 * o],
            h = e[3 * o + 1];
          return [new n(a, s), new n(c, l), new n(u, h)];
        },
        generateSideWallUV: function (t, e, i, r, o, a) {
          var s = e[3 * i],
            c = e[3 * i + 1],
            l = e[3 * i + 2],
            u = e[3 * r],
            h = e[3 * r + 1],
            p = e[3 * r + 2],
            d = e[3 * o],
            f = e[3 * o + 1],
            m = e[3 * o + 2],
            g = e[3 * a],
            v = e[3 * a + 1],
            y = e[3 * a + 2];
          return Math.abs(c - h) < 0.01
            ? [
                new n(s, 1 - l),
                new n(u, 1 - p),
                new n(d, 1 - m),
                new n(g, 1 - y),
              ]
            : [
                new n(c, 1 - l),
                new n(h, 1 - p),
                new n(f, 1 - m),
                new n(v, 1 - y),
              ];
        },
      }),
      ((ze.prototype = Object.create(ut.prototype)).constructor = ze),
      ((ke.prototype = Object.create(Ne.prototype)).constructor = ke),
      ((Fe.prototype = Object.create(ut.prototype)).constructor = Fe),
      ((Be.prototype = Object.create(Mt.prototype)).constructor = Be),
      ((He.prototype = Object.create(ut.prototype)).constructor = He),
      ((je.prototype = Object.create(Mt.prototype)).constructor = je),
      ((Ge.prototype = Object.create(ut.prototype)).constructor = Ge),
      ((Ve.prototype = Object.create(Mt.prototype)).constructor = Ve),
      ((We.prototype = Object.create(ut.prototype)).constructor = We),
      ((Xe.prototype = Object.create(Mt.prototype)).constructor = Xe),
      ((Ye.prototype = Object.create(Mt.prototype)).constructor = Ye),
      ((qe.prototype = Object.create(ut.prototype)).constructor = qe),
      (($e.prototype = Object.create(Mt.prototype)).constructor = $e),
      ((Ze.prototype = Object.create(qe.prototype)).constructor = Ze),
      ((Je.prototype = Object.create($e.prototype)).constructor = Je),
      ((Qe.prototype = Object.create(ut.prototype)).constructor = Qe),
      ((Ke.prototype = Object.create(Mt.prototype)).constructor = Ke);
    var Aa = Object.freeze({
      WireframeGeometry: ge,
      ParametricGeometry: ve,
      ParametricBufferGeometry: ye,
      TetrahedronGeometry: _e,
      TetrahedronBufferGeometry: we,
      OctahedronGeometry: Me,
      OctahedronBufferGeometry: Ee,
      IcosahedronGeometry: Te,
      IcosahedronBufferGeometry: Se,
      DodecahedronGeometry: Ae,
      DodecahedronBufferGeometry: Le,
      PolyhedronGeometry: xe,
      PolyhedronBufferGeometry: be,
      TubeGeometry: Re,
      TubeBufferGeometry: Pe,
      TorusKnotGeometry: Ce,
      TorusKnotBufferGeometry: Oe,
      TorusGeometry: Ie,
      TorusBufferGeometry: De,
      TextGeometry: ze,
      TextBufferGeometry: ke,
      SphereGeometry: Fe,
      SphereBufferGeometry: Be,
      RingGeometry: He,
      RingBufferGeometry: je,
      PlaneGeometry: St,
      PlaneBufferGeometry: At,
      LatheGeometry: Ge,
      LatheBufferGeometry: Ve,
      ShapeGeometry: We,
      ShapeBufferGeometry: Xe,
      ExtrudeGeometry: Ue,
      ExtrudeBufferGeometry: Ne,
      EdgesGeometry: Ye,
      ConeGeometry: Ze,
      ConeBufferGeometry: Je,
      CylinderGeometry: qe,
      CylinderBufferGeometry: $e,
      CircleGeometry: Qe,
      CircleBufferGeometry: Ke,
      BoxGeometry: Et,
      BoxBufferGeometry: Tt,
    });
    ((tn.prototype = Object.create(Z.prototype)).constructor = tn),
      (tn.prototype.isShadowMaterial = !0),
      ((en.prototype = Object.create(Rt.prototype)).constructor = en),
      (en.prototype.isRawShaderMaterial = !0),
      ((nn.prototype = Object.create(Z.prototype)).constructor = nn),
      (nn.prototype.isMeshStandardMaterial = !0),
      (nn.prototype.copy = function (t) {
        return (
          Z.prototype.copy.call(this, t),
          (this.defines = { STANDARD: "" }),
          this.color.copy(t.color),
          (this.roughness = t.roughness),
          (this.metalness = t.metalness),
          (this.map = t.map),
          (this.lightMap = t.lightMap),
          (this.lightMapIntensity = t.lightMapIntensity),
          (this.aoMap = t.aoMap),
          (this.aoMapIntensity = t.aoMapIntensity),
          this.emissive.copy(t.emissive),
          (this.emissiveMap = t.emissiveMap),
          (this.emissiveIntensity = t.emissiveIntensity),
          (this.bumpMap = t.bumpMap),
          (this.bumpScale = t.bumpScale),
          (this.normalMap = t.normalMap),
          this.normalScale.copy(t.normalScale),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          (this.roughnessMap = t.roughnessMap),
          (this.metalnessMap = t.metalnessMap),
          (this.alphaMap = t.alphaMap),
          (this.envMap = t.envMap),
          (this.envMapIntensity = t.envMapIntensity),
          (this.refractionRatio = t.refractionRatio),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.wireframeLinecap = t.wireframeLinecap),
          (this.wireframeLinejoin = t.wireframeLinejoin),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.morphNormals = t.morphNormals),
          this
        );
      }),
      ((rn.prototype = Object.create(nn.prototype)).constructor = rn),
      (rn.prototype.isMeshPhysicalMaterial = !0),
      (rn.prototype.copy = function (t) {
        return (
          nn.prototype.copy.call(this, t),
          (this.defines = { PHYSICAL: "" }),
          (this.reflectivity = t.reflectivity),
          (this.clearCoat = t.clearCoat),
          (this.clearCoatRoughness = t.clearCoatRoughness),
          this
        );
      }),
      ((on.prototype = Object.create(Z.prototype)).constructor = on),
      (on.prototype.isMeshPhongMaterial = !0),
      (on.prototype.copy = function (t) {
        return (
          Z.prototype.copy.call(this, t),
          this.color.copy(t.color),
          this.specular.copy(t.specular),
          (this.shininess = t.shininess),
          (this.map = t.map),
          (this.lightMap = t.lightMap),
          (this.lightMapIntensity = t.lightMapIntensity),
          (this.aoMap = t.aoMap),
          (this.aoMapIntensity = t.aoMapIntensity),
          this.emissive.copy(t.emissive),
          (this.emissiveMap = t.emissiveMap),
          (this.emissiveIntensity = t.emissiveIntensity),
          (this.bumpMap = t.bumpMap),
          (this.bumpScale = t.bumpScale),
          (this.normalMap = t.normalMap),
          this.normalScale.copy(t.normalScale),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          (this.specularMap = t.specularMap),
          (this.alphaMap = t.alphaMap),
          (this.envMap = t.envMap),
          (this.combine = t.combine),
          (this.reflectivity = t.reflectivity),
          (this.refractionRatio = t.refractionRatio),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.wireframeLinecap = t.wireframeLinecap),
          (this.wireframeLinejoin = t.wireframeLinejoin),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.morphNormals = t.morphNormals),
          this
        );
      }),
      ((an.prototype = Object.create(on.prototype)).constructor = an),
      (an.prototype.isMeshToonMaterial = !0),
      (an.prototype.copy = function (t) {
        return (
          on.prototype.copy.call(this, t),
          (this.gradientMap = t.gradientMap),
          this
        );
      }),
      ((sn.prototype = Object.create(Z.prototype)).constructor = sn),
      (sn.prototype.isMeshNormalMaterial = !0),
      (sn.prototype.copy = function (t) {
        return (
          Z.prototype.copy.call(this, t),
          (this.bumpMap = t.bumpMap),
          (this.bumpScale = t.bumpScale),
          (this.normalMap = t.normalMap),
          this.normalScale.copy(t.normalScale),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.morphNormals = t.morphNormals),
          this
        );
      }),
      ((cn.prototype = Object.create(Z.prototype)).constructor = cn),
      (cn.prototype.isMeshLambertMaterial = !0),
      (cn.prototype.copy = function (t) {
        return (
          Z.prototype.copy.call(this, t),
          this.color.copy(t.color),
          (this.map = t.map),
          (this.lightMap = t.lightMap),
          (this.lightMapIntensity = t.lightMapIntensity),
          (this.aoMap = t.aoMap),
          (this.aoMapIntensity = t.aoMapIntensity),
          this.emissive.copy(t.emissive),
          (this.emissiveMap = t.emissiveMap),
          (this.emissiveIntensity = t.emissiveIntensity),
          (this.specularMap = t.specularMap),
          (this.alphaMap = t.alphaMap),
          (this.envMap = t.envMap),
          (this.combine = t.combine),
          (this.reflectivity = t.reflectivity),
          (this.refractionRatio = t.refractionRatio),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.wireframeLinecap = t.wireframeLinecap),
          (this.wireframeLinejoin = t.wireframeLinejoin),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          (this.morphNormals = t.morphNormals),
          this
        );
      }),
      ((ln.prototype = Object.create(ae.prototype)).constructor = ln),
      (ln.prototype.isLineDashedMaterial = !0),
      (ln.prototype.copy = function (t) {
        return (
          ae.prototype.copy.call(this, t),
          (this.scale = t.scale),
          (this.dashSize = t.dashSize),
          (this.gapSize = t.gapSize),
          this
        );
      });
    var La = Object.freeze({
        ShadowMaterial: tn,
        SpriteMaterial: te,
        RawShaderMaterial: en,
        ShaderMaterial: Rt,
        PointsMaterial: ue,
        MeshPhysicalMaterial: rn,
        MeshStandardMaterial: nn,
        MeshPhongMaterial: on,
        MeshToonMaterial: an,
        MeshNormalMaterial: sn,
        MeshLambertMaterial: cn,
        MeshDepthMaterial: J,
        MeshDistanceMaterial: Q,
        MeshBasicMaterial: Lt,
        LineDashedMaterial: ln,
        LineBasicMaterial: ae,
        Material: Z,
      }),
      Ra = {
        enabled: !1,
        files: {},
        add: function (t, e) {
          !1 !== this.enabled && (this.files[t] = e);
        },
        get: function (t) {
          if (!1 !== this.enabled) return this.files[t];
        },
        remove: function (t) {
          delete this.files[t];
        },
        clear: function () {
          this.files = {};
        },
      },
      Pa = new un(),
      Ca = {};
    Object.assign(hn.prototype, {
      load: function (t, e, n, i) {
        void 0 === t && (t = ""),
          void 0 !== this.path && (t = this.path + t),
          (t = this.manager.resolveURL(t));
        var r = this,
          o = Ra.get(t);
        if (void 0 !== o)
          return (
            r.manager.itemStart(t),
            setTimeout(function () {
              e && e(o), r.manager.itemEnd(t);
            }, 0),
            o
          );
        if (void 0 === Ca[t]) {
          var a = t.match(/^data:(.*?)(;base64)?,(.*)$/);
          if (a) {
            var s = a[1],
              c = !!a[2],
              l = a[3];
            (l = window.decodeURIComponent(l)), c && (l = window.atob(l));
            try {
              var u,
                h = (this.responseType || "").toLowerCase();
              switch (h) {
                case "arraybuffer":
                case "blob":
                  for (
                    var p = new Uint8Array(l.length), d = 0;
                    d < l.length;
                    d++
                  )
                    p[d] = l.charCodeAt(d);
                  u =
                    "blob" === h ? new Blob([p.buffer], { type: s }) : p.buffer;
                  break;
                case "document":
                  var f = new DOMParser();
                  u = f.parseFromString(l, s);
                  break;
                case "json":
                  u = JSON.parse(l);
                  break;
                default:
                  u = l;
              }
              window.setTimeout(function () {
                e && e(u), r.manager.itemEnd(t);
              }, 0);
            } catch (e) {
              window.setTimeout(function () {
                i && i(e), r.manager.itemEnd(t), r.manager.itemError(t);
              }, 0);
            }
          } else {
            (Ca[t] = []), Ca[t].push({ onLoad: e, onProgress: n, onError: i });
            var m = new XMLHttpRequest();
            m.open("GET", t, !0),
              m.addEventListener(
                "load",
                function (e) {
                  var n = e.target.response;
                  Ra.add(t, n);
                  var i = Ca[t];
                  if ((delete Ca[t], 200 === this.status)) {
                    for (var o = 0, a = i.length; o < a; o++)
                      (s = i[o]).onLoad && s.onLoad(n);
                    r.manager.itemEnd(t);
                  } else if (0 === this.status) {
                    console.warn("THREE.FileLoader: HTTP Status 0 received.");
                    for (var o = 0, a = i.length; o < a; o++)
                      (s = i[o]).onLoad && s.onLoad(n);
                    r.manager.itemEnd(t);
                  } else {
                    for (var o = 0, a = i.length; o < a; o++) {
                      var s = i[o];
                      s.onError && s.onError(e);
                    }
                    r.manager.itemEnd(t), r.manager.itemError(t);
                  }
                },
                !1
              ),
              m.addEventListener(
                "progress",
                function (e) {
                  for (var n = Ca[t], i = 0, r = n.length; i < r; i++) {
                    var o = n[i];
                    o.onProgress && o.onProgress(e);
                  }
                },
                !1
              ),
              m.addEventListener(
                "error",
                function (e) {
                  var n = Ca[t];
                  delete Ca[t];
                  for (var i = 0, o = n.length; i < o; i++) {
                    var a = n[i];
                    a.onError && a.onError(e);
                  }
                  r.manager.itemEnd(t), r.manager.itemError(t);
                },
                !1
              ),
              void 0 !== this.responseType &&
                (m.responseType = this.responseType),
              void 0 !== this.withCredentials &&
                (m.withCredentials = this.withCredentials),
              m.overrideMimeType &&
                m.overrideMimeType(
                  void 0 !== this.mimeType ? this.mimeType : "text/plain"
                );
            for (var g in this.requestHeader)
              m.setRequestHeader(g, this.requestHeader[g]);
            m.send(null);
          }
          return r.manager.itemStart(t), m;
        }
        Ca[t].push({ onLoad: e, onProgress: n, onError: i });
      },
      setPath: function (t) {
        return (this.path = t), this;
      },
      setResponseType: function (t) {
        return (this.responseType = t), this;
      },
      setWithCredentials: function (t) {
        return (this.withCredentials = t), this;
      },
      setMimeType: function (t) {
        return (this.mimeType = t), this;
      },
      setRequestHeader: function (t) {
        return (this.requestHeader = t), this;
      },
    }),
      Object.assign(pn.prototype, {
        load: function (t, e, n, i) {
          function r(r) {
            c.load(
              t[r],
              function (t) {
                var n = o._parser(t, !0);
                (a[r] = {
                  width: n.width,
                  height: n.height,
                  format: n.format,
                  mipmaps: n.mipmaps,
                }),
                  6 === (l += 1) &&
                    (1 === n.mipmapCount && (s.minFilter = go),
                    (s.format = n.format),
                    (s.needsUpdate = !0),
                    e && e(s));
              },
              n,
              i
            );
          }
          var o = this,
            a = [],
            s = new fe();
          s.image = a;
          var c = new hn(this.manager);
          if (
            (c.setPath(this.path),
            c.setResponseType("arraybuffer"),
            Array.isArray(t))
          )
            for (var l = 0, u = 0, h = t.length; u < h; ++u) r(u);
          else
            c.load(
              t,
              function (t) {
                var n = o._parser(t, !0);
                if (n.isCubemap)
                  for (
                    var i = n.mipmaps.length / n.mipmapCount, r = 0;
                    r < i;
                    r++
                  ) {
                    a[r] = { mipmaps: [] };
                    for (var c = 0; c < n.mipmapCount; c++)
                      a[r].mipmaps.push(n.mipmaps[r * n.mipmapCount + c]),
                        (a[r].format = n.format),
                        (a[r].width = n.width),
                        (a[r].height = n.height);
                  }
                else
                  (s.image.width = n.width),
                    (s.image.height = n.height),
                    (s.mipmaps = n.mipmaps);
                1 === n.mipmapCount && (s.minFilter = go),
                  (s.format = n.format),
                  (s.needsUpdate = !0),
                  e && e(s);
              },
              n,
              i
            );
          return s;
        },
        setPath: function (t) {
          return (this.path = t), this;
        },
      }),
      Object.assign(dn.prototype, {
        load: function (t, e, n, i) {
          var r = this,
            o = new h(),
            a = new hn(this.manager);
          return (
            a.setResponseType("arraybuffer"),
            a.load(
              t,
              function (t) {
                var n = r._parser(t);
                n &&
                  (void 0 !== n.image
                    ? (o.image = n.image)
                    : void 0 !== n.data &&
                      ((o.image.width = n.width),
                      (o.image.height = n.height),
                      (o.image.data = n.data)),
                  (o.wrapS = void 0 !== n.wrapS ? n.wrapS : uo),
                  (o.wrapT = void 0 !== n.wrapT ? n.wrapT : uo),
                  (o.magFilter = void 0 !== n.magFilter ? n.magFilter : go),
                  (o.minFilter = void 0 !== n.minFilter ? n.minFilter : yo),
                  (o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1),
                  void 0 !== n.format && (o.format = n.format),
                  void 0 !== n.type && (o.type = n.type),
                  void 0 !== n.mipmaps && (o.mipmaps = n.mipmaps),
                  1 === n.mipmapCount && (o.minFilter = go),
                  (o.needsUpdate = !0),
                  e && e(o, n));
              },
              n,
              i
            ),
            o
          );
        },
      }),
      Object.assign(fn.prototype, {
        crossOrigin: "Anonymous",
        load: function (t, e, n, i) {
          void 0 === t && (t = ""),
            void 0 !== this.path && (t = this.path + t),
            (t = this.manager.resolveURL(t));
          var r = this,
            o = Ra.get(t);
          if (void 0 !== o)
            return (
              r.manager.itemStart(t),
              setTimeout(function () {
                e && e(o), r.manager.itemEnd(t);
              }, 0),
              o
            );
          var a = document.createElementNS(
            "http://www.w3.org/1999/xhtml",
            "img"
          );
          return (
            a.addEventListener(
              "load",
              function () {
                Ra.add(t, this), e && e(this), r.manager.itemEnd(t);
              },
              !1
            ),
            a.addEventListener(
              "error",
              function (e) {
                i && i(e), r.manager.itemEnd(t), r.manager.itemError(t);
              },
              !1
            ),
            "data:" !== t.substr(0, 5) &&
              void 0 !== this.crossOrigin &&
              (a.crossOrigin = this.crossOrigin),
            r.manager.itemStart(t),
            (a.src = t),
            a
          );
        },
        setCrossOrigin: function (t) {
          return (this.crossOrigin = t), this;
        },
        setPath: function (t) {
          return (this.path = t), this;
        },
      }),
      Object.assign(mn.prototype, {
        crossOrigin: "Anonymous",
        load: function (t, e, n, i) {
          function r(n) {
            a.load(
              t[n],
              function (t) {
                (o.images[n] = t),
                  6 == ++s && ((o.needsUpdate = !0), e && e(o));
              },
              void 0,
              i
            );
          }
          var o = new p(),
            a = new fn(this.manager);
          a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
          for (var s = 0, c = 0; c < t.length; ++c) r(c);
          return o;
        },
        setCrossOrigin: function (t) {
          return (this.crossOrigin = t), this;
        },
        setPath: function (t) {
          return (this.path = t), this;
        },
      }),
      Object.assign(gn.prototype, {
        crossOrigin: "Anonymous",
        load: function (t, e, n, i) {
          var r = new fn(this.manager);
          r.setCrossOrigin(this.crossOrigin), r.setPath(this.path);
          var o = new s();
          return (
            (o.image = r.load(
              t,
              function () {
                var n =
                  t.search(/\.(jpg|jpeg)$/) > 0 ||
                  0 === t.search(/^data\:image\/jpeg/);
                (o.format = n ? Oo : Io),
                  (o.needsUpdate = !0),
                  void 0 !== e && e(o);
              },
              n,
              i
            )),
            o
          );
        },
        setCrossOrigin: function (t) {
          return (this.crossOrigin = t), this;
        },
        setPath: function (t) {
          return (this.path = t), this;
        },
      }),
      (vn.prototype = Object.assign(Object.create(at.prototype), {
        constructor: vn,
        isLight: !0,
        copy: function (t) {
          return (
            at.prototype.copy.call(this, t),
            this.color.copy(t.color),
            (this.intensity = t.intensity),
            this
          );
        },
        toJSON: function (t) {
          var e = at.prototype.toJSON.call(this, t);
          return (
            (e.object.color = this.color.getHex()),
            (e.object.intensity = this.intensity),
            void 0 !== this.groundColor &&
              (e.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (e.object.distance = this.distance),
            void 0 !== this.angle && (e.object.angle = this.angle),
            void 0 !== this.decay && (e.object.decay = this.decay),
            void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
            e
          );
        },
      })),
      (yn.prototype = Object.assign(Object.create(vn.prototype), {
        constructor: yn,
        isHemisphereLight: !0,
        copy: function (t) {
          return (
            vn.prototype.copy.call(this, t),
            this.groundColor.copy(t.groundColor),
            this
          );
        },
      })),
      Object.assign(xn.prototype, {
        copy: function (t) {
          return (
            (this.camera = t.camera.clone()),
            (this.bias = t.bias),
            (this.radius = t.radius),
            this.mapSize.copy(t.mapSize),
            this
          );
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        toJSON: function () {
          var t = {};
          return (
            0 !== this.bias && (t.bias = this.bias),
            1 !== this.radius && (t.radius = this.radius),
            (512 === this.mapSize.x && 512 === this.mapSize.y) ||
              (t.mapSize = this.mapSize.toArray()),
            (t.camera = this.camera.toJSON(!1).object),
            delete t.camera.matrix,
            t
          );
        },
      }),
      (bn.prototype = Object.assign(Object.create(xn.prototype), {
        constructor: bn,
        isSpotLightShadow: !0,
        update: function (t) {
          var e = this.camera,
            n = 2 * sa.RAD2DEG * t.angle,
            i = this.mapSize.width / this.mapSize.height,
            r = t.distance || e.far;
          (n === e.fov && i === e.aspect && r === e.far) ||
            ((e.fov = n),
            (e.aspect = i),
            (e.far = r),
            e.updateProjectionMatrix());
        },
      })),
      (_n.prototype = Object.assign(Object.create(vn.prototype), {
        constructor: _n,
        isSpotLight: !0,
        copy: function (t) {
          return (
            vn.prototype.copy.call(this, t),
            (this.distance = t.distance),
            (this.angle = t.angle),
            (this.penumbra = t.penumbra),
            (this.decay = t.decay),
            (this.target = t.target.clone()),
            (this.shadow = t.shadow.clone()),
            this
          );
        },
      })),
      (wn.prototype = Object.assign(Object.create(vn.prototype), {
        constructor: wn,
        isPointLight: !0,
        copy: function (t) {
          return (
            vn.prototype.copy.call(this, t),
            (this.distance = t.distance),
            (this.decay = t.decay),
            (this.shadow = t.shadow.clone()),
            this
          );
        },
      })),
      (Mn.prototype = Object.assign(Object.create(xn.prototype), {
        constructor: Mn,
      })),
      (En.prototype = Object.assign(Object.create(vn.prototype), {
        constructor: En,
        isDirectionalLight: !0,
        copy: function (t) {
          return (
            vn.prototype.copy.call(this, t),
            (this.target = t.target.clone()),
            (this.shadow = t.shadow.clone()),
            this
          );
        },
      })),
      (Tn.prototype = Object.assign(Object.create(vn.prototype), {
        constructor: Tn,
        isAmbientLight: !0,
      })),
      (Sn.prototype = Object.assign(Object.create(vn.prototype), {
        constructor: Sn,
        isRectAreaLight: !0,
        copy: function (t) {
          return (
            vn.prototype.copy.call(this, t),
            (this.width = t.width),
            (this.height = t.height),
            this
          );
        },
        toJSON: function (t) {
          var e = vn.prototype.toJSON.call(this, t);
          return (
            (e.object.width = this.width), (e.object.height = this.height), e
          );
        },
      }));
    var Oa = {
      arraySlice: function (t, e, n) {
        return Oa.isTypedArray(t)
          ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length))
          : t.slice(e, n);
      },
      convertArray: function (t, e, n) {
        return !t || (!n && t.constructor === e)
          ? t
          : "number" == typeof e.BYTES_PER_ELEMENT
          ? new e(t)
          : Array.prototype.slice.call(t);
      },
      isTypedArray: function (t) {
        return ArrayBuffer.isView(t) && !(t instanceof DataView);
      },
      getKeyframeOrder: function (t) {
        for (var e = t.length, n = new Array(e), i = 0; i !== e; ++i) n[i] = i;
        return (
          n.sort(function (e, n) {
            return t[e] - t[n];
          }),
          n
        );
      },
      sortedArray: function (t, e, n) {
        for (
          var i = t.length, r = new t.constructor(i), o = 0, a = 0;
          a !== i;
          ++o
        )
          for (var s = n[o] * e, c = 0; c !== e; ++c) r[a++] = t[s + c];
        return r;
      },
      flattenJSON: function (t, e, n, i) {
        for (var r = 1, o = t[0]; void 0 !== o && void 0 === o[i]; ) o = t[r++];
        if (void 0 !== o) {
          var a = o[i];
          if (void 0 !== a)
            if (Array.isArray(a))
              do {
                void 0 !== (a = o[i]) && (e.push(o.time), n.push.apply(n, a)),
                  (o = t[r++]);
              } while (void 0 !== o);
            else if (void 0 !== a.toArray)
              do {
                void 0 !== (a = o[i]) &&
                  (e.push(o.time), a.toArray(n, n.length)),
                  (o = t[r++]);
              } while (void 0 !== o);
            else
              do {
                void 0 !== (a = o[i]) && (e.push(o.time), n.push(a)),
                  (o = t[r++]);
              } while (void 0 !== o);
        }
      },
    };
    Object.assign(An.prototype, {
      evaluate: function (t) {
        var e = this.parameterPositions,
          n = this._cachedIndex,
          i = e[n],
          r = e[n - 1];
        t: {
          e: {
            var o;
            n: {
              i: if (!(t < i)) {
                for (s = n + 2; ; ) {
                  if (void 0 === i) {
                    if (t < r) break i;
                    return (
                      (n = e.length),
                      (this._cachedIndex = n),
                      this.afterEnd_(n - 1, t, r)
                    );
                  }
                  if (n === s) break;
                  if (((r = i), (i = e[++n]), t < i)) break e;
                }
                o = e.length;
                break n;
              }
              if (t >= r) break t;
              var a = e[1];
              t < a && ((n = 2), (r = a));
              for (var s = n - 2; ; ) {
                if (void 0 === r)
                  return (this._cachedIndex = 0), this.beforeStart_(0, t, i);
                if (n === s) break;
                if (((i = r), (r = e[--n - 1]), t >= r)) break e;
              }
              (o = n), (n = 0);
            }
            for (; n < o; ) {
              var c = (n + o) >>> 1;
              t < e[c] ? (o = c) : (n = c + 1);
            }
            if (((i = e[n]), void 0 === (r = e[n - 1])))
              return (this._cachedIndex = 0), this.beforeStart_(0, t, i);
            if (void 0 === i)
              return (
                (n = e.length),
                (this._cachedIndex = n),
                this.afterEnd_(n - 1, r, t)
              );
          }
          (this._cachedIndex = n), this.intervalChanged_(n, r, i);
        }
        return this.interpolate_(n, r, t, i);
      },
      settings: null,
      DefaultSettings_: {},
      getSettings_: function () {
        return this.settings || this.DefaultSettings_;
      },
      copySampleValue_: function (t) {
        for (
          var e = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            r = t * i,
            o = 0;
          o !== i;
          ++o
        )
          e[o] = n[r + o];
        return e;
      },
      interpolate_: function () {
        throw new Error("call to abstract method");
      },
      intervalChanged_: function () {},
    }),
      Object.assign(An.prototype, {
        beforeStart_: An.prototype.copySampleValue_,
        afterEnd_: An.prototype.copySampleValue_,
      }),
      (Ln.prototype = Object.assign(Object.create(An.prototype), {
        constructor: Ln,
        DefaultSettings_: { endingStart: qo, endingEnd: qo },
        intervalChanged_: function (t, e, n) {
          var i = this.parameterPositions,
            r = t - 2,
            o = t + 1,
            a = i[r],
            s = i[o];
          if (void 0 === a)
            switch (this.getSettings_().endingStart) {
              case 2401:
                (r = t), (a = 2 * e - n);
                break;
              case 2402:
                a = e + i[(r = i.length - 2)] - i[r + 1];
                break;
              default:
                (r = t), (a = n);
            }
          if (void 0 === s)
            switch (this.getSettings_().endingEnd) {
              case 2401:
                (o = t), (s = 2 * n - e);
                break;
              case 2402:
                (o = 1), (s = n + i[1] - i[0]);
                break;
              default:
                (o = t - 1), (s = e);
            }
          var c = 0.5 * (n - e),
            l = this.valueSize;
          (this._weightPrev = c / (e - a)),
            (this._weightNext = c / (s - n)),
            (this._offsetPrev = r * l),
            (this._offsetNext = o * l);
        },
        interpolate_: function (t, e, n, i) {
          for (
            var r = this.resultBuffer,
              o = this.sampleValues,
              a = this.valueSize,
              s = t * a,
              c = s - a,
              l = this._offsetPrev,
              u = this._offsetNext,
              h = this._weightPrev,
              p = this._weightNext,
              d = (n - e) / (i - e),
              f = d * d,
              m = f * d,
              g = -h * m + 2 * h * f - h * d,
              v = (1 + h) * m + (-1.5 - 2 * h) * f + (-0.5 + h) * d + 1,
              y = (-1 - p) * m + (1.5 + p) * f + 0.5 * d,
              x = p * m - p * f,
              b = 0;
            b !== a;
            ++b
          )
            r[b] = g * o[l + b] + v * o[c + b] + y * o[s + b] + x * o[u + b];
          return r;
        },
      })),
      (Rn.prototype = Object.assign(Object.create(An.prototype), {
        constructor: Rn,
        interpolate_: function (t, e, n, i) {
          for (
            var r = this.resultBuffer,
              o = this.sampleValues,
              a = this.valueSize,
              s = t * a,
              c = s - a,
              l = (n - e) / (i - e),
              u = 1 - l,
              h = 0;
            h !== a;
            ++h
          )
            r[h] = o[c + h] * u + o[s + h] * l;
          return r;
        },
      })),
      (Pn.prototype = Object.assign(Object.create(An.prototype), {
        constructor: Pn,
        interpolate_: function (t) {
          return this.copySampleValue_(t - 1);
        },
      }));
    var Ia;
    (Ia = {
      TimeBufferType: Float32Array,
      ValueBufferType: Float32Array,
      DefaultInterpolation: 2301,
      InterpolantFactoryMethodDiscrete: function (t) {
        return new Pn(this.times, this.values, this.getValueSize(), t);
      },
      InterpolantFactoryMethodLinear: function (t) {
        return new Rn(this.times, this.values, this.getValueSize(), t);
      },
      InterpolantFactoryMethodSmooth: function (t) {
        return new Ln(this.times, this.values, this.getValueSize(), t);
      },
      setInterpolation: function (t) {
        var e;
        switch (t) {
          case 2300:
            e = this.InterpolantFactoryMethodDiscrete;
            break;
          case 2301:
            e = this.InterpolantFactoryMethodLinear;
            break;
          case 2302:
            e = this.InterpolantFactoryMethodSmooth;
        }
        if (void 0 !== e) this.createInterpolant = e;
        else {
          var n =
            "unsupported interpolation for " +
            this.ValueTypeName +
            " keyframe track named " +
            this.name;
          if (void 0 === this.createInterpolant) {
            if (t === this.DefaultInterpolation) throw new Error(n);
            this.setInterpolation(this.DefaultInterpolation);
          }
          console.warn("THREE.KeyframeTrackPrototype:", n);
        }
      },
      getInterpolation: function () {
        switch (this.createInterpolant) {
          case this.InterpolantFactoryMethodDiscrete:
            return 2300;
          case this.InterpolantFactoryMethodLinear:
            return 2301;
          case this.InterpolantFactoryMethodSmooth:
            return 2302;
        }
      },
      getValueSize: function () {
        return this.values.length / this.times.length;
      },
      shift: function (t) {
        if (0 !== t)
          for (var e = this.times, n = 0, i = e.length; n !== i; ++n) e[n] += t;
        return this;
      },
      scale: function (t) {
        if (1 !== t)
          for (var e = this.times, n = 0, i = e.length; n !== i; ++n) e[n] *= t;
        return this;
      },
      trim: function (t, e) {
        for (
          var n = this.times, i = n.length, r = 0, o = i - 1;
          r !== i && n[r] < t;

        )
          ++r;
        for (; -1 !== o && n[o] > e; ) --o;
        if ((++o, 0 !== r || o !== i)) {
          r >= o && ((o = Math.max(o, 1)), (r = o - 1));
          var a = this.getValueSize();
          (this.times = Oa.arraySlice(n, r, o)),
            (this.values = Oa.arraySlice(this.values, r * a, o * a));
        }
        return this;
      },
      validate: function () {
        var t = !0,
          e = this.getValueSize();
        e - Math.floor(e) != 0 &&
          (console.error(
            "THREE.KeyframeTrackPrototype: Invalid value size in track.",
            this
          ),
          (t = !1));
        var n = this.times,
          i = this.values,
          r = n.length;
        0 === r &&
          (console.error("THREE.KeyframeTrackPrototype: Track is empty.", this),
          (t = !1));
        for (var o = null, a = 0; a !== r; a++) {
          var s = n[a];
          if ("number" == typeof s && isNaN(s)) {
            console.error(
              "THREE.KeyframeTrackPrototype: Time is not a valid number.",
              this,
              a,
              s
            ),
              (t = !1);
            break;
          }
          if (null !== o && o > s) {
            console.error(
              "THREE.KeyframeTrackPrototype: Out of order keys.",
              this,
              a,
              s,
              o
            ),
              (t = !1);
            break;
          }
          o = s;
        }
        if (void 0 !== i && Oa.isTypedArray(i))
          for (var a = 0, c = i.length; a !== c; ++a) {
            var l = i[a];
            if (isNaN(l)) {
              console.error(
                "THREE.KeyframeTrackPrototype: Value is not a valid number.",
                this,
                a,
                l
              ),
                (t = !1);
              break;
            }
          }
        return t;
      },
      optimize: function () {
        for (
          var t = this.times,
            e = this.values,
            n = this.getValueSize(),
            i = 2302 === this.getInterpolation(),
            r = 1,
            o = t.length - 1,
            a = 1;
          a < o;
          ++a
        ) {
          var s = !1,
            c = t[a];
          if (c !== t[a + 1] && (1 !== a || c !== c[0]))
            if (i) s = !0;
            else
              for (var l = a * n, u = l - n, h = l + n, p = 0; p !== n; ++p) {
                var d = e[l + p];
                if (d !== e[u + p] || d !== e[h + p]) {
                  s = !0;
                  break;
                }
              }
          if (s) {
            if (a !== r) {
              t[r] = t[a];
              for (var f = a * n, m = r * n, p = 0; p !== n; ++p)
                e[m + p] = e[f + p];
            }
            ++r;
          }
        }
        if (o > 0) {
          t[r] = t[o];
          for (var f = o * n, m = r * n, p = 0; p !== n; ++p)
            e[m + p] = e[f + p];
          ++r;
        }
        return (
          r !== t.length &&
            ((this.times = Oa.arraySlice(t, 0, r)),
            (this.values = Oa.arraySlice(e, 0, r * n))),
          this
        );
      },
    }),
      (On.prototype = Object.assign(Object.create(Ia), {
        constructor: On,
        ValueTypeName: "vector",
      })),
      (In.prototype = Object.assign(Object.create(An.prototype), {
        constructor: In,
        interpolate_: function (t, e, n, i) {
          for (
            var o = this.resultBuffer,
              a = this.sampleValues,
              s = this.valueSize,
              c = t * s,
              l = (n - e) / (i - e),
              u = c + s;
            c !== u;
            c += 4
          )
            r.slerpFlat(o, 0, a, c - s, a, c, l);
          return o;
        },
      })),
      (Dn.prototype = Object.assign(Object.create(Ia), {
        constructor: Dn,
        ValueTypeName: "quaternion",
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodLinear: function (t) {
          return new In(this.times, this.values, this.getValueSize(), t);
        },
        InterpolantFactoryMethodSmooth: void 0,
      })),
      (Un.prototype = Object.assign(Object.create(Ia), {
        constructor: Un,
        ValueTypeName: "number",
      })),
      (Nn.prototype = Object.assign(Object.create(Ia), {
        constructor: Nn,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0,
      })),
      (zn.prototype = Object.assign(Object.create(Ia), {
        constructor: zn,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0,
      })),
      (kn.prototype = Object.assign(Object.create(Ia), {
        constructor: kn,
        ValueTypeName: "color",
      })),
      (Fn.prototype = Ia),
      (Ia.constructor = Fn),
      Object.assign(Fn, {
        parse: function (t) {
          if (void 0 === t.type)
            throw new Error("track type undefined, can not parse");
          var e = Fn._getTrackTypeForValueTypeName(t.type);
          if (void 0 === t.times) {
            var n = [],
              i = [];
            Oa.flattenJSON(t.keys, n, i, "value"),
              (t.times = n),
              (t.values = i);
          }
          return void 0 !== e.parse
            ? e.parse(t)
            : new e(t.name, t.times, t.values, t.interpolation);
        },
        toJSON: function (t) {
          var e,
            n = t.constructor;
          if (void 0 !== n.toJSON) e = n.toJSON(t);
          else {
            e = {
              name: t.name,
              times: Oa.convertArray(t.times, Array),
              values: Oa.convertArray(t.values, Array),
            };
            var i = t.getInterpolation();
            i !== t.DefaultInterpolation && (e.interpolation = i);
          }
          return (e.type = t.ValueTypeName), e;
        },
        _getTrackTypeForValueTypeName: function (t) {
          switch (t.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
              return Un;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
              return On;
            case "color":
              return kn;
            case "quaternion":
              return Dn;
            case "bool":
            case "boolean":
              return zn;
            case "string":
              return Nn;
          }
          throw new Error("Unsupported typeName: " + t);
        },
      }),
      Object.assign(Bn, {
        parse: function (t) {
          for (
            var e = [], n = t.tracks, i = 1 / (t.fps || 1), r = 0, o = n.length;
            r !== o;
            ++r
          )
            e.push(Fn.parse(n[r]).scale(i));
          return new Bn(t.name, t.duration, e);
        },
        toJSON: function (t) {
          for (
            var e = [],
              n = t.tracks,
              i = { name: t.name, duration: t.duration, tracks: e },
              r = 0,
              o = n.length;
            r !== o;
            ++r
          )
            e.push(Fn.toJSON(n[r]));
          return i;
        },
        CreateFromMorphTargetSequence: function (t, e, n, i) {
          for (var r = e.length, o = [], a = 0; a < r; a++) {
            var s = [],
              c = [];
            s.push((a + r - 1) % r, a, (a + 1) % r), c.push(0, 1, 0);
            var l = Oa.getKeyframeOrder(s);
            (s = Oa.sortedArray(s, 1, l)),
              (c = Oa.sortedArray(c, 1, l)),
              i || 0 !== s[0] || (s.push(r), c.push(c[0])),
              o.push(
                new Un(".morphTargetInfluences[" + e[a].name + "]", s, c).scale(
                  1 / n
                )
              );
          }
          return new Bn(t, -1, o);
        },
        findByName: function (t, e) {
          var n = t;
          if (!Array.isArray(t)) {
            var i = t;
            n = (i.geometry && i.geometry.animations) || i.animations;
          }
          for (var r = 0; r < n.length; r++) if (n[r].name === e) return n[r];
          return null;
        },
        CreateClipsFromMorphTargetSequences: function (t, e, n) {
          for (
            var i = {}, r = /^([\w-]*?)([\d]+)$/, o = 0, a = t.length;
            o < a;
            o++
          ) {
            var s = t[o],
              c = s.name.match(r);
            if (c && c.length > 1) {
              var l = i[(h = c[1])];
              l || (i[h] = l = []), l.push(s);
            }
          }
          var u = [];
          for (var h in i)
            u.push(Bn.CreateFromMorphTargetSequence(h, i[h], e, n));
          return u;
        },
        parseAnimation: function (t, e) {
          if (!t)
            return (
              console.error(
                "THREE.AnimationClip: No animation in JSONLoader data."
              ),
              null
            );
          for (
            var n = function (t, e, n, i, r) {
                if (0 !== n.length) {
                  var o = [],
                    a = [];
                  Oa.flattenJSON(n, o, a, i),
                    0 !== o.length && r.push(new t(e, o, a));
                }
              },
              i = [],
              r = t.name || "default",
              o = t.length || -1,
              a = t.fps || 30,
              s = t.hierarchy || [],
              c = 0;
            c < s.length;
            c++
          ) {
            var l = s[c].keys;
            if (l && 0 !== l.length)
              if (l[0].morphTargets) {
                for (var u = {}, h = 0; h < l.length; h++)
                  if (l[h].morphTargets)
                    for (m = 0; m < l[h].morphTargets.length; m++)
                      u[l[h].morphTargets[m]] = -1;
                for (var p in u) {
                  for (
                    var d = [], f = [], m = 0;
                    m !== l[h].morphTargets.length;
                    ++m
                  ) {
                    var g = l[h];
                    d.push(g.time), f.push(g.morphTarget === p ? 1 : 0);
                  }
                  i.push(new Un(".morphTargetInfluence[" + p + "]", d, f));
                }
                o = u.length * (a || 1);
              } else {
                var v = ".bones[" + e[c].name + "]";
                n(On, v + ".position", l, "pos", i),
                  n(Dn, v + ".quaternion", l, "rot", i),
                  n(On, v + ".scale", l, "scl", i);
              }
          }
          return 0 === i.length ? null : new Bn(r, o, i);
        },
      }),
      Object.assign(Bn.prototype, {
        resetDuration: function () {
          for (var t = 0, e = 0, n = this.tracks.length; e !== n; ++e) {
            var i = this.tracks[e];
            t = Math.max(t, i.times[i.times.length - 1]);
          }
          this.duration = t;
        },
        trim: function () {
          for (var t = 0; t < this.tracks.length; t++)
            this.tracks[t].trim(0, this.duration);
          return this;
        },
        optimize: function () {
          for (var t = 0; t < this.tracks.length; t++)
            this.tracks[t].optimize();
          return this;
        },
      }),
      Object.assign(Hn.prototype, {
        load: function (t, e, n, i) {
          var r = this;
          new hn(r.manager).load(
            t,
            function (t) {
              e(r.parse(JSON.parse(t)));
            },
            n,
            i
          );
        },
        setTextures: function (t) {
          this.textures = t;
        },
        parse: function (t) {
          function e(t) {
            return (
              void 0 === i[t] &&
                console.warn("THREE.MaterialLoader: Undefined texture", t),
              i[t]
            );
          }
          var i = this.textures,
            r = new La[t.type]();
          if (
            (void 0 !== t.uuid && (r.uuid = t.uuid),
            void 0 !== t.name && (r.name = t.name),
            void 0 !== t.color && r.color.setHex(t.color),
            void 0 !== t.roughness && (r.roughness = t.roughness),
            void 0 !== t.metalness && (r.metalness = t.metalness),
            void 0 !== t.emissive && r.emissive.setHex(t.emissive),
            void 0 !== t.specular && r.specular.setHex(t.specular),
            void 0 !== t.shininess && (r.shininess = t.shininess),
            void 0 !== t.clearCoat && (r.clearCoat = t.clearCoat),
            void 0 !== t.clearCoatRoughness &&
              (r.clearCoatRoughness = t.clearCoatRoughness),
            void 0 !== t.uniforms && (r.uniforms = t.uniforms),
            void 0 !== t.vertexShader && (r.vertexShader = t.vertexShader),
            void 0 !== t.fragmentShader &&
              (r.fragmentShader = t.fragmentShader),
            void 0 !== t.vertexColors && (r.vertexColors = t.vertexColors),
            void 0 !== t.fog && (r.fog = t.fog),
            void 0 !== t.flatShading && (r.flatShading = t.flatShading),
            void 0 !== t.blending && (r.blending = t.blending),
            void 0 !== t.side && (r.side = t.side),
            void 0 !== t.opacity && (r.opacity = t.opacity),
            void 0 !== t.transparent && (r.transparent = t.transparent),
            void 0 !== t.alphaTest && (r.alphaTest = t.alphaTest),
            void 0 !== t.depthTest && (r.depthTest = t.depthTest),
            void 0 !== t.depthWrite && (r.depthWrite = t.depthWrite),
            void 0 !== t.colorWrite && (r.colorWrite = t.colorWrite),
            void 0 !== t.wireframe && (r.wireframe = t.wireframe),
            void 0 !== t.wireframeLinewidth &&
              (r.wireframeLinewidth = t.wireframeLinewidth),
            void 0 !== t.wireframeLinecap &&
              (r.wireframeLinecap = t.wireframeLinecap),
            void 0 !== t.wireframeLinejoin &&
              (r.wireframeLinejoin = t.wireframeLinejoin),
            void 0 !== t.rotation && (r.rotation = t.rotation),
            1 !== t.linewidth && (r.linewidth = t.linewidth),
            void 0 !== t.dashSize && (r.dashSize = t.dashSize),
            void 0 !== t.gapSize && (r.gapSize = t.gapSize),
            void 0 !== t.scale && (r.scale = t.scale),
            void 0 !== t.skinning && (r.skinning = t.skinning),
            void 0 !== t.morphTargets && (r.morphTargets = t.morphTargets),
            void 0 !== t.dithering && (r.dithering = t.dithering),
            void 0 !== t.visible && (r.visible = t.visible),
            void 0 !== t.userData && (r.userData = t.userData),
            void 0 !== t.shading && (r.flatShading = 1 === t.shading),
            void 0 !== t.size && (r.size = t.size),
            void 0 !== t.sizeAttenuation &&
              (r.sizeAttenuation = t.sizeAttenuation),
            void 0 !== t.map && (r.map = e(t.map)),
            void 0 !== t.alphaMap &&
              ((r.alphaMap = e(t.alphaMap)), (r.transparent = !0)),
            void 0 !== t.bumpMap && (r.bumpMap = e(t.bumpMap)),
            void 0 !== t.bumpScale && (r.bumpScale = t.bumpScale),
            void 0 !== t.normalMap && (r.normalMap = e(t.normalMap)),
            void 0 !== t.normalScale)
          ) {
            var o = t.normalScale;
            !1 === Array.isArray(o) && (o = [o, o]),
              (r.normalScale = new n().fromArray(o));
          }
          return (
            void 0 !== t.displacementMap &&
              (r.displacementMap = e(t.displacementMap)),
            void 0 !== t.displacementScale &&
              (r.displacementScale = t.displacementScale),
            void 0 !== t.displacementBias &&
              (r.displacementBias = t.displacementBias),
            void 0 !== t.roughnessMap && (r.roughnessMap = e(t.roughnessMap)),
            void 0 !== t.metalnessMap && (r.metalnessMap = e(t.metalnessMap)),
            void 0 !== t.emissiveMap && (r.emissiveMap = e(t.emissiveMap)),
            void 0 !== t.emissiveIntensity &&
              (r.emissiveIntensity = t.emissiveIntensity),
            void 0 !== t.specularMap && (r.specularMap = e(t.specularMap)),
            void 0 !== t.envMap && (r.envMap = e(t.envMap)),
            void 0 !== t.reflectivity && (r.reflectivity = t.reflectivity),
            void 0 !== t.lightMap && (r.lightMap = e(t.lightMap)),
            void 0 !== t.lightMapIntensity &&
              (r.lightMapIntensity = t.lightMapIntensity),
            void 0 !== t.aoMap && (r.aoMap = e(t.aoMap)),
            void 0 !== t.aoMapIntensity &&
              (r.aoMapIntensity = t.aoMapIntensity),
            void 0 !== t.gradientMap && (r.gradientMap = e(t.gradientMap)),
            r
          );
        },
      }),
      Object.assign(jn.prototype, {
        load: function (t, e, n, i) {
          var r = this;
          new hn(r.manager).load(
            t,
            function (t) {
              e(r.parse(JSON.parse(t)));
            },
            n,
            i
          );
        },
        parse: function (t) {
          var e = new Mt(),
            n = t.data.index;
          void 0 !== n &&
            ((s = new Da[n.type](n.array)), e.setIndex(new ht(s, 1)));
          var i = t.data.attributes;
          for (var r in i) {
            var a = i[r],
              s = new Da[a.type](a.array);
            e.addAttribute(r, new ht(s, a.itemSize, a.normalized));
          }
          var c = t.data.groups || t.data.drawcalls || t.data.offsets;
          if (void 0 !== c)
            for (var l = 0, u = c.length; l !== u; ++l) {
              var h = c[l];
              e.addGroup(h.start, h.count, h.materialIndex);
            }
          var p = t.data.boundingSphere;
          if (void 0 !== p) {
            var d = new o();
            void 0 !== p.center && d.fromArray(p.center),
              (e.boundingSphere = new tt(d, p.radius));
          }
          return e;
        },
      });
    var Da = {
      Int8Array: Int8Array,
      Uint8Array: Uint8Array,
      Uint8ClampedArray:
        "undefined" != typeof Uint8ClampedArray
          ? Uint8ClampedArray
          : Uint8Array,
      Int16Array: Int16Array,
      Uint16Array: Uint16Array,
      Int32Array: Int32Array,
      Uint32Array: Uint32Array,
      Float32Array: Float32Array,
      Float64Array: Float64Array,
    };
    (Gn.Handlers = {
      handlers: [],
      add: function (t, e) {
        this.handlers.push(t, e);
      },
      get: function (t) {
        for (var e = this.handlers, n = 0, i = e.length; n < i; n += 2) {
          var r = e[n],
            o = e[n + 1];
          if (r.test(t)) return o;
        }
        return null;
      },
    }),
      Object.assign(Gn.prototype, {
        crossOrigin: void 0,
        extractUrlBase: function (t) {
          var e = t.split("/");
          return 1 === e.length ? "./" : (e.pop(), e.join("/") + "/");
        },
        initMaterials: function (t, e, n) {
          for (var i = [], r = 0; r < t.length; ++r)
            i[r] = this.createMaterial(t[r], e, n);
          return i;
        },
        createMaterial: (function () {
          var t = {
              NoBlending: yr,
              NormalBlending: xr,
              AdditiveBlending: br,
              SubtractiveBlending: _r,
              MultiplyBlending: wr,
              CustomBlending: Mr,
            },
            e = new W(),
            n = new gn(),
            i = new Hn();
          return function (r, o, a) {
            function s(t, e, i, r, s) {
              var l,
                u = o + t,
                h = Gn.Handlers.get(u);
              null !== h
                ? (l = h.load(u))
                : (n.setCrossOrigin(a), (l = n.load(u))),
                void 0 !== e &&
                  (l.repeat.fromArray(e),
                  1 !== e[0] && (l.wrapS = lo),
                  1 !== e[1] && (l.wrapT = lo)),
                void 0 !== i && l.offset.fromArray(i),
                void 0 !== r &&
                  ("repeat" === r[0] && (l.wrapS = lo),
                  "mirror" === r[0] && (l.wrapS = ho),
                  "repeat" === r[1] && (l.wrapT = lo),
                  "mirror" === r[1] && (l.wrapT = ho)),
                void 0 !== s && (l.anisotropy = s);
              var p = sa.generateUUID();
              return (c[p] = l), p;
            }
            var c = {},
              l = { uuid: sa.generateUUID(), type: "MeshLambertMaterial" };
            for (var u in r) {
              var h = r[u];
              switch (u) {
                case "DbgColor":
                case "DbgIndex":
                case "opticalDensity":
                case "illumination":
                  break;
                case "DbgName":
                  l.name = h;
                  break;
                case "blending":
                  l.blending = t[h];
                  break;
                case "colorAmbient":
                case "mapAmbient":
                  console.warn(
                    "THREE.Loader.createMaterial:",
                    u,
                    "is no longer supported."
                  );
                  break;
                case "colorDiffuse":
                  l.color = e.fromArray(h).getHex();
                  break;
                case "colorSpecular":
                  l.specular = e.fromArray(h).getHex();
                  break;
                case "colorEmissive":
                  l.emissive = e.fromArray(h).getHex();
                  break;
                case "specularCoef":
                  l.shininess = h;
                  break;
                case "shading":
                  "basic" === h.toLowerCase() && (l.type = "MeshBasicMaterial"),
                    "phong" === h.toLowerCase() &&
                      (l.type = "MeshPhongMaterial"),
                    "standard" === h.toLowerCase() &&
                      (l.type = "MeshStandardMaterial");
                  break;
                case "mapDiffuse":
                  l.map = s(
                    h,
                    r.mapDiffuseRepeat,
                    r.mapDiffuseOffset,
                    r.mapDiffuseWrap,
                    r.mapDiffuseAnisotropy
                  );
                  break;
                case "mapDiffuseRepeat":
                case "mapDiffuseOffset":
                case "mapDiffuseWrap":
                case "mapDiffuseAnisotropy":
                  break;
                case "mapEmissive":
                  l.emissiveMap = s(
                    h,
                    r.mapEmissiveRepeat,
                    r.mapEmissiveOffset,
                    r.mapEmissiveWrap,
                    r.mapEmissiveAnisotropy
                  );
                  break;
                case "mapEmissiveRepeat":
                case "mapEmissiveOffset":
                case "mapEmissiveWrap":
                case "mapEmissiveAnisotropy":
                  break;
                case "mapLight":
                  l.lightMap = s(
                    h,
                    r.mapLightRepeat,
                    r.mapLightOffset,
                    r.mapLightWrap,
                    r.mapLightAnisotropy
                  );
                  break;
                case "mapLightRepeat":
                case "mapLightOffset":
                case "mapLightWrap":
                case "mapLightAnisotropy":
                  break;
                case "mapAO":
                  l.aoMap = s(
                    h,
                    r.mapAORepeat,
                    r.mapAOOffset,
                    r.mapAOWrap,
                    r.mapAOAnisotropy
                  );
                  break;
                case "mapAORepeat":
                case "mapAOOffset":
                case "mapAOWrap":
                case "mapAOAnisotropy":
                  break;
                case "mapBump":
                  l.bumpMap = s(
                    h,
                    r.mapBumpRepeat,
                    r.mapBumpOffset,
                    r.mapBumpWrap,
                    r.mapBumpAnisotropy
                  );
                  break;
                case "mapBumpScale":
                  l.bumpScale = h;
                  break;
                case "mapBumpRepeat":
                case "mapBumpOffset":
                case "mapBumpWrap":
                case "mapBumpAnisotropy":
                  break;
                case "mapNormal":
                  l.normalMap = s(
                    h,
                    r.mapNormalRepeat,
                    r.mapNormalOffset,
                    r.mapNormalWrap,
                    r.mapNormalAnisotropy
                  );
                  break;
                case "mapNormalFactor":
                  l.normalScale = [h, h];
                  break;
                case "mapNormalRepeat":
                case "mapNormalOffset":
                case "mapNormalWrap":
                case "mapNormalAnisotropy":
                  break;
                case "mapSpecular":
                  l.specularMap = s(
                    h,
                    r.mapSpecularRepeat,
                    r.mapSpecularOffset,
                    r.mapSpecularWrap,
                    r.mapSpecularAnisotropy
                  );
                  break;
                case "mapSpecularRepeat":
                case "mapSpecularOffset":
                case "mapSpecularWrap":
                case "mapSpecularAnisotropy":
                  break;
                case "mapMetalness":
                  l.metalnessMap = s(
                    h,
                    r.mapMetalnessRepeat,
                    r.mapMetalnessOffset,
                    r.mapMetalnessWrap,
                    r.mapMetalnessAnisotropy
                  );
                  break;
                case "mapMetalnessRepeat":
                case "mapMetalnessOffset":
                case "mapMetalnessWrap":
                case "mapMetalnessAnisotropy":
                  break;
                case "mapRoughness":
                  l.roughnessMap = s(
                    h,
                    r.mapRoughnessRepeat,
                    r.mapRoughnessOffset,
                    r.mapRoughnessWrap,
                    r.mapRoughnessAnisotropy
                  );
                  break;
                case "mapRoughnessRepeat":
                case "mapRoughnessOffset":
                case "mapRoughnessWrap":
                case "mapRoughnessAnisotropy":
                  break;
                case "mapAlpha":
                  l.alphaMap = s(
                    h,
                    r.mapAlphaRepeat,
                    r.mapAlphaOffset,
                    r.mapAlphaWrap,
                    r.mapAlphaAnisotropy
                  );
                  break;
                case "mapAlphaRepeat":
                case "mapAlphaOffset":
                case "mapAlphaWrap":
                case "mapAlphaAnisotropy":
                  break;
                case "flipSided":
                  l.side = dr;
                  break;
                case "doubleSided":
                  l.side = fr;
                  break;
                case "transparency":
                  console.warn(
                    "THREE.Loader.createMaterial: transparency has been renamed to opacity"
                  ),
                    (l.opacity = h);
                  break;
                case "depthTest":
                case "depthWrite":
                case "colorWrite":
                case "opacity":
                case "reflectivity":
                case "transparent":
                case "visible":
                case "wireframe":
                  l[u] = h;
                  break;
                case "vertexColors":
                  !0 === h && (l.vertexColors = vr),
                    "face" === h && (l.vertexColors = gr);
                  break;
                default:
                  console.error(
                    "THREE.Loader.createMaterial: Unsupported",
                    u,
                    h
                  );
              }
            }
            return (
              "MeshBasicMaterial" === l.type && delete l.emissive,
              "MeshPhongMaterial" !== l.type && delete l.specular,
              l.opacity < 1 && (l.transparent = !0),
              i.setTextures(c),
              i.parse(l)
            );
          };
        })(),
      }),
      Object.assign(Vn.prototype, {
        load: function (t, e, n, i) {
          var r = this,
            o =
              this.texturePath && "string" == typeof this.texturePath
                ? this.texturePath
                : Gn.prototype.extractUrlBase(t),
            a = new hn(this.manager);
          a.setWithCredentials(this.withCredentials),
            a.load(
              t,
              function (n) {
                var i = JSON.parse(n),
                  a = i.metadata;
                if (void 0 !== a) {
                  var s = a.type;
                  if (void 0 !== s) {
                    if ("object" === s.toLowerCase())
                      return void console.error(
                        "THREE.JSONLoader: " +
                          t +
                          " should be loaded with THREE.ObjectLoader instead."
                      );
                    if ("scene" === s.toLowerCase())
                      return void console.error(
                        "THREE.JSONLoader: " +
                          t +
                          " should be loaded with THREE.SceneLoader instead."
                      );
                  }
                }
                var c = r.parse(i, o);
                e(c.geometry, c.materials);
              },
              n,
              i
            );
        },
        setTexturePath: function (t) {
          this.texturePath = t;
        },
        parse: function (t, e) {
          void 0 !== t.data && (t = t.data),
            void 0 !== t.scale ? (t.scale = 1 / t.scale) : (t.scale = 1);
          var i = new ut();
          return (
            (function (t, e) {
              function i(t, e) {
                return t & (1 << e);
              }
              var r,
                a,
                s,
                c,
                l,
                u,
                h,
                p,
                d,
                f,
                m,
                g,
                v,
                y,
                x,
                b,
                _,
                w,
                M,
                E,
                T,
                S,
                A,
                L,
                R,
                P = t.faces,
                C = t.vertices,
                O = t.normals,
                I = t.colors,
                D = t.scale,
                U = 0;
              if (void 0 !== t.uvs) {
                for (r = 0; r < t.uvs.length; r++) t.uvs[r].length && U++;
                for (r = 0; r < U; r++) e.faceVertexUvs[r] = [];
              }
              for (c = 0, l = C.length; c < l; )
                ((w = new o()).x = C[c++] * D),
                  (w.y = C[c++] * D),
                  (w.z = C[c++] * D),
                  e.vertices.push(w);
              for (c = 0, l = P.length; c < l; )
                if (
                  ((f = P[c++]),
                  (m = i(f, 0)),
                  (g = i(f, 1)),
                  (v = i(f, 3)),
                  (y = i(f, 4)),
                  (x = i(f, 5)),
                  (b = i(f, 6)),
                  (_ = i(f, 7)),
                  m)
                ) {
                  if (
                    ((E = new lt()),
                    (E.a = P[c]),
                    (E.b = P[c + 1]),
                    (E.c = P[c + 3]),
                    (T = new lt()),
                    (T.a = P[c + 1]),
                    (T.b = P[c + 2]),
                    (T.c = P[c + 3]),
                    (c += 4),
                    g &&
                      ((d = P[c++]),
                      (E.materialIndex = d),
                      (T.materialIndex = d)),
                    (s = e.faces.length),
                    v)
                  )
                    for (r = 0; r < U; r++)
                      for (
                        L = t.uvs[r],
                          e.faceVertexUvs[r][s] = [],
                          e.faceVertexUvs[r][s + 1] = [],
                          a = 0;
                        a < 4;
                        a++
                      )
                        (R = new n(L[2 * (p = P[c++])], L[2 * p + 1])),
                          2 !== a && e.faceVertexUvs[r][s].push(R),
                          0 !== a && e.faceVertexUvs[r][s + 1].push(R);
                  if (
                    (y &&
                      ((h = 3 * P[c++]),
                      E.normal.set(O[h++], O[h++], O[h]),
                      T.normal.copy(E.normal)),
                    x)
                  )
                    for (r = 0; r < 4; r++)
                      (h = 3 * P[c++]),
                        (A = new o(O[h++], O[h++], O[h])),
                        2 !== r && E.vertexNormals.push(A),
                        0 !== r && T.vertexNormals.push(A);
                  if (
                    (b &&
                      ((S = I[(u = P[c++])]),
                      E.color.setHex(S),
                      T.color.setHex(S)),
                    _)
                  )
                    for (r = 0; r < 4; r++)
                      (S = I[(u = P[c++])]),
                        2 !== r && E.vertexColors.push(new W(S)),
                        0 !== r && T.vertexColors.push(new W(S));
                  e.faces.push(E), e.faces.push(T);
                } else {
                  if (
                    ((M = new lt()),
                    (M.a = P[c++]),
                    (M.b = P[c++]),
                    (M.c = P[c++]),
                    g && ((d = P[c++]), (M.materialIndex = d)),
                    (s = e.faces.length),
                    v)
                  )
                    for (r = 0; r < U; r++)
                      for (
                        L = t.uvs[r], e.faceVertexUvs[r][s] = [], a = 0;
                        a < 3;
                        a++
                      )
                        (R = new n(L[2 * (p = P[c++])], L[2 * p + 1])),
                          e.faceVertexUvs[r][s].push(R);
                  if (
                    (y &&
                      ((h = 3 * P[c++]), M.normal.set(O[h++], O[h++], O[h])),
                    x)
                  )
                    for (r = 0; r < 3; r++)
                      (h = 3 * P[c++]),
                        (A = new o(O[h++], O[h++], O[h])),
                        M.vertexNormals.push(A);
                  if ((b && ((u = P[c++]), M.color.setHex(I[u])), _))
                    for (r = 0; r < 3; r++)
                      (u = P[c++]), M.vertexColors.push(new W(I[u]));
                  e.faces.push(M);
                }
            })(t, i),
            (function (t, e) {
              var n =
                void 0 !== t.influencesPerVertex ? t.influencesPerVertex : 2;
              if (t.skinWeights)
                for (var i = 0, r = t.skinWeights.length; i < r; i += n) {
                  var o = t.skinWeights[i],
                    a = n > 1 ? t.skinWeights[i + 1] : 0,
                    s = n > 2 ? t.skinWeights[i + 2] : 0,
                    l = n > 3 ? t.skinWeights[i + 3] : 0;
                  e.skinWeights.push(new c(o, a, s, l));
                }
              if (t.skinIndices)
                for (var i = 0, r = t.skinIndices.length; i < r; i += n) {
                  var u = t.skinIndices[i],
                    h = n > 1 ? t.skinIndices[i + 1] : 0,
                    p = n > 2 ? t.skinIndices[i + 2] : 0,
                    d = n > 3 ? t.skinIndices[i + 3] : 0;
                  e.skinIndices.push(new c(u, h, p, d));
                }
              (e.bones = t.bones),
                e.bones &&
                  e.bones.length > 0 &&
                  (e.skinWeights.length !== e.skinIndices.length ||
                    e.skinIndices.length !== e.vertices.length) &&
                  console.warn(
                    "When skinning, number of vertices (" +
                      e.vertices.length +
                      "), skinIndices (" +
                      e.skinIndices.length +
                      "), and skinWeights (" +
                      e.skinWeights.length +
                      ") should match."
                  );
            })(t, i),
            (function (t, e) {
              var n = t.scale;
              if (void 0 !== t.morphTargets)
                for (var i = 0, r = t.morphTargets.length; i < r; i++) {
                  (e.morphTargets[i] = {}),
                    (e.morphTargets[i].name = t.morphTargets[i].name),
                    (e.morphTargets[i].vertices = []);
                  for (
                    var a = e.morphTargets[i].vertices,
                      s = t.morphTargets[i].vertices,
                      c = 0,
                      l = s.length;
                    c < l;
                    c += 3
                  ) {
                    var u = new o();
                    (u.x = s[c] * n),
                      (u.y = s[c + 1] * n),
                      (u.z = s[c + 2] * n),
                      a.push(u);
                  }
                }
              if (void 0 !== t.morphColors && t.morphColors.length > 0) {
                console.warn(
                  'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'
                );
                for (
                  var h = e.faces,
                    p = t.morphColors[0].colors,
                    i = 0,
                    r = h.length;
                  i < r;
                  i++
                )
                  h[i].color.fromArray(p, 3 * i);
              }
            })(t, i),
            (function (t, e) {
              var n = [],
                i = [];
              void 0 !== t.animation && i.push(t.animation),
                void 0 !== t.animations &&
                  (t.animations.length
                    ? (i = i.concat(t.animations))
                    : i.push(t.animations));
              for (var r = 0; r < i.length; r++) {
                var o = Bn.parseAnimation(i[r], e.bones);
                o && n.push(o);
              }
              if (e.morphTargets) {
                var a = Bn.CreateClipsFromMorphTargetSequences(
                  e.morphTargets,
                  10
                );
                n = n.concat(a);
              }
              n.length > 0 && (e.animations = n);
            })(t, i),
            i.computeFaceNormals(),
            i.computeBoundingSphere(),
            void 0 === t.materials || 0 === t.materials.length
              ? { geometry: i }
              : {
                  geometry: i,
                  materials: Gn.prototype.initMaterials(
                    t.materials,
                    e,
                    this.crossOrigin
                  ),
                }
          );
        },
      }),
      Object.assign(Wn.prototype, {
        load: function (t, e, n, i) {
          "" === this.texturePath &&
            (this.texturePath = t.substring(0, t.lastIndexOf("/") + 1));
          var r = this;
          new hn(r.manager).load(
            t,
            function (n) {
              var o = null;
              try {
                o = JSON.parse(n);
              } catch (e) {
                return (
                  void 0 !== i && i(e),
                  void console.error(
                    "THREE:ObjectLoader: Can't parse " + t + ".",
                    e.message
                  )
                );
              }
              var a = o.metadata;
              void 0 !== a &&
              void 0 !== a.type &&
              "geometry" !== a.type.toLowerCase()
                ? r.parse(o, e)
                : console.error(
                    "THREE.ObjectLoader: Can't load " +
                      t +
                      ". Use THREE.JSONLoader instead."
                  );
            },
            n,
            i
          );
        },
        setTexturePath: function (t) {
          this.texturePath = t;
        },
        setCrossOrigin: function (t) {
          this.crossOrigin = t;
        },
        parse: function (t, e) {
          var n = this.parseGeometries(t.geometries),
            i = this.parseImages(t.images, function () {
              void 0 !== e && e(a);
            }),
            r = this.parseTextures(t.textures, i),
            o = this.parseMaterials(t.materials, r),
            a = this.parseObject(t.object, n, o);
          return (
            t.animations && (a.animations = this.parseAnimations(t.animations)),
            (void 0 !== t.images && 0 !== t.images.length) ||
              (void 0 !== e && e(a)),
            a
          );
        },
        parseGeometries: function (t) {
          var e = {};
          if (void 0 !== t)
            for (
              var n = new Vn(), i = new jn(), r = 0, o = t.length;
              r < o;
              r++
            ) {
              var a,
                s = t[r];
              switch (s.type) {
                case "PlaneGeometry":
                case "PlaneBufferGeometry":
                  a = new Aa[s.type](
                    s.width,
                    s.height,
                    s.widthSegments,
                    s.heightSegments
                  );
                  break;
                case "BoxGeometry":
                case "BoxBufferGeometry":
                case "CubeGeometry":
                  a = new Aa[s.type](
                    s.width,
                    s.height,
                    s.depth,
                    s.widthSegments,
                    s.heightSegments,
                    s.depthSegments
                  );
                  break;
                case "CircleGeometry":
                case "CircleBufferGeometry":
                  a = new Aa[s.type](
                    s.radius,
                    s.segments,
                    s.thetaStart,
                    s.thetaLength
                  );
                  break;
                case "CylinderGeometry":
                case "CylinderBufferGeometry":
                  a = new Aa[s.type](
                    s.radiusTop,
                    s.radiusBottom,
                    s.height,
                    s.radialSegments,
                    s.heightSegments,
                    s.openEnded,
                    s.thetaStart,
                    s.thetaLength
                  );
                  break;
                case "ConeGeometry":
                case "ConeBufferGeometry":
                  a = new Aa[s.type](
                    s.radius,
                    s.height,
                    s.radialSegments,
                    s.heightSegments,
                    s.openEnded,
                    s.thetaStart,
                    s.thetaLength
                  );
                  break;
                case "SphereGeometry":
                case "SphereBufferGeometry":
                  a = new Aa[s.type](
                    s.radius,
                    s.widthSegments,
                    s.heightSegments,
                    s.phiStart,
                    s.phiLength,
                    s.thetaStart,
                    s.thetaLength
                  );
                  break;
                case "DodecahedronGeometry":
                case "DodecahedronBufferGeometry":
                case "IcosahedronGeometry":
                case "IcosahedronBufferGeometry":
                case "OctahedronGeometry":
                case "OctahedronBufferGeometry":
                case "TetrahedronGeometry":
                case "TetrahedronBufferGeometry":
                  a = new Aa[s.type](s.radius, s.detail);
                  break;
                case "RingGeometry":
                case "RingBufferGeometry":
                  a = new Aa[s.type](
                    s.innerRadius,
                    s.outerRadius,
                    s.thetaSegments,
                    s.phiSegments,
                    s.thetaStart,
                    s.thetaLength
                  );
                  break;
                case "TorusGeometry":
                case "TorusBufferGeometry":
                  a = new Aa[s.type](
                    s.radius,
                    s.tube,
                    s.radialSegments,
                    s.tubularSegments,
                    s.arc
                  );
                  break;
                case "TorusKnotGeometry":
                case "TorusKnotBufferGeometry":
                  a = new Aa[s.type](
                    s.radius,
                    s.tube,
                    s.tubularSegments,
                    s.radialSegments,
                    s.p,
                    s.q
                  );
                  break;
                case "LatheGeometry":
                case "LatheBufferGeometry":
                  a = new Aa[s.type](
                    s.points,
                    s.segments,
                    s.phiStart,
                    s.phiLength
                  );
                  break;
                case "PolyhedronGeometry":
                case "PolyhedronBufferGeometry":
                  a = new Aa[s.type](
                    s.vertices,
                    s.indices,
                    s.radius,
                    s.details
                  );
                  break;
                case "BufferGeometry":
                  a = i.parse(s);
                  break;
                case "Geometry":
                  a = n.parse(s, this.texturePath).geometry;
                  break;
                default:
                  console.warn(
                    'THREE.ObjectLoader: Unsupported geometry type "' +
                      s.type +
                      '"'
                  );
                  continue;
              }
              (a.uuid = s.uuid),
                void 0 !== s.name && (a.name = s.name),
                (e[s.uuid] = a);
            }
          return e;
        },
        parseMaterials: function (t, e) {
          var n = {};
          if (void 0 !== t) {
            var i = new Hn();
            i.setTextures(e);
            for (var r = 0, o = t.length; r < o; r++) {
              var a = t[r];
              if ("MultiMaterial" === a.type) {
                for (var s = [], c = 0; c < a.materials.length; c++)
                  s.push(i.parse(a.materials[c]));
                n[a.uuid] = s;
              } else n[a.uuid] = i.parse(a);
            }
          }
          return n;
        },
        parseAnimations: function (t) {
          for (var e = [], n = 0; n < t.length; n++) {
            var i = Bn.parse(t[n]);
            e.push(i);
          }
          return e;
        },
        parseImages: function (t, e) {
          function n(t) {
            return (
              i.manager.itemStart(t),
              o.load(
                t,
                function () {
                  i.manager.itemEnd(t);
                },
                void 0,
                function () {
                  i.manager.itemEnd(t), i.manager.itemError(t);
                }
              )
            );
          }
          var i = this,
            r = {};
          if (void 0 !== t && t.length > 0) {
            var o = new fn(new un(e));
            o.setCrossOrigin(this.crossOrigin);
            for (var a = 0, s = t.length; a < s; a++) {
              var c = t[a],
                l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url)
                  ? c.url
                  : i.texturePath + c.url;
              r[c.uuid] = n(l);
            }
          }
          return r;
        },
        parseTextures: function (t, e) {
          function n(t, e) {
            return "number" == typeof t
              ? t
              : (console.warn(
                  "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
                  t
                ),
                e[t]);
          }
          var i = {};
          if (void 0 !== t)
            for (var r = 0, o = t.length; r < o; r++) {
              var a = t[r];
              void 0 === a.image &&
                console.warn(
                  'THREE.ObjectLoader: No "image" specified for',
                  a.uuid
                ),
                void 0 === e[a.image] &&
                  console.warn("THREE.ObjectLoader: Undefined image", a.image);
              var c = new s(e[a.image]);
              (c.needsUpdate = !0),
                (c.uuid = a.uuid),
                void 0 !== a.name && (c.name = a.name),
                void 0 !== a.mapping && (c.mapping = n(a.mapping, Ua)),
                void 0 !== a.offset && c.offset.fromArray(a.offset),
                void 0 !== a.repeat && c.repeat.fromArray(a.repeat),
                void 0 !== a.center && c.center.fromArray(a.center),
                void 0 !== a.rotation && (c.rotation = a.rotation),
                void 0 !== a.wrap &&
                  ((c.wrapS = n(a.wrap[0], Na)), (c.wrapT = n(a.wrap[1], Na))),
                void 0 !== a.minFilter && (c.minFilter = n(a.minFilter, za)),
                void 0 !== a.magFilter && (c.magFilter = n(a.magFilter, za)),
                void 0 !== a.anisotropy && (c.anisotropy = a.anisotropy),
                void 0 !== a.flipY && (c.flipY = a.flipY),
                (i[a.uuid] = c);
            }
          return i;
        },
        parseObject: (function () {
          var t = new i();
          return function (e, n, i) {
            function r(t) {
              return (
                void 0 === n[t] &&
                  console.warn("THREE.ObjectLoader: Undefined geometry", t),
                n[t]
              );
            }
            function o(t) {
              if (void 0 !== t) {
                if (Array.isArray(t)) {
                  for (var e = [], n = 0, r = t.length; n < r; n++) {
                    var o = t[n];
                    void 0 === i[o] &&
                      console.warn("THREE.ObjectLoader: Undefined material", o),
                      e.push(i[o]);
                  }
                  return e;
                }
                return (
                  void 0 === i[t] &&
                    console.warn("THREE.ObjectLoader: Undefined material", t),
                  i[t]
                );
              }
            }
            var a;
            switch (e.type) {
              case "Scene":
                (a = new Qt()),
                  void 0 !== e.background &&
                    Number.isInteger(e.background) &&
                    (a.background = new W(e.background)),
                  void 0 !== e.fog &&
                    ("Fog" === e.fog.type
                      ? (a.fog = new Jt(e.fog.color, e.fog.near, e.fog.far))
                      : "FogExp2" === e.fog.type &&
                        (a.fog = new Zt(e.fog.color, e.fog.density)));
                break;
              case "PerspectiveCamera":
                (a = new Xt(e.fov, e.aspect, e.near, e.far)),
                  void 0 !== e.focus && (a.focus = e.focus),
                  void 0 !== e.zoom && (a.zoom = e.zoom),
                  void 0 !== e.filmGauge && (a.filmGauge = e.filmGauge),
                  void 0 !== e.filmOffset && (a.filmOffset = e.filmOffset),
                  void 0 !== e.view && (a.view = Object.assign({}, e.view));
                break;
              case "OrthographicCamera":
                a = new ct(e.left, e.right, e.top, e.bottom, e.near, e.far);
                break;
              case "AmbientLight":
                a = new Tn(e.color, e.intensity);
                break;
              case "DirectionalLight":
                a = new En(e.color, e.intensity);
                break;
              case "PointLight":
                a = new wn(e.color, e.intensity, e.distance, e.decay);
                break;
              case "RectAreaLight":
                a = new Sn(e.color, e.intensity, e.width, e.height);
                break;
              case "SpotLight":
                a = new _n(
                  e.color,
                  e.intensity,
                  e.distance,
                  e.angle,
                  e.penumbra,
                  e.decay
                );
                break;
              case "HemisphereLight":
                a = new yn(e.color, e.groundColor, e.intensity);
                break;
              case "SkinnedMesh":
                console.warn(
                  "THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet."
                );
              case "Mesh":
                var s = r(e.geometry),
                  c = o(e.material);
                a = s.bones && s.bones.length > 0 ? new oe(s, c) : new It(s, c);
                break;
              case "LOD":
                a = new ne();
                break;
              case "Line":
                a = new se(r(e.geometry), o(e.material), e.mode);
                break;
              case "LineLoop":
                a = new le(r(e.geometry), o(e.material));
                break;
              case "LineSegments":
                a = new ce(r(e.geometry), o(e.material));
                break;
              case "PointCloud":
              case "Points":
                a = new he(r(e.geometry), o(e.material));
                break;
              case "Sprite":
                a = new ee(o(e.material));
                break;
              case "Group":
                a = new pe();
                break;
              default:
                a = new at();
            }
            if (
              ((a.uuid = e.uuid),
              void 0 !== e.name && (a.name = e.name),
              void 0 !== e.matrix
                ? (t.fromArray(e.matrix),
                  t.decompose(a.position, a.quaternion, a.scale))
                : (void 0 !== e.position && a.position.fromArray(e.position),
                  void 0 !== e.rotation && a.rotation.fromArray(e.rotation),
                  void 0 !== e.quaternion &&
                    a.quaternion.fromArray(e.quaternion),
                  void 0 !== e.scale && a.scale.fromArray(e.scale)),
              void 0 !== e.castShadow && (a.castShadow = e.castShadow),
              void 0 !== e.receiveShadow && (a.receiveShadow = e.receiveShadow),
              e.shadow &&
                (void 0 !== e.shadow.bias && (a.shadow.bias = e.shadow.bias),
                void 0 !== e.shadow.radius &&
                  (a.shadow.radius = e.shadow.radius),
                void 0 !== e.shadow.mapSize &&
                  a.shadow.mapSize.fromArray(e.shadow.mapSize),
                void 0 !== e.shadow.camera &&
                  (a.shadow.camera = this.parseObject(e.shadow.camera))),
              void 0 !== e.visible && (a.visible = e.visible),
              void 0 !== e.userData && (a.userData = e.userData),
              void 0 !== e.children)
            )
              for (var l = e.children, u = 0; u < l.length; u++)
                a.add(this.parseObject(l[u], n, i));
            if ("LOD" === e.type)
              for (var h = e.levels, p = 0; p < h.length; p++) {
                var d = h[p],
                  f = a.getObjectByProperty("uuid", d.object);
                void 0 !== f && a.addLevel(f, d.distance);
              }
            return a;
          };
        })(),
      });
    var Ua = {
        UVMapping: 300,
        CubeReflectionMapping: no,
        CubeRefractionMapping: io,
        EquirectangularReflectionMapping: ro,
        EquirectangularRefractionMapping: oo,
        SphericalReflectionMapping: ao,
        CubeUVReflectionMapping: so,
        CubeUVRefractionMapping: co,
      },
      Na = {
        RepeatWrapping: lo,
        ClampToEdgeWrapping: uo,
        MirroredRepeatWrapping: ho,
      },
      za = {
        NearestFilter: po,
        NearestMipMapNearestFilter: fo,
        NearestMipMapLinearFilter: mo,
        LinearFilter: go,
        LinearMipMapNearestFilter: vo,
        LinearMipMapLinearFilter: yo,
      };
    Object.assign($n.prototype, {
      getPoint: function () {
        return console.warn("THREE.Curve: .getPoint() not implemented."), null;
      },
      getPointAt: function (t, e) {
        var n = this.getUtoTmapping(t);
        return this.getPoint(n, e);
      },
      getPoints: function (t) {
        void 0 === t && (t = 5);
        for (var e = [], n = 0; n <= t; n++) e.push(this.getPoint(n / t));
        return e;
      },
      getSpacedPoints: function (t) {
        void 0 === t && (t = 5);
        for (var e = [], n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
        return e;
      },
      getLength: function () {
        var t = this.getLengths();
        return t[t.length - 1];
      },
      getLengths: function (t) {
        if (
          (void 0 === t && (t = this.arcLengthDivisions),
          this.cacheArcLengths &&
            this.cacheArcLengths.length === t + 1 &&
            !this.needsUpdate)
        )
          return this.cacheArcLengths;
        this.needsUpdate = !1;
        var e,
          n,
          i = [],
          r = this.getPoint(0),
          o = 0;
        for (i.push(0), n = 1; n <= t; n++)
          (o += (e = this.getPoint(n / t)).distanceTo(r)), i.push(o), (r = e);
        return (this.cacheArcLengths = i), i;
      },
      updateArcLengths: function () {
        (this.needsUpdate = !0), this.getLengths();
      },
      getUtoTmapping: function (t, e) {
        var n,
          i = this.getLengths(),
          r = 0,
          o = i.length;
        n = e || t * i[o - 1];
        for (var a, s = 0, c = o - 1; s <= c; )
          if (((r = Math.floor(s + (c - s) / 2)), (a = i[r] - n) < 0))
            s = r + 1;
          else {
            if (!(a > 0)) {
              c = r;
              break;
            }
            c = r - 1;
          }
        if (((r = c), i[r] === n)) return r / (o - 1);
        var l = i[r];
        return (r + (n - l) / (i[r + 1] - l)) / (o - 1);
      },
      getTangent: function (t) {
        var e = t - 1e-4,
          n = t + 1e-4;
        e < 0 && (e = 0), n > 1 && (n = 1);
        var i = this.getPoint(e);
        return this.getPoint(n).clone().sub(i).normalize();
      },
      getTangentAt: function (t) {
        var e = this.getUtoTmapping(t);
        return this.getTangent(e);
      },
      computeFrenetFrames: function (t, e) {
        var n,
          r,
          a,
          s = new o(),
          c = [],
          l = [],
          u = [],
          h = new o(),
          p = new i();
        for (n = 0; n <= t; n++)
          (r = n / t), (c[n] = this.getTangentAt(r)), c[n].normalize();
        (l[0] = new o()), (u[0] = new o());
        var d = Number.MAX_VALUE,
          f = Math.abs(c[0].x),
          m = Math.abs(c[0].y),
          g = Math.abs(c[0].z);
        for (
          f <= d && ((d = f), s.set(1, 0, 0)),
            m <= d && ((d = m), s.set(0, 1, 0)),
            g <= d && s.set(0, 0, 1),
            h.crossVectors(c[0], s).normalize(),
            l[0].crossVectors(c[0], h),
            u[0].crossVectors(c[0], l[0]),
            n = 1;
          n <= t;
          n++
        )
          (l[n] = l[n - 1].clone()),
            (u[n] = u[n - 1].clone()),
            h.crossVectors(c[n - 1], c[n]),
            h.length() > Number.EPSILON &&
              (h.normalize(),
              (a = Math.acos(sa.clamp(c[n - 1].dot(c[n]), -1, 1))),
              l[n].applyMatrix4(p.makeRotationAxis(h, a))),
            u[n].crossVectors(c[n], l[n]);
        if (!0 === e)
          for (
            a = Math.acos(sa.clamp(l[0].dot(l[t]), -1, 1)),
              a /= t,
              c[0].dot(h.crossVectors(l[0], l[t])) > 0 && (a = -a),
              n = 1;
            n <= t;
            n++
          )
            l[n].applyMatrix4(p.makeRotationAxis(c[n], a * n)),
              u[n].crossVectors(c[n], l[n]);
        return { tangents: c, normals: l, binormals: u };
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return (this.arcLengthDivisions = t.arcLengthDivisions), this;
      },
    }),
      ((Zn.prototype = Object.create($n.prototype)).constructor = Zn),
      (Zn.prototype.isLineCurve = !0),
      (Zn.prototype.getPoint = function (t, e) {
        var i = e || new n();
        return (
          1 === t
            ? i.copy(this.v2)
            : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)),
          i
        );
      }),
      (Zn.prototype.getPointAt = function (t, e) {
        return this.getPoint(t, e);
      }),
      (Zn.prototype.getTangent = function () {
        return this.v2.clone().sub(this.v1).normalize();
      }),
      (Zn.prototype.copy = function (t) {
        return (
          $n.prototype.copy.call(this, t),
          this.v1.copy(t.v1),
          this.v2.copy(t.v2),
          this
        );
      }),
      (Jn.prototype = Object.assign(Object.create($n.prototype), {
        constructor: Jn,
        add: function (t) {
          this.curves.push(t);
        },
        closePath: function () {
          var t = this.curves[0].getPoint(0),
            e = this.curves[this.curves.length - 1].getPoint(1);
          t.equals(e) || this.curves.push(new Zn(e, t));
        },
        getPoint: function (t) {
          for (
            var e = t * this.getLength(), n = this.getCurveLengths(), i = 0;
            i < n.length;

          ) {
            if (n[i] >= e) {
              var r = n[i] - e,
                o = this.curves[i],
                a = o.getLength(),
                s = 0 === a ? 0 : 1 - r / a;
              return o.getPointAt(s);
            }
            i++;
          }
          return null;
        },
        getLength: function () {
          var t = this.getCurveLengths();
          return t[t.length - 1];
        },
        updateArcLengths: function () {
          (this.needsUpdate = !0),
            (this.cacheLengths = null),
            this.getCurveLengths();
        },
        getCurveLengths: function () {
          if (
            this.cacheLengths &&
            this.cacheLengths.length === this.curves.length
          )
            return this.cacheLengths;
          for (var t = [], e = 0, n = 0, i = this.curves.length; n < i; n++)
            (e += this.curves[n].getLength()), t.push(e);
          return (this.cacheLengths = t), t;
        },
        getSpacedPoints: function (t) {
          void 0 === t && (t = 40);
          for (var e = [], n = 0; n <= t; n++) e.push(this.getPoint(n / t));
          return this.autoClose && e.push(e[0]), e;
        },
        getPoints: function (t) {
          t = t || 12;
          for (var e, n = [], i = 0, r = this.curves; i < r.length; i++)
            for (
              var o = r[i],
                a =
                  o && o.isEllipseCurve
                    ? 2 * t
                    : o && o.isLineCurve
                    ? 1
                    : o && o.isSplineCurve
                    ? t * o.points.length
                    : t,
                s = o.getPoints(a),
                c = 0;
              c < s.length;
              c++
            ) {
              var l = s[c];
              (e && e.equals(l)) || (n.push(l), (e = l));
            }
          return (
            this.autoClose &&
              n.length > 1 &&
              !n[n.length - 1].equals(n[0]) &&
              n.push(n[0]),
            n
          );
        },
        copy: function (t) {
          $n.prototype.copy.call(this, t), (this.curves = []);
          for (var e = 0, n = t.curves.length; e < n; e++) {
            var i = t.curves[e];
            this.curves.push(i.clone());
          }
          return (this.autoClose = t.autoClose), this;
        },
      })),
      ((Qn.prototype = Object.create($n.prototype)).constructor = Qn),
      (Qn.prototype.isEllipseCurve = !0),
      (Qn.prototype.getPoint = function (t, e) {
        for (
          var i = e || new n(),
            r = 2 * Math.PI,
            o = this.aEndAngle - this.aStartAngle,
            a = Math.abs(o) < Number.EPSILON;
          o < 0;

        )
          o += r;
        for (; o > r; ) o -= r;
        o < Number.EPSILON && (o = a ? 0 : r),
          !0 !== this.aClockwise || a || (o === r ? (o = -r) : (o -= r));
        var s = this.aStartAngle + t * o,
          c = this.aX + this.xRadius * Math.cos(s),
          l = this.aY + this.yRadius * Math.sin(s);
        if (0 !== this.aRotation) {
          var u = Math.cos(this.aRotation),
            h = Math.sin(this.aRotation),
            p = c - this.aX,
            d = l - this.aY;
          (c = p * u - d * h + this.aX), (l = p * h + d * u + this.aY);
        }
        return i.set(c, l);
      }),
      (Qn.prototype.copy = function (t) {
        return (
          $n.prototype.copy.call(this, t),
          (this.aX = t.aX),
          (this.aY = t.aY),
          (this.xRadius = t.xRadius),
          (this.yRadius = t.yRadius),
          (this.aStartAngle = t.aStartAngle),
          (this.aEndAngle = t.aEndAngle),
          (this.aClockwise = t.aClockwise),
          (this.aRotation = t.aRotation),
          this
        );
      }),
      ((Kn.prototype = Object.create($n.prototype)).constructor = Kn),
      (Kn.prototype.isSplineCurve = !0),
      (Kn.prototype.getPoint = function (t, e) {
        var i = e || new n(),
          r = this.points,
          o = (r.length - 1) * t,
          a = Math.floor(o),
          s = o - a,
          c = r[0 === a ? a : a - 1],
          l = r[a],
          u = r[a > r.length - 2 ? r.length - 1 : a + 1],
          h = r[a > r.length - 3 ? r.length - 1 : a + 2];
        return i.set(Xn(s, c.x, l.x, u.x, h.x), Xn(s, c.y, l.y, u.y, h.y)), i;
      }),
      (Kn.prototype.copy = function (t) {
        $n.prototype.copy.call(this, t), (this.points = []);
        for (var e = 0, n = t.points.length; e < n; e++) {
          var i = t.points[e];
          this.points.push(i.clone());
        }
        return this;
      }),
      ((ti.prototype = Object.create($n.prototype)).constructor = ti),
      (ti.prototype.isCubicBezierCurve = !0),
      (ti.prototype.getPoint = function (t, e) {
        var i = e || new n(),
          r = this.v0,
          o = this.v1,
          a = this.v2,
          s = this.v3;
        return i.set(qn(t, r.x, o.x, a.x, s.x), qn(t, r.y, o.y, a.y, s.y)), i;
      }),
      (ti.prototype.copy = function (t) {
        return (
          $n.prototype.copy.call(this, t),
          this.v0.copy(t.v0),
          this.v1.copy(t.v1),
          this.v2.copy(t.v2),
          this.v3.copy(t.v3),
          this
        );
      }),
      ((ei.prototype = Object.create($n.prototype)).constructor = ei),
      (ei.prototype.isQuadraticBezierCurve = !0),
      (ei.prototype.getPoint = function (t, e) {
        var i = e || new n(),
          r = this.v0,
          o = this.v1,
          a = this.v2;
        return i.set(Yn(t, r.x, o.x, a.x), Yn(t, r.y, o.y, a.y)), i;
      }),
      (ei.prototype.copy = function (t) {
        return (
          $n.prototype.copy.call(this, t),
          this.v0.copy(t.v0),
          this.v1.copy(t.v1),
          this.v2.copy(t.v2),
          this
        );
      });
    var ka = Object.assign(Object.create(Jn.prototype), {
      setFromPoints: function (t) {
        this.moveTo(t[0].x, t[0].y);
        for (var e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
      },
      moveTo: function (t, e) {
        this.currentPoint.set(t, e);
      },
      lineTo: function (t, e) {
        var i = new Zn(this.currentPoint.clone(), new n(t, e));
        this.curves.push(i), this.currentPoint.set(t, e);
      },
      quadraticCurveTo: function (t, e, i, r) {
        var o = new ei(this.currentPoint.clone(), new n(t, e), new n(i, r));
        this.curves.push(o), this.currentPoint.set(i, r);
      },
      bezierCurveTo: function (t, e, i, r, o, a) {
        var s = new ti(
          this.currentPoint.clone(),
          new n(t, e),
          new n(i, r),
          new n(o, a)
        );
        this.curves.push(s), this.currentPoint.set(o, a);
      },
      splineThru: function (t) {
        var e = new Kn([this.currentPoint.clone()].concat(t));
        this.curves.push(e), this.currentPoint.copy(t[t.length - 1]);
      },
      arc: function (t, e, n, i, r, o) {
        var a = this.currentPoint.x,
          s = this.currentPoint.y;
        this.absarc(t + a, e + s, n, i, r, o);
      },
      absarc: function (t, e, n, i, r, o) {
        this.absellipse(t, e, n, n, i, r, o);
      },
      ellipse: function (t, e, n, i, r, o, a, s) {
        var c = this.currentPoint.x,
          l = this.currentPoint.y;
        this.absellipse(t + c, e + l, n, i, r, o, a, s);
      },
      absellipse: function (t, e, n, i, r, o, a, s) {
        var c = new Qn(t, e, n, i, r, o, a, s);
        if (this.curves.length > 0) {
          var l = c.getPoint(0);
          l.equals(this.currentPoint) || this.lineTo(l.x, l.y);
        }
        this.curves.push(c);
        var u = c.getPoint(1);
        this.currentPoint.copy(u);
      },
      copy: function (t) {
        return (
          Jn.prototype.copy.call(this, t),
          this.currentPoint.copy(t.currentPoint),
          this
        );
      },
    });
    (ni.prototype = ka),
      (ka.constructor = ni),
      (ii.prototype = Object.assign(Object.create(ka), {
        constructor: ii,
        getPointsHoles: function (t) {
          for (var e = [], n = 0, i = this.holes.length; n < i; n++)
            e[n] = this.holes[n].getPoints(t);
          return e;
        },
        extractPoints: function (t) {
          return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
        },
        copy: function (t) {
          ni.prototype.copy.call(this, t), (this.holes = []);
          for (var e = 0, n = t.holes.length; e < n; e++) {
            var i = t.holes[e];
            this.holes.push(i.clone());
          }
          return this;
        },
      })),
      Object.assign(ri.prototype, {
        moveTo: function (t, e) {
          (this.currentPath = new ni()),
            this.subPaths.push(this.currentPath),
            this.currentPath.moveTo(t, e);
        },
        lineTo: function (t, e) {
          this.currentPath.lineTo(t, e);
        },
        quadraticCurveTo: function (t, e, n, i) {
          this.currentPath.quadraticCurveTo(t, e, n, i);
        },
        bezierCurveTo: function (t, e, n, i, r, o) {
          this.currentPath.bezierCurveTo(t, e, n, i, r, o);
        },
        splineThru: function (t) {
          this.currentPath.splineThru(t);
        },
        toShapes: function (t, e) {
          function n(t) {
            for (var e = [], n = 0, i = t.length; n < i; n++) {
              var r = t[n],
                o = new ii();
              (o.curves = r.curves), e.push(o);
            }
            return e;
          }
          function i(t, e) {
            for (var n = e.length, i = !1, r = n - 1, o = 0; o < n; r = o++) {
              var a = e[r],
                s = e[o],
                c = s.x - a.x,
                l = s.y - a.y;
              if (Math.abs(l) > Number.EPSILON) {
                if (
                  (l < 0 && ((a = e[o]), (c = -c), (s = e[r]), (l = -l)),
                  t.y < a.y || t.y > s.y)
                )
                  continue;
                if (t.y === a.y) {
                  if (t.x === a.x) return !0;
                } else {
                  var u = l * (t.x - a.x) - c * (t.y - a.y);
                  if (0 === u) return !0;
                  if (u < 0) continue;
                  i = !i;
                }
              } else {
                if (t.y !== a.y) continue;
                if ((s.x <= t.x && t.x <= a.x) || (a.x <= t.x && t.x <= s.x))
                  return !0;
              }
            }
            return i;
          }
          var r = Sa.isClockWise,
            o = this.subPaths;
          if (0 === o.length) return [];
          if (!0 === e) return n(o);
          var a,
            s,
            c,
            l = [];
          if (1 === o.length)
            return (
              (s = o[0]), (c = new ii()), (c.curves = s.curves), l.push(c), l
            );
          var u = !r(o[0].getPoints());
          u = t ? !u : u;
          var h,
            p = [],
            d = [],
            f = [],
            m = 0;
          (d[m] = void 0), (f[m] = []);
          for (var g = 0, v = o.length; g < v; g++)
            (a = r((h = (s = o[g]).getPoints()))),
              (a = t ? !a : a)
                ? (!u && d[m] && m++,
                  (d[m] = { s: new ii(), p: h }),
                  (d[m].s.curves = s.curves),
                  u && m++,
                  (f[m] = []))
                : f[m].push({ h: s, p: h[0] });
          if (!d[0]) return n(o);
          if (d.length > 1) {
            for (var y = !1, x = [], b = 0, _ = d.length; b < _; b++) p[b] = [];
            for (var b = 0, _ = d.length; b < _; b++)
              for (var w = f[b], M = 0; M < w.length; M++) {
                for (var E = w[M], T = !0, S = 0; S < d.length; S++)
                  i(E.p, d[S].p) &&
                    (b !== S && x.push({ froms: b, tos: S, hole: M }),
                    T ? ((T = !1), p[S].push(E)) : (y = !0));
                T && p[b].push(E);
              }
            x.length > 0 && (y || (f = p));
          }
          for (var A, g = 0, L = d.length; g < L; g++) {
            (c = d[g].s), l.push(c);
            for (var R = 0, P = (A = f[g]).length; R < P; R++)
              c.holes.push(A[R].h);
          }
          return l;
        },
      }),
      Object.assign(oi.prototype, {
        isFont: !0,
        generateShapes: function (t, e, n) {
          void 0 === e && (e = 100), void 0 === n && (n = 4);
          for (
            var i = this.data,
              r = (function (t) {
                for (
                  var r = String(t).split(""),
                    o = e / i.resolution,
                    a =
                      (i.boundingBox.yMax -
                        i.boundingBox.yMin +
                        i.underlineThickness) *
                      o,
                    s = 0,
                    c = 0,
                    l = [],
                    u = 0;
                  u < r.length;
                  u++
                ) {
                  var h = r[u];
                  if ("\n" === h) (s = 0), (c -= a);
                  else {
                    var p = (function (t, e, r, o) {
                      var a = i.glyphs[t] || i.glyphs["?"];
                      if (a) {
                        var s,
                          c,
                          l,
                          u,
                          h,
                          p,
                          d,
                          f,
                          m,
                          g,
                          v,
                          y = new ri(),
                          x = [];
                        if (a.o)
                          for (
                            var b =
                                a._cachedOutline ||
                                (a._cachedOutline = a.o.split(" ")),
                              _ = 0,
                              w = b.length;
                            _ < w;

                          )
                            switch (b[_++]) {
                              case "m":
                                (s = b[_++] * e + r),
                                  (c = b[_++] * e + o),
                                  y.moveTo(s, c);
                                break;
                              case "l":
                                (s = b[_++] * e + r),
                                  (c = b[_++] * e + o),
                                  y.lineTo(s, c);
                                break;
                              case "q":
                                if (
                                  ((l = b[_++] * e + r),
                                  (u = b[_++] * e + o),
                                  (d = b[_++] * e + r),
                                  (f = b[_++] * e + o),
                                  y.quadraticCurveTo(d, f, l, u),
                                  (v = x[x.length - 1]))
                                )
                                  for (h = v.x, p = v.y, M = 1; M <= n; M++)
                                    Yn((E = M / n), h, d, l), Yn(E, p, f, u);
                                break;
                              case "b":
                                if (
                                  ((l = b[_++] * e + r),
                                  (u = b[_++] * e + o),
                                  (d = b[_++] * e + r),
                                  (f = b[_++] * e + o),
                                  (m = b[_++] * e + r),
                                  (g = b[_++] * e + o),
                                  y.bezierCurveTo(d, f, m, g, l, u),
                                  (v = x[x.length - 1]))
                                ) {
                                  (h = v.x), (p = v.y);
                                  for (var M = 1; M <= n; M++) {
                                    var E = M / n;
                                    qn(E, h, d, m, l), qn(E, p, f, g, u);
                                  }
                                }
                            }
                        return { offsetX: a.ha * e, path: y };
                      }
                    })(h, o, s, c);
                    (s += p.offsetX), l.push(p.path);
                  }
                }
                return l;
              })(t),
              o = [],
              a = 0,
              s = r.length;
            a < s;
            a++
          )
            Array.prototype.push.apply(o, r[a].toShapes());
          return o;
        },
      }),
      Object.assign(ai.prototype, {
        load: function (t, e, n, i) {
          var r = this,
            o = new hn(this.manager);
          o.setPath(this.path),
            o.load(
              t,
              function (t) {
                var n;
                try {
                  n = JSON.parse(t);
                } catch (e) {
                  console.warn(
                    "THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."
                  ),
                    (n = JSON.parse(t.substring(65, t.length - 2)));
                }
                var i = r.parse(n);
                e && e(i);
              },
              n,
              i
            );
        },
        parse: function (t) {
          return new oi(t);
        },
        setPath: function (t) {
          return (this.path = t), this;
        },
      });
    var Fa,
      Ba = {
        getContext: function () {
          return (
            void 0 === Fa &&
              (Fa = new (window.AudioContext || window.webkitAudioContext)()),
            Fa
          );
        },
        setContext: function (t) {
          Fa = t;
        },
      };
    Object.assign(si.prototype, {
      load: function (t, e, n, i) {
        var r = new hn(this.manager);
        r.setResponseType("arraybuffer"),
          r.load(
            t,
            function (t) {
              Ba.getContext().decodeAudioData(t, function (t) {
                e(t);
              });
            },
            n,
            i
          );
      },
    }),
      Object.assign(ci.prototype, {
        update: (function () {
          var t,
            e,
            n,
            r,
            o,
            a,
            s,
            c,
            l = new i(),
            u = new i();
          return function (i) {
            if (
              t !== this ||
              e !== i.focus ||
              n !== i.fov ||
              r !== i.aspect * this.aspect ||
              o !== i.near ||
              a !== i.far ||
              s !== i.zoom ||
              c !== this.eyeSep
            ) {
              (t = this),
                (e = i.focus),
                (n = i.fov),
                (r = i.aspect * this.aspect),
                (o = i.near),
                (a = i.far),
                (s = i.zoom);
              var h,
                p,
                d = i.projectionMatrix.clone(),
                f = ((c = this.eyeSep / 2) * o) / e,
                m = (o * Math.tan(sa.DEG2RAD * n * 0.5)) / s;
              (u.elements[12] = -c),
                (l.elements[12] = c),
                (h = -m * r + f),
                (p = m * r + f),
                (d.elements[0] = (2 * o) / (p - h)),
                (d.elements[8] = (p + h) / (p - h)),
                this.cameraL.projectionMatrix.copy(d),
                (h = -m * r - f),
                (p = m * r - f),
                (d.elements[0] = (2 * o) / (p - h)),
                (d.elements[8] = (p + h) / (p - h)),
                this.cameraR.projectionMatrix.copy(d);
            }
            this.cameraL.matrixWorld.copy(i.matrixWorld).multiply(u),
              this.cameraR.matrixWorld.copy(i.matrixWorld).multiply(l);
          };
        })(),
      }),
      ((li.prototype = Object.create(at.prototype)).constructor = li),
      (ui.prototype = Object.assign(Object.create(at.prototype), {
        constructor: ui,
        getInput: function () {
          return this.gain;
        },
        removeFilter: function () {
          null !== this.filter &&
            (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination),
            this.gain.connect(this.context.destination),
            (this.filter = null));
        },
        getFilter: function () {
          return this.filter;
        },
        setFilter: function (t) {
          null !== this.filter
            ? (this.gain.disconnect(this.filter),
              this.filter.disconnect(this.context.destination))
            : this.gain.disconnect(this.context.destination),
            (this.filter = t),
            this.gain.connect(this.filter),
            this.filter.connect(this.context.destination);
        },
        getMasterVolume: function () {
          return this.gain.gain.value;
        },
        setMasterVolume: function (t) {
          this.gain.gain.value = t;
        },
        updateMatrixWorld: (function () {
          var t = new o(),
            e = new r(),
            n = new o(),
            i = new o();
          return function (r) {
            at.prototype.updateMatrixWorld.call(this, r);
            var o = this.context.listener,
              a = this.up;
            this.matrixWorld.decompose(t, e, n),
              i.set(0, 0, -1).applyQuaternion(e),
              o.positionX
                ? (o.positionX.setValueAtTime(t.x, this.context.currentTime),
                  o.positionY.setValueAtTime(t.y, this.context.currentTime),
                  o.positionZ.setValueAtTime(t.z, this.context.currentTime),
                  o.forwardX.setValueAtTime(i.x, this.context.currentTime),
                  o.forwardY.setValueAtTime(i.y, this.context.currentTime),
                  o.forwardZ.setValueAtTime(i.z, this.context.currentTime),
                  o.upX.setValueAtTime(a.x, this.context.currentTime),
                  o.upY.setValueAtTime(a.y, this.context.currentTime),
                  o.upZ.setValueAtTime(a.z, this.context.currentTime))
                : (o.setPosition(t.x, t.y, t.z),
                  o.setOrientation(i.x, i.y, i.z, a.x, a.y, a.z));
          };
        })(),
      })),
      (hi.prototype = Object.assign(Object.create(at.prototype), {
        constructor: hi,
        getOutput: function () {
          return this.gain;
        },
        setNodeSource: function (t) {
          return (
            (this.hasPlaybackControl = !1),
            (this.sourceType = "audioNode"),
            (this.source = t),
            this.connect(),
            this
          );
        },
        setBuffer: function (t) {
          return (
            (this.buffer = t),
            (this.sourceType = "buffer"),
            this.autoplay && this.play(),
            this
          );
        },
        play: function () {
          if (!0 !== this.isPlaying) {
            if (!1 !== this.hasPlaybackControl) {
              var t = this.context.createBufferSource();
              return (
                (t.buffer = this.buffer),
                (t.loop = this.loop),
                (t.onended = this.onEnded.bind(this)),
                t.playbackRate.setValueAtTime(
                  this.playbackRate,
                  this.startTime
                ),
                (this.startTime = this.context.currentTime),
                t.start(this.startTime, this.offset),
                (this.isPlaying = !0),
                (this.source = t),
                this.connect()
              );
            }
            console.warn("THREE.Audio: this Audio has no playback control.");
          } else console.warn("THREE.Audio: Audio is already playing.");
        },
        pause: function () {
          if (!1 !== this.hasPlaybackControl)
            return (
              !0 === this.isPlaying &&
                (this.source.stop(),
                (this.offset +=
                  (this.context.currentTime - this.startTime) *
                  this.playbackRate),
                (this.isPlaying = !1)),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        },
        stop: function () {
          if (!1 !== this.hasPlaybackControl)
            return (
              this.source.stop(), (this.offset = 0), (this.isPlaying = !1), this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        },
        connect: function () {
          if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (var t = 1, e = this.filters.length; t < e; t++)
              this.filters[t - 1].connect(this.filters[t]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
          } else this.source.connect(this.getOutput());
          return this;
        },
        disconnect: function () {
          if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (var t = 1, e = this.filters.length; t < e; t++)
              this.filters[t - 1].disconnect(this.filters[t]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
          } else this.source.disconnect(this.getOutput());
          return this;
        },
        getFilters: function () {
          return this.filters;
        },
        setFilters: function (t) {
          return (
            t || (t = []),
            !0 === this.isPlaying
              ? (this.disconnect(), (this.filters = t), this.connect())
              : (this.filters = t),
            this
          );
        },
        getFilter: function () {
          return this.getFilters()[0];
        },
        setFilter: function (t) {
          return this.setFilters(t ? [t] : []);
        },
        setPlaybackRate: function (t) {
          if (!1 !== this.hasPlaybackControl)
            return (
              (this.playbackRate = t),
              !0 === this.isPlaying &&
                this.source.playbackRate.setValueAtTime(
                  this.playbackRate,
                  this.context.currentTime
                ),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        },
        getPlaybackRate: function () {
          return this.playbackRate;
        },
        onEnded: function () {
          this.isPlaying = !1;
        },
        getLoop: function () {
          return !1 === this.hasPlaybackControl
            ? (console.warn("THREE.Audio: this Audio has no playback control."),
              !1)
            : this.loop;
        },
        setLoop: function (t) {
          if (!1 !== this.hasPlaybackControl)
            return (
              (this.loop = t),
              !0 === this.isPlaying && (this.source.loop = this.loop),
              this
            );
          console.warn("THREE.Audio: this Audio has no playback control.");
        },
        getVolume: function () {
          return this.gain.gain.value;
        },
        setVolume: function (t) {
          return (this.gain.gain.value = t), this;
        },
      })),
      (pi.prototype = Object.assign(Object.create(hi.prototype), {
        constructor: pi,
        getOutput: function () {
          return this.panner;
        },
        getRefDistance: function () {
          return this.panner.refDistance;
        },
        setRefDistance: function (t) {
          this.panner.refDistance = t;
        },
        getRolloffFactor: function () {
          return this.panner.rolloffFactor;
        },
        setRolloffFactor: function (t) {
          this.panner.rolloffFactor = t;
        },
        getDistanceModel: function () {
          return this.panner.distanceModel;
        },
        setDistanceModel: function (t) {
          this.panner.distanceModel = t;
        },
        getMaxDistance: function () {
          return this.panner.maxDistance;
        },
        setMaxDistance: function (t) {
          this.panner.maxDistance = t;
        },
        updateMatrixWorld: (function () {
          var t = new o();
          return function (e) {
            at.prototype.updateMatrixWorld.call(this, e),
              t.setFromMatrixPosition(this.matrixWorld),
              this.panner.setPosition(t.x, t.y, t.z);
          };
        })(),
      })),
      Object.assign(di.prototype, {
        getFrequencyData: function () {
          return this.analyser.getByteFrequencyData(this.data), this.data;
        },
        getAverageFrequency: function () {
          for (var t = 0, e = this.getFrequencyData(), n = 0; n < e.length; n++)
            t += e[n];
          return t / e.length;
        },
      }),
      Object.assign(fi.prototype, {
        accumulate: function (t, e) {
          var n = this.buffer,
            i = this.valueSize,
            r = t * i + i,
            o = this.cumulativeWeight;
          if (0 === o) {
            for (var a = 0; a !== i; ++a) n[r + a] = n[a];
            o = e;
          } else {
            var s = e / (o += e);
            this._mixBufferRegion(n, r, 0, s, i);
          }
          this.cumulativeWeight = o;
        },
        apply: function (t) {
          var e = this.valueSize,
            n = this.buffer,
            i = t * e + e,
            r = this.cumulativeWeight,
            o = this.binding;
          if (((this.cumulativeWeight = 0), r < 1)) {
            var a = 3 * e;
            this._mixBufferRegion(n, i, a, 1 - r, e);
          }
          for (var s = e, c = e + e; s !== c; ++s)
            if (n[s] !== n[s + e]) {
              o.setValue(n, i);
              break;
            }
        },
        saveOriginalState: function () {
          var t = this.binding,
            e = this.buffer,
            n = this.valueSize,
            i = 3 * n;
          t.getValue(e, i);
          for (var r = n, o = i; r !== o; ++r) e[r] = e[i + (r % n)];
          this.cumulativeWeight = 0;
        },
        restoreOriginalState: function () {
          var t = 3 * this.valueSize;
          this.binding.setValue(this.buffer, t);
        },
        _select: function (t, e, n, i, r) {
          if (i >= 0.5) for (var o = 0; o !== r; ++o) t[e + o] = t[n + o];
        },
        _slerp: function (t, e, n, i) {
          r.slerpFlat(t, e, t, e, t, n, i);
        },
        _lerp: function (t, e, n, i, r) {
          for (var o = 1 - i, a = 0; a !== r; ++a) {
            var s = e + a;
            t[s] = t[s] * o + t[n + a] * i;
          }
        },
      }),
      Object.assign(mi.prototype, {
        getValue: function (t, e) {
          this.bind();
          var n = this._targetGroup.nCachedObjects_,
            i = this._bindings[n];
          void 0 !== i && i.getValue(t, e);
        },
        setValue: function (t, e) {
          for (
            var n = this._bindings,
              i = this._targetGroup.nCachedObjects_,
              r = n.length;
            i !== r;
            ++i
          )
            n[i].setValue(t, e);
        },
        bind: function () {
          for (
            var t = this._bindings,
              e = this._targetGroup.nCachedObjects_,
              n = t.length;
            e !== n;
            ++e
          )
            t[e].bind();
        },
        unbind: function () {
          for (
            var t = this._bindings,
              e = this._targetGroup.nCachedObjects_,
              n = t.length;
            e !== n;
            ++e
          )
            t[e].unbind();
        },
      }),
      Object.assign(gi, {
        Composite: mi,
        create: function (t, e, n) {
          return t && t.isAnimationObjectGroup
            ? new gi.Composite(t, e, n)
            : new gi(t, e, n);
        },
        sanitizeNodeName: function (t) {
          return t.replace(/\s/g, "_").replace(/[^\w-]/g, "");
        },
        parseTrackName: (function () {
          var t = new RegExp(
              "^" +
                /((?:[\w-]+[\/:])*)/.source +
                /([\w-\.]+)?/.source +
                /(?:\.([\w-]+)(?:\[(.+)\])?)?/.source +
                /\.([\w-]+)(?:\[(.+)\])?/.source +
                "$"
            ),
            e = ["material", "materials", "bones"];
          return function (n) {
            var i = t.exec(n);
            if (!i)
              throw new Error("PropertyBinding: Cannot parse trackName: " + n);
            var r = {
                nodeName: i[2],
                objectName: i[3],
                objectIndex: i[4],
                propertyName: i[5],
                propertyIndex: i[6],
              },
              o = r.nodeName && r.nodeName.lastIndexOf(".");
            if (void 0 !== o && -1 !== o) {
              var a = r.nodeName.substring(o + 1);
              -1 !== e.indexOf(a) &&
                ((r.nodeName = r.nodeName.substring(0, o)), (r.objectName = a));
            }
            if (null === r.propertyName || 0 === r.propertyName.length)
              throw new Error(
                "PropertyBinding: can not parse propertyName from trackName: " +
                  n
              );
            return r;
          };
        })(),
        findNode: function (t, e) {
          if (
            !e ||
            "" === e ||
            "root" === e ||
            "." === e ||
            -1 === e ||
            e === t.name ||
            e === t.uuid
          )
            return t;
          if (t.skeleton) {
            var n = (function (t) {
              for (var n = 0; n < t.bones.length; n++) {
                var i = t.bones[n];
                if (i.name === e) return i;
              }
              return null;
            })(t.skeleton);
            if (n) return n;
          }
          if (t.children) {
            var i = function (t) {
                for (var n = 0; n < t.length; n++) {
                  var r = t[n];
                  if (r.name === e || r.uuid === e) return r;
                  var o = i(r.children);
                  if (o) return o;
                }
                return null;
              },
              r = i(t.children);
            if (r) return r;
          }
          return null;
        },
      }),
      Object.assign(gi.prototype, {
        _getValue_unavailable: function () {},
        _setValue_unavailable: function () {},
        BindingType: {
          Direct: 0,
          EntireArray: 1,
          ArrayElement: 2,
          HasFromToArray: 3,
        },
        Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 },
        GetterByBindingType: [
          function (t, e) {
            t[e] = this.node[this.propertyName];
          },
          function (t, e) {
            for (
              var n = this.resolvedProperty, i = 0, r = n.length;
              i !== r;
              ++i
            )
              t[e++] = n[i];
          },
          function (t, e) {
            t[e] = this.resolvedProperty[this.propertyIndex];
          },
          function (t, e) {
            this.resolvedProperty.toArray(t, e);
          },
        ],
        SetterByBindingTypeAndVersioning: [
          [
            function (t, e) {
              this.targetObject[this.propertyName] = t[e];
            },
            function (t, e) {
              (this.targetObject[this.propertyName] = t[e]),
                (this.targetObject.needsUpdate = !0);
            },
            function (t, e) {
              (this.targetObject[this.propertyName] = t[e]),
                (this.targetObject.matrixWorldNeedsUpdate = !0);
            },
          ],
          [
            function (t, e) {
              for (
                var n = this.resolvedProperty, i = 0, r = n.length;
                i !== r;
                ++i
              )
                n[i] = t[e++];
            },
            function (t, e) {
              for (
                var n = this.resolvedProperty, i = 0, r = n.length;
                i !== r;
                ++i
              )
                n[i] = t[e++];
              this.targetObject.needsUpdate = !0;
            },
            function (t, e) {
              for (
                var n = this.resolvedProperty, i = 0, r = n.length;
                i !== r;
                ++i
              )
                n[i] = t[e++];
              this.targetObject.matrixWorldNeedsUpdate = !0;
            },
          ],
          [
            function (t, e) {
              this.resolvedProperty[this.propertyIndex] = t[e];
            },
            function (t, e) {
              (this.resolvedProperty[this.propertyIndex] = t[e]),
                (this.targetObject.needsUpdate = !0);
            },
            function (t, e) {
              (this.resolvedProperty[this.propertyIndex] = t[e]),
                (this.targetObject.matrixWorldNeedsUpdate = !0);
            },
          ],
          [
            function (t, e) {
              this.resolvedProperty.fromArray(t, e);
            },
            function (t, e) {
              this.resolvedProperty.fromArray(t, e),
                (this.targetObject.needsUpdate = !0);
            },
            function (t, e) {
              this.resolvedProperty.fromArray(t, e),
                (this.targetObject.matrixWorldNeedsUpdate = !0);
            },
          ],
        ],
        getValue: function (t, e) {
          this.bind(), this.getValue(t, e);
        },
        setValue: function (t, e) {
          this.bind(), this.setValue(t, e);
        },
        bind: function () {
          var t = this.node,
            e = this.parsedPath,
            n = e.objectName,
            i = e.propertyName,
            r = e.propertyIndex;
          if (
            (t ||
              ((t = gi.findNode(this.rootNode, e.nodeName) || this.rootNode),
              (this.node = t)),
            (this.getValue = this._getValue_unavailable),
            (this.setValue = this._setValue_unavailable),
            t)
          ) {
            if (n) {
              var o = e.objectIndex;
              switch (n) {
                case "materials":
                  if (!t.material)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                      this
                    );
                  if (!t.material.materials)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                      this
                    );
                  t = t.material.materials;
                  break;
                case "bones":
                  if (!t.skeleton)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                      this
                    );
                  for (t = t.skeleton.bones, l = 0; l < t.length; l++)
                    if (t[l].name === o) {
                      o = l;
                      break;
                    }
                  break;
                default:
                  if (void 0 === t[n])
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                      this
                    );
                  t = t[n];
              }
              if (void 0 !== o) {
                if (void 0 === t[o])
                  return void console.error(
                    "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                    this,
                    t
                  );
                t = t[o];
              }
            }
            var a = t[i];
            if (void 0 !== a) {
              var s = this.Versioning.None;
              void 0 !== t.needsUpdate
                ? ((s = this.Versioning.NeedsUpdate), (this.targetObject = t))
                : void 0 !== t.matrixWorldNeedsUpdate &&
                  ((s = this.Versioning.MatrixWorldNeedsUpdate),
                  (this.targetObject = t));
              var c = this.BindingType.Direct;
              if (void 0 !== r) {
                if ("morphTargetInfluences" === i) {
                  if (!t.geometry)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                      this
                    );
                  if (t.geometry.isBufferGeometry) {
                    if (!t.geometry.morphAttributes)
                      return void console.error(
                        "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                        this
                      );
                    for (
                      l = 0;
                      l < this.node.geometry.morphAttributes.position.length;
                      l++
                    )
                      if (t.geometry.morphAttributes.position[l].name === r) {
                        r = l;
                        break;
                      }
                  } else {
                    if (!t.geometry.morphTargets)
                      return void console.error(
                        "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.",
                        this
                      );
                    for (
                      var l = 0;
                      l < this.node.geometry.morphTargets.length;
                      l++
                    )
                      if (t.geometry.morphTargets[l].name === r) {
                        r = l;
                        break;
                      }
                  }
                }
                (c = this.BindingType.ArrayElement),
                  (this.resolvedProperty = a),
                  (this.propertyIndex = r);
              } else
                void 0 !== a.fromArray && void 0 !== a.toArray
                  ? ((c = this.BindingType.HasFromToArray),
                    (this.resolvedProperty = a))
                  : Array.isArray(a)
                  ? ((c = this.BindingType.EntireArray),
                    (this.resolvedProperty = a))
                  : (this.propertyName = i);
              (this.getValue = this.GetterByBindingType[c]),
                (this.setValue = this.SetterByBindingTypeAndVersioning[c][s]);
            } else {
              var u = e.nodeName;
              console.error(
                "THREE.PropertyBinding: Trying to update property for track: " +
                  u +
                  "." +
                  i +
                  " but it wasn't found.",
                t
              );
            }
          } else
            console.error(
              "THREE.PropertyBinding: Trying to update node for track: " +
                this.path +
                " but it wasn't found."
            );
        },
        unbind: function () {
          (this.node = null),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        },
      }),
      Object.assign(gi.prototype, {
        _getValue_unbound: gi.prototype.getValue,
        _setValue_unbound: gi.prototype.setValue,
      }),
      Object.assign(vi.prototype, {
        isAnimationObjectGroup: !0,
        add: function () {
          for (
            var t = this._objects,
              e = t.length,
              n = this.nCachedObjects_,
              i = this._indicesByUUID,
              r = this._paths,
              o = this._parsedPaths,
              a = this._bindings,
              s = a.length,
              c = 0,
              l = arguments.length;
            c !== l;
            ++c
          ) {
            var u = arguments[c],
              h = u.uuid,
              p = i[h],
              d = void 0;
            if (void 0 === p) {
              (p = e++), (i[h] = p), t.push(u);
              for (var f = 0, m = s; f !== m; ++f)
                a[f].push(new gi(u, r[f], o[f]));
            } else if (p < n) {
              d = t[p];
              var g = --n,
                v = t[g];
              (i[v.uuid] = p), (t[p] = v), (i[h] = g), (t[g] = u);
              for (var f = 0, m = s; f !== m; ++f) {
                var y = a[f],
                  x = y[g],
                  b = y[p];
                (y[p] = x),
                  void 0 === b && (b = new gi(u, r[f], o[f])),
                  (y[g] = b);
              }
            } else
              t[p] !== d &&
                console.error(
                  "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
                );
          }
          this.nCachedObjects_ = n;
        },
        remove: function () {
          for (
            var t = this._objects,
              e = this.nCachedObjects_,
              n = this._indicesByUUID,
              i = this._bindings,
              r = i.length,
              o = 0,
              a = arguments.length;
            o !== a;
            ++o
          ) {
            var s = arguments[o],
              c = s.uuid,
              l = n[c];
            if (void 0 !== l && l >= e) {
              var u = e++,
                h = t[u];
              (n[h.uuid] = l), (t[l] = h), (n[c] = u), (t[u] = s);
              for (var p = 0, d = r; p !== d; ++p) {
                var f = i[p],
                  m = f[u],
                  g = f[l];
                (f[l] = m), (f[u] = g);
              }
            }
          }
          this.nCachedObjects_ = e;
        },
        uncache: function () {
          for (
            var t = this._objects,
              e = t.length,
              n = this.nCachedObjects_,
              i = this._indicesByUUID,
              r = this._bindings,
              o = r.length,
              a = 0,
              s = arguments.length;
            a !== s;
            ++a
          ) {
            var c = arguments[a].uuid,
              l = i[c];
            if (void 0 !== l)
              if ((delete i[c], l < n)) {
                var u = --n,
                  h = t[u],
                  p = t[(v = --e)];
                (i[h.uuid] = l),
                  (t[l] = h),
                  (i[p.uuid] = u),
                  (t[u] = p),
                  t.pop();
                for (var d = 0, f = o; d !== f; ++d) {
                  var m = (y = r[d])[u],
                    g = y[v];
                  (y[l] = m), (y[u] = g), y.pop();
                }
              } else {
                var v = --e;
                (i[(p = t[v]).uuid] = l), (t[l] = p), t.pop();
                for (var d = 0, f = o; d !== f; ++d) {
                  var y = r[d];
                  (y[l] = y[v]), y.pop();
                }
              }
          }
          this.nCachedObjects_ = n;
        },
        subscribe_: function (t, e) {
          var n = this._bindingsIndicesByPath,
            i = n[t],
            r = this._bindings;
          if (void 0 !== i) return r[i];
          var o = this._paths,
            a = this._parsedPaths,
            s = this._objects,
            c = s.length,
            l = this.nCachedObjects_,
            u = new Array(c);
          (i = r.length), (n[t] = i), o.push(t), a.push(e), r.push(u);
          for (var h = l, p = s.length; h !== p; ++h) {
            var d = s[h];
            u[h] = new gi(d, t, e);
          }
          return u;
        },
        unsubscribe_: function (t) {
          var e = this._bindingsIndicesByPath,
            n = e[t];
          if (void 0 !== n) {
            var i = this._paths,
              r = this._parsedPaths,
              o = this._bindings,
              a = o.length - 1,
              s = o[a];
            (e[t[a]] = n),
              (o[n] = s),
              o.pop(),
              (r[n] = r[a]),
              r.pop(),
              (i[n] = i[a]),
              i.pop();
          }
        },
      }),
      Object.assign(yi.prototype, {
        play: function () {
          return this._mixer._activateAction(this), this;
        },
        stop: function () {
          return this._mixer._deactivateAction(this), this.reset();
        },
        reset: function () {
          return (
            (this.paused = !1),
            (this.enabled = !0),
            (this.time = 0),
            (this._loopCount = -1),
            (this._startTime = null),
            this.stopFading().stopWarping()
          );
        },
        isRunning: function () {
          return (
            this.enabled &&
            !this.paused &&
            0 !== this.timeScale &&
            null === this._startTime &&
            this._mixer._isActiveAction(this)
          );
        },
        isScheduled: function () {
          return this._mixer._isActiveAction(this);
        },
        startAt: function (t) {
          return (this._startTime = t), this;
        },
        setLoop: function (t, e) {
          return (this.loop = t), (this.repetitions = e), this;
        },
        setEffectiveWeight: function (t) {
          return (
            (this.weight = t),
            (this._effectiveWeight = this.enabled ? t : 0),
            this.stopFading()
          );
        },
        getEffectiveWeight: function () {
          return this._effectiveWeight;
        },
        fadeIn: function (t) {
          return this._scheduleFading(t, 0, 1);
        },
        fadeOut: function (t) {
          return this._scheduleFading(t, 1, 0);
        },
        crossFadeFrom: function (t, e, n) {
          if ((t.fadeOut(e), this.fadeIn(e), n)) {
            var i = this._clip.duration,
              r = t._clip.duration,
              o = r / i,
              a = i / r;
            t.warp(1, o, e), this.warp(a, 1, e);
          }
          return this;
        },
        crossFadeTo: function (t, e, n) {
          return t.crossFadeFrom(this, e, n);
        },
        stopFading: function () {
          var t = this._weightInterpolant;
          return (
            null !== t &&
              ((this._weightInterpolant = null),
              this._mixer._takeBackControlInterpolant(t)),
            this
          );
        },
        setEffectiveTimeScale: function (t) {
          return (
            (this.timeScale = t),
            (this._effectiveTimeScale = this.paused ? 0 : t),
            this.stopWarping()
          );
        },
        getEffectiveTimeScale: function () {
          return this._effectiveTimeScale;
        },
        setDuration: function (t) {
          return (this.timeScale = this._clip.duration / t), this.stopWarping();
        },
        syncWith: function (t) {
          return (
            (this.time = t.time),
            (this.timeScale = t.timeScale),
            this.stopWarping()
          );
        },
        halt: function (t) {
          return this.warp(this._effectiveTimeScale, 0, t);
        },
        warp: function (t, e, n) {
          var i = this._mixer,
            r = i.time,
            o = this._timeScaleInterpolant,
            a = this.timeScale;
          null === o &&
            ((o = i._lendControlInterpolant()),
            (this._timeScaleInterpolant = o));
          var s = o.parameterPositions,
            c = o.sampleValues;
          return (
            (s[0] = r), (s[1] = r + n), (c[0] = t / a), (c[1] = e / a), this
          );
        },
        stopWarping: function () {
          var t = this._timeScaleInterpolant;
          return (
            null !== t &&
              ((this._timeScaleInterpolant = null),
              this._mixer._takeBackControlInterpolant(t)),
            this
          );
        },
        getMixer: function () {
          return this._mixer;
        },
        getClip: function () {
          return this._clip;
        },
        getRoot: function () {
          return this._localRoot || this._mixer._root;
        },
        _update: function (t, e, n, i) {
          if (this.enabled) {
            var r = this._startTime;
            if (null !== r) {
              var o = (t - r) * n;
              if (o < 0 || 0 === n) return;
              (this._startTime = null), (e = n * o);
            }
            e *= this._updateTimeScale(t);
            var a = this._updateTime(e),
              s = this._updateWeight(t);
            if (s > 0)
              for (
                var c = this._interpolants,
                  l = this._propertyBindings,
                  u = 0,
                  h = c.length;
                u !== h;
                ++u
              )
                c[u].evaluate(a), l[u].accumulate(i, s);
          } else this._updateWeight(t);
        },
        _updateWeight: function (t) {
          var e = 0;
          if (this.enabled) {
            e = this.weight;
            var n = this._weightInterpolant;
            if (null !== n) {
              var i = n.evaluate(t)[0];
              (e *= i),
                t > n.parameterPositions[1] &&
                  (this.stopFading(), 0 === i && (this.enabled = !1));
            }
          }
          return (this._effectiveWeight = e), e;
        },
        _updateTimeScale: function (t) {
          var e = 0;
          if (!this.paused) {
            e = this.timeScale;
            var n = this._timeScaleInterpolant;
            null !== n &&
              ((e *= n.evaluate(t)[0]),
              t > n.parameterPositions[1] &&
                (this.stopWarping(),
                0 === e ? (this.paused = !0) : (this.timeScale = e)));
          }
          return (this._effectiveTimeScale = e), e;
        },
        _updateTime: function (t) {
          var e = this.time + t;
          if (0 === t) return e;
          var n = this._clip.duration,
            i = this.loop,
            r = this._loopCount;
          if (2200 === i) {
            -1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
            t: {
              if (e >= n) e = n;
              else {
                if (!(e < 0)) break t;
                e = 0;
              }
              this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: t < 0 ? -1 : 1,
                });
            }
          } else {
            var o = 2202 === i;
            if (
              (-1 === r &&
                (t >= 0
                  ? ((r = 0), this._setEndings(!0, 0 === this.repetitions, o))
                  : this._setEndings(0 === this.repetitions, !0, o)),
              e >= n || e < 0)
            ) {
              var a = Math.floor(e / n);
              (e -= n * a), (r += Math.abs(a));
              var s = this.repetitions - r;
              if (s < 0)
                this.clampWhenFinished
                  ? (this.paused = !0)
                  : (this.enabled = !1),
                  (e = t > 0 ? n : 0),
                  this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: t > 0 ? 1 : -1,
                  });
              else {
                if (0 === s) {
                  var c = t < 0;
                  this._setEndings(c, !c, o);
                } else this._setEndings(!1, !1, o);
                (this._loopCount = r),
                  this._mixer.dispatchEvent({
                    type: "loop",
                    action: this,
                    loopDelta: a,
                  });
              }
            }
            if (o && 1 == (1 & r)) return (this.time = e), n - e;
          }
          return (this.time = e), e;
        },
        _setEndings: function (t, e, n) {
          var i = this._interpolantSettings;
          n
            ? ((i.endingStart = 2401), (i.endingEnd = 2401))
            : ((i.endingStart = t ? (this.zeroSlopeAtStart ? 2401 : qo) : 2402),
              (i.endingEnd = e ? (this.zeroSlopeAtEnd ? 2401 : qo) : 2402));
        },
        _scheduleFading: function (t, e, n) {
          var i = this._mixer,
            r = i.time,
            o = this._weightInterpolant;
          null === o &&
            ((o = i._lendControlInterpolant()), (this._weightInterpolant = o));
          var a = o.parameterPositions,
            s = o.sampleValues;
          return (a[0] = r), (s[0] = e), (a[1] = r + t), (s[1] = n), this;
        },
      }),
      Object.assign(xi.prototype, e.prototype, {
        _bindAction: function (t, e) {
          var n = t._localRoot || this._root,
            i = t._clip.tracks,
            r = i.length,
            o = t._propertyBindings,
            a = t._interpolants,
            s = n.uuid,
            c = this._bindingsByRootAndName,
            l = c[s];
          void 0 === l && ((l = {}), (c[s] = l));
          for (var u = 0; u !== r; ++u) {
            var h = i[u],
              p = h.name,
              d = l[p];
            if (void 0 !== d) o[u] = d;
            else {
              if (void 0 !== (d = o[u])) {
                null === d._cacheIndex &&
                  (++d.referenceCount, this._addInactiveBinding(d, s, p));
                continue;
              }
              var f = e && e._propertyBindings[u].binding.parsedPath;
              ++(d = new fi(
                gi.create(n, p, f),
                h.ValueTypeName,
                h.getValueSize()
              )).referenceCount,
                this._addInactiveBinding(d, s, p),
                (o[u] = d);
            }
            a[u].resultBuffer = d.buffer;
          }
        },
        _activateAction: function (t) {
          if (!this._isActiveAction(t)) {
            if (null === t._cacheIndex) {
              var e = (t._localRoot || this._root).uuid,
                n = t._clip.uuid,
                i = this._actionsByClip[n];
              this._bindAction(t, i && i.knownActions[0]),
                this._addInactiveAction(t, n, e);
            }
            for (
              var r = t._propertyBindings, o = 0, a = r.length;
              o !== a;
              ++o
            ) {
              var s = r[o];
              0 == s.useCount++ &&
                (this._lendBinding(s), s.saveOriginalState());
            }
            this._lendAction(t);
          }
        },
        _deactivateAction: function (t) {
          if (this._isActiveAction(t)) {
            for (
              var e = t._propertyBindings, n = 0, i = e.length;
              n !== i;
              ++n
            ) {
              var r = e[n];
              0 == --r.useCount &&
                (r.restoreOriginalState(), this._takeBackBinding(r));
            }
            this._takeBackAction(t);
          }
        },
        _initMemoryManager: function () {
          (this._actions = []),
            (this._nActiveActions = 0),
            (this._actionsByClip = {}),
            (this._bindings = []),
            (this._nActiveBindings = 0),
            (this._bindingsByRootAndName = {}),
            (this._controlInterpolants = []),
            (this._nActiveControlInterpolants = 0);
          var t = this;
          this.stats = {
            actions: {
              get total() {
                return t._actions.length;
              },
              get inUse() {
                return t._nActiveActions;
              },
            },
            bindings: {
              get total() {
                return t._bindings.length;
              },
              get inUse() {
                return t._nActiveBindings;
              },
            },
            controlInterpolants: {
              get total() {
                return t._controlInterpolants.length;
              },
              get inUse() {
                return t._nActiveControlInterpolants;
              },
            },
          };
        },
        _isActiveAction: function (t) {
          var e = t._cacheIndex;
          return null !== e && e < this._nActiveActions;
        },
        _addInactiveAction: function (t, e, n) {
          var i = this._actions,
            r = this._actionsByClip,
            o = r[e];
          if (void 0 === o)
            (o = { knownActions: [t], actionByRoot: {} }),
              (t._byClipCacheIndex = 0),
              (r[e] = o);
          else {
            var a = o.knownActions;
            (t._byClipCacheIndex = a.length), a.push(t);
          }
          (t._cacheIndex = i.length), i.push(t), (o.actionByRoot[n] = t);
        },
        _removeInactiveAction: function (t) {
          var e = this._actions,
            n = e[e.length - 1],
            i = t._cacheIndex;
          (n._cacheIndex = i), (e[i] = n), e.pop(), (t._cacheIndex = null);
          var r = t._clip.uuid,
            o = this._actionsByClip,
            a = o[r],
            s = a.knownActions,
            c = s[s.length - 1],
            l = t._byClipCacheIndex;
          (c._byClipCacheIndex = l),
            (s[l] = c),
            s.pop(),
            (t._byClipCacheIndex = null),
            delete a.actionByRoot[(t._localRoot || this._root).uuid],
            0 === s.length && delete o[r],
            this._removeInactiveBindingsForAction(t);
        },
        _removeInactiveBindingsForAction: function (t) {
          for (var e = t._propertyBindings, n = 0, i = e.length; n !== i; ++n) {
            var r = e[n];
            0 == --r.referenceCount && this._removeInactiveBinding(r);
          }
        },
        _lendAction: function (t) {
          var e = this._actions,
            n = t._cacheIndex,
            i = this._nActiveActions++,
            r = e[i];
          (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
        },
        _takeBackAction: function (t) {
          var e = this._actions,
            n = t._cacheIndex,
            i = --this._nActiveActions,
            r = e[i];
          (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
        },
        _addInactiveBinding: function (t, e, n) {
          var i = this._bindingsByRootAndName,
            r = i[e],
            o = this._bindings;
          void 0 === r && ((r = {}), (i[e] = r)),
            (r[n] = t),
            (t._cacheIndex = o.length),
            o.push(t);
        },
        _removeInactiveBinding: function (t) {
          var e = this._bindings,
            n = t.binding,
            i = n.rootNode.uuid,
            r = n.path,
            o = this._bindingsByRootAndName,
            a = o[i],
            s = e[e.length - 1],
            c = t._cacheIndex;
          (s._cacheIndex = c), (e[c] = s), e.pop(), delete a[r];
          t: {
            for (var l in a) break t;
            delete o[i];
          }
        },
        _lendBinding: function (t) {
          var e = this._bindings,
            n = t._cacheIndex,
            i = this._nActiveBindings++,
            r = e[i];
          (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
        },
        _takeBackBinding: function (t) {
          var e = this._bindings,
            n = t._cacheIndex,
            i = --this._nActiveBindings,
            r = e[i];
          (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
        },
        _lendControlInterpolant: function () {
          var t = this._controlInterpolants,
            e = this._nActiveControlInterpolants++,
            n = t[e];
          return (
            void 0 === n &&
              (((n = new Rn(
                new Float32Array(2),
                new Float32Array(2),
                1,
                this._controlInterpolantsResultBuffer
              )).__cacheIndex = e),
              (t[e] = n)),
            n
          );
        },
        _takeBackControlInterpolant: function (t) {
          var e = this._controlInterpolants,
            n = t.__cacheIndex,
            i = --this._nActiveControlInterpolants,
            r = e[i];
          (t.__cacheIndex = i), (e[i] = t), (r.__cacheIndex = n), (e[n] = r);
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function (t, e) {
          var n = e || this._root,
            i = n.uuid,
            r = "string" == typeof t ? Bn.findByName(n, t) : t,
            o = null !== r ? r.uuid : t,
            a = this._actionsByClip[o],
            s = null;
          if (void 0 !== a) {
            var c = a.actionByRoot[i];
            if (void 0 !== c) return c;
            (s = a.knownActions[0]), null === r && (r = s._clip);
          }
          if (null === r) return null;
          var l = new yi(this, r, e);
          return this._bindAction(l, s), this._addInactiveAction(l, o, i), l;
        },
        existingAction: function (t, e) {
          var n = e || this._root,
            i = n.uuid,
            r = "string" == typeof t ? Bn.findByName(n, t) : t,
            o = r ? r.uuid : t,
            a = this._actionsByClip[o];
          return void 0 !== a ? a.actionByRoot[i] || null : null;
        },
        stopAllAction: function () {
          var t = this._actions,
            e = this._nActiveActions,
            n = this._bindings,
            i = this._nActiveBindings;
          for (
            this._nActiveActions = 0, this._nActiveBindings = 0, r = 0;
            r !== e;
            ++r
          )
            t[r].reset();
          for (var r = 0; r !== i; ++r) n[r].useCount = 0;
          return this;
        },
        update: function (t) {
          t *= this.timeScale;
          for (
            var e = this._actions,
              n = this._nActiveActions,
              i = (this.time += t),
              r = Math.sign(t),
              o = (this._accuIndex ^= 1),
              a = 0;
            a !== n;
            ++a
          )
            e[a]._update(i, t, r, o);
          for (
            var s = this._bindings, c = this._nActiveBindings, a = 0;
            a !== c;
            ++a
          )
            s[a].apply(o);
          return this;
        },
        getRoot: function () {
          return this._root;
        },
        uncacheClip: function (t) {
          var e = this._actions,
            n = t.uuid,
            i = this._actionsByClip,
            r = i[n];
          if (void 0 !== r) {
            for (var o = r.knownActions, a = 0, s = o.length; a !== s; ++a) {
              var c = o[a];
              this._deactivateAction(c);
              var l = c._cacheIndex,
                u = e[e.length - 1];
              (c._cacheIndex = null),
                (c._byClipCacheIndex = null),
                (u._cacheIndex = l),
                (e[l] = u),
                e.pop(),
                this._removeInactiveBindingsForAction(c);
            }
            delete i[n];
          }
        },
        uncacheRoot: function (t) {
          var e = t.uuid,
            n = this._actionsByClip;
          for (var i in n) {
            var r = n[i].actionByRoot[e];
            void 0 !== r &&
              (this._deactivateAction(r), this._removeInactiveAction(r));
          }
          var o = this._bindingsByRootAndName[e];
          if (void 0 !== o)
            for (var a in o) {
              var s = o[a];
              s.restoreOriginalState(), this._removeInactiveBinding(s);
            }
        },
        uncacheAction: function (t, e) {
          var n = this.existingAction(t, e);
          null !== n &&
            (this._deactivateAction(n), this._removeInactiveAction(n));
        },
      }),
      (bi.prototype.clone = function () {
        return new bi(
          void 0 === this.value.clone ? this.value : this.value.clone()
        );
      }),
      (_i.prototype = Object.assign(Object.create(Mt.prototype), {
        constructor: _i,
        isInstancedBufferGeometry: !0,
        copy: function (t) {
          return (
            Mt.prototype.copy.call(this, t),
            (this.maxInstancedCount = t.maxInstancedCount),
            this
          );
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
      })),
      Object.defineProperties(wi.prototype, {
        count: {
          get: function () {
            return this.data.count;
          },
        },
        array: {
          get: function () {
            return this.data.array;
          },
        },
      }),
      Object.assign(wi.prototype, {
        isInterleavedBufferAttribute: !0,
        setX: function (t, e) {
          return (
            (this.data.array[t * this.data.stride + this.offset] = e), this
          );
        },
        setY: function (t, e) {
          return (
            (this.data.array[t * this.data.stride + this.offset + 1] = e), this
          );
        },
        setZ: function (t, e) {
          return (
            (this.data.array[t * this.data.stride + this.offset + 2] = e), this
          );
        },
        setW: function (t, e) {
          return (
            (this.data.array[t * this.data.stride + this.offset + 3] = e), this
          );
        },
        getX: function (t) {
          return this.data.array[t * this.data.stride + this.offset];
        },
        getY: function (t) {
          return this.data.array[t * this.data.stride + this.offset + 1];
        },
        getZ: function (t) {
          return this.data.array[t * this.data.stride + this.offset + 2];
        },
        getW: function (t) {
          return this.data.array[t * this.data.stride + this.offset + 3];
        },
        setXY: function (t, e, n) {
          return (
            (t = t * this.data.stride + this.offset),
            (this.data.array[t + 0] = e),
            (this.data.array[t + 1] = n),
            this
          );
        },
        setXYZ: function (t, e, n, i) {
          return (
            (t = t * this.data.stride + this.offset),
            (this.data.array[t + 0] = e),
            (this.data.array[t + 1] = n),
            (this.data.array[t + 2] = i),
            this
          );
        },
        setXYZW: function (t, e, n, i, r) {
          return (
            (t = t * this.data.stride + this.offset),
            (this.data.array[t + 0] = e),
            (this.data.array[t + 1] = n),
            (this.data.array[t + 2] = i),
            (this.data.array[t + 3] = r),
            this
          );
        },
      }),
      Object.defineProperty(Mi.prototype, "needsUpdate", {
        set: function (t) {
          !0 === t && this.version++;
        },
      }),
      Object.assign(Mi.prototype, {
        isInterleavedBuffer: !0,
        setArray: function (t) {
          if (Array.isArray(t))
            throw new TypeError(
              "THREE.BufferAttribute: array should be a Typed Array."
            );
          (this.count = void 0 !== t ? t.length / this.stride : 0),
            (this.array = t);
        },
        setDynamic: function (t) {
          return (this.dynamic = t), this;
        },
        copy: function (t) {
          return (
            (this.array = new t.array.constructor(t.array)),
            (this.count = t.count),
            (this.stride = t.stride),
            (this.dynamic = t.dynamic),
            this
          );
        },
        copyAt: function (t, e, n) {
          (t *= this.stride), (n *= e.stride);
          for (var i = 0, r = this.stride; i < r; i++)
            this.array[t + i] = e.array[n + i];
          return this;
        },
        set: function (t, e) {
          return void 0 === e && (e = 0), this.array.set(t, e), this;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        onUpload: function (t) {
          return (this.onUploadCallback = t), this;
        },
      }),
      (Ei.prototype = Object.assign(Object.create(Mi.prototype), {
        constructor: Ei,
        isInstancedInterleavedBuffer: !0,
        copy: function (t) {
          return (
            Mi.prototype.copy.call(this, t),
            (this.meshPerAttribute = t.meshPerAttribute),
            this
          );
        },
      })),
      (Ti.prototype = Object.assign(Object.create(ht.prototype), {
        constructor: Ti,
        isInstancedBufferAttribute: !0,
        copy: function (t) {
          return (
            ht.prototype.copy.call(this, t),
            (this.meshPerAttribute = t.meshPerAttribute),
            this
          );
        },
      })),
      Object.assign(Si.prototype, {
        linePrecision: 1,
        set: function (t, e) {
          this.ray.set(t, e);
        },
        setFromCamera: function (t, e) {
          e && e.isPerspectiveCamera
            ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
              this.ray.direction
                .set(t.x, t.y, 0.5)
                .unproject(e)
                .sub(this.ray.origin)
                .normalize())
            : e && e.isOrthographicCamera
            ? (this.ray.origin
                .set(t.x, t.y, (e.near + e.far) / (e.near - e.far))
                .unproject(e),
              this.ray.direction
                .set(0, 0, -1)
                .transformDirection(e.matrixWorld))
            : console.error("THREE.Raycaster: Unsupported camera type.");
        },
        intersectObject: function (t, e) {
          var n = [];
          return Li(t, this, n, e), n.sort(Ai), n;
        },
        intersectObjects: function (t, e) {
          var n = [];
          if (!1 === Array.isArray(t))
            return (
              console.warn(
                "THREE.Raycaster.intersectObjects: objects is not an Array."
              ),
              n
            );
          for (var i = 0, r = t.length; i < r; i++) Li(t[i], this, n, e);
          return n.sort(Ai), n;
        },
      }),
      Object.assign(Ri.prototype, {
        start: function () {
          (this.startTime = (
            "undefined" == typeof performance ? Date : performance
          ).now()),
            (this.oldTime = this.startTime),
            (this.elapsedTime = 0),
            (this.running = !0);
        },
        stop: function () {
          this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
        },
        getElapsedTime: function () {
          return this.getDelta(), this.elapsedTime;
        },
        getDelta: function () {
          var t = 0;
          if (this.autoStart && !this.running) return this.start(), 0;
          if (this.running) {
            var e = (
              "undefined" == typeof performance ? Date : performance
            ).now();
            (t = (e - this.oldTime) / 1e3),
              (this.oldTime = e),
              (this.elapsedTime += t);
          }
          return t;
        },
      }),
      Object.assign(Pi.prototype, {
        set: function (t, e, n) {
          return (this.radius = t), (this.phi = e), (this.theta = n), this;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          return (
            (this.radius = t.radius),
            (this.phi = t.phi),
            (this.theta = t.theta),
            this
          );
        },
        makeSafe: function () {
          return (
            (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))),
            this
          );
        },
        setFromVector3: function (t) {
          return (
            (this.radius = t.length()),
            0 === this.radius
              ? ((this.theta = 0), (this.phi = 0))
              : ((this.theta = Math.atan2(t.x, t.z)),
                (this.phi = Math.acos(sa.clamp(t.y / this.radius, -1, 1)))),
            this
          );
        },
      }),
      Object.assign(Ci.prototype, {
        set: function (t, e, n) {
          return (this.radius = t), (this.theta = e), (this.y = n), this;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          return (
            (this.radius = t.radius),
            (this.theta = t.theta),
            (this.y = t.y),
            this
          );
        },
        setFromVector3: function (t) {
          return (
            (this.radius = Math.sqrt(t.x * t.x + t.z * t.z)),
            (this.theta = Math.atan2(t.x, t.z)),
            (this.y = t.y),
            this
          );
        },
      }),
      ((Oi.prototype = Object.create(at.prototype)).constructor = Oi),
      (Oi.prototype.isImmediateRenderObject = !0),
      ((Ii.prototype = Object.create(ce.prototype)).constructor = Ii),
      (Ii.prototype.update = (function () {
        var t = new o(),
          e = new o(),
          n = new a();
        return function () {
          var i = ["a", "b", "c"];
          this.object.updateMatrixWorld(!0),
            n.getNormalMatrix(this.object.matrixWorld);
          var r = this.object.matrixWorld,
            o = this.geometry.attributes.position,
            a = this.object.geometry;
          if (a && a.isGeometry)
            for (
              var s = a.vertices, c = a.faces, l = 0, u = 0, h = c.length;
              u < h;
              u++
            )
              for (
                var p = c[u], d = 0, f = p.vertexNormals.length;
                d < f;
                d++
              ) {
                var m = s[p[i[d]]],
                  g = p.vertexNormals[d];
                t.copy(m).applyMatrix4(r),
                  e
                    .copy(g)
                    .applyMatrix3(n)
                    .normalize()
                    .multiplyScalar(this.size)
                    .add(t),
                  o.setXYZ(l, t.x, t.y, t.z),
                  (l += 1),
                  o.setXYZ(l, e.x, e.y, e.z),
                  (l += 1);
              }
          else if (a && a.isBufferGeometry)
            for (
              var v = a.attributes.position,
                y = a.attributes.normal,
                l = 0,
                d = 0,
                f = v.count;
              d < f;
              d++
            )
              t.set(v.getX(d), v.getY(d), v.getZ(d)).applyMatrix4(r),
                e.set(y.getX(d), y.getY(d), y.getZ(d)),
                e.applyMatrix3(n).normalize().multiplyScalar(this.size).add(t),
                o.setXYZ(l, t.x, t.y, t.z),
                (l += 1),
                o.setXYZ(l, e.x, e.y, e.z),
                (l += 1);
          o.needsUpdate = !0;
        };
      })()),
      ((Di.prototype = Object.create(at.prototype)).constructor = Di),
      (Di.prototype.dispose = function () {
        this.cone.geometry.dispose(), this.cone.material.dispose();
      }),
      (Di.prototype.update = (function () {
        var t = new o(),
          e = new o();
        return function () {
          this.light.updateMatrixWorld();
          var n = this.light.distance ? this.light.distance : 1e3,
            i = n * Math.tan(this.light.angle);
          this.cone.scale.set(i, i, n),
            t.setFromMatrixPosition(this.light.matrixWorld),
            e.setFromMatrixPosition(this.light.target.matrixWorld),
            this.cone.lookAt(e.sub(t)),
            void 0 !== this.color
              ? this.cone.material.color.set(this.color)
              : this.cone.material.color.copy(this.light.color);
        };
      })()),
      ((Ni.prototype = Object.create(ce.prototype)).constructor = Ni),
      (Ni.prototype.updateMatrixWorld = (function () {
        var t = new o(),
          e = new i(),
          n = new i();
        return function (i) {
          var r = this.bones,
            o = this.geometry,
            a = o.getAttribute("position");
          n.getInverse(this.root.matrixWorld);
          for (var s = 0, c = 0; s < r.length; s++) {
            var l = r[s];
            l.parent &&
              l.parent.isBone &&
              (e.multiplyMatrices(n, l.matrixWorld),
              t.setFromMatrixPosition(e),
              a.setXYZ(c, t.x, t.y, t.z),
              e.multiplyMatrices(n, l.parent.matrixWorld),
              t.setFromMatrixPosition(e),
              a.setXYZ(c + 1, t.x, t.y, t.z),
              (c += 2));
          }
          (o.getAttribute("position").needsUpdate = !0),
            at.prototype.updateMatrixWorld.call(this, i);
        };
      })()),
      ((zi.prototype = Object.create(It.prototype)).constructor = zi),
      (zi.prototype.dispose = function () {
        this.geometry.dispose(), this.material.dispose();
      }),
      (zi.prototype.update = function () {
        void 0 !== this.color
          ? this.material.color.set(this.color)
          : this.material.color.copy(this.light.color);
      }),
      ((ki.prototype = Object.create(at.prototype)).constructor = ki),
      (ki.prototype.dispose = function () {
        this.children[0].geometry.dispose(),
          this.children[0].material.dispose();
      }),
      (ki.prototype.update = function () {
        var t = 0.5 * this.light.width,
          e = 0.5 * this.light.height,
          n = this.line.geometry.attributes.position,
          i = n.array;
        (i[0] = t),
          (i[1] = -e),
          (i[2] = 0),
          (i[3] = t),
          (i[4] = e),
          (i[5] = 0),
          (i[6] = -t),
          (i[7] = e),
          (i[8] = 0),
          (i[9] = -t),
          (i[10] = -e),
          (i[11] = 0),
          (i[12] = t),
          (i[13] = -e),
          (i[14] = 0),
          (n.needsUpdate = !0),
          void 0 !== this.color
            ? this.line.material.color.set(this.color)
            : this.line.material.color.copy(this.light.color);
      }),
      ((Fi.prototype = Object.create(at.prototype)).constructor = Fi),
      (Fi.prototype.dispose = function () {
        this.children[0].geometry.dispose(),
          this.children[0].material.dispose();
      }),
      (Fi.prototype.update = (function () {
        var t = new o(),
          e = new W(),
          n = new W();
        return function () {
          var i = this.children[0];
          if (void 0 !== this.color) this.material.color.set(this.color);
          else {
            var r = i.geometry.getAttribute("color");
            e.copy(this.light.color), n.copy(this.light.groundColor);
            for (var o = 0, a = r.count; o < a; o++) {
              var s = o < a / 2 ? e : n;
              r.setXYZ(o, s.r, s.g, s.b);
            }
            r.needsUpdate = !0;
          }
          i.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate());
        };
      })()),
      ((Bi.prototype = Object.create(ce.prototype)).constructor = Bi),
      ((Hi.prototype = Object.create(ce.prototype)).constructor = Hi),
      ((ji.prototype = Object.create(ce.prototype)).constructor = ji),
      (ji.prototype.update = (function () {
        var t = new o(),
          e = new o(),
          n = new a();
        return function () {
          this.object.updateMatrixWorld(!0),
            n.getNormalMatrix(this.object.matrixWorld);
          for (
            var i = this.object.matrixWorld,
              r = this.geometry.attributes.position,
              o = this.object.geometry,
              a = o.vertices,
              s = o.faces,
              c = 0,
              l = 0,
              u = s.length;
            l < u;
            l++
          ) {
            var h = s[l],
              p = h.normal;
            t
              .copy(a[h.a])
              .add(a[h.b])
              .add(a[h.c])
              .divideScalar(3)
              .applyMatrix4(i),
              e
                .copy(p)
                .applyMatrix3(n)
                .normalize()
                .multiplyScalar(this.size)
                .add(t),
              r.setXYZ(c, t.x, t.y, t.z),
              (c += 1),
              r.setXYZ(c, e.x, e.y, e.z),
              (c += 1);
          }
          r.needsUpdate = !0;
        };
      })()),
      ((Gi.prototype = Object.create(at.prototype)).constructor = Gi),
      (Gi.prototype.dispose = function () {
        this.lightPlane.geometry.dispose(),
          this.lightPlane.material.dispose(),
          this.targetLine.geometry.dispose(),
          this.targetLine.material.dispose();
      }),
      (Gi.prototype.update = (function () {
        var t = new o(),
          e = new o(),
          n = new o();
        return function () {
          t.setFromMatrixPosition(this.light.matrixWorld),
            e.setFromMatrixPosition(this.light.target.matrixWorld),
            n.subVectors(e, t),
            this.lightPlane.lookAt(n),
            void 0 !== this.color
              ? (this.lightPlane.material.color.set(this.color),
                this.targetLine.material.color.set(this.color))
              : (this.lightPlane.material.color.copy(this.light.color),
                this.targetLine.material.color.copy(this.light.color)),
            this.targetLine.lookAt(n),
            (this.targetLine.scale.z = n.length());
        };
      })()),
      ((Vi.prototype = Object.create(ce.prototype)).constructor = Vi),
      (Vi.prototype.update = (function () {
        function t(t, o, a, s) {
          i.set(o, a, s).unproject(r);
          var c = n[t];
          if (void 0 !== c)
            for (
              var l = e.getAttribute("position"), u = 0, h = c.length;
              u < h;
              u++
            )
              l.setXYZ(c[u], i.x, i.y, i.z);
        }
        var e,
          n,
          i = new o(),
          r = new st();
        return function () {
          (e = this.geometry),
            (n = this.pointMap),
            r.projectionMatrix.copy(this.camera.projectionMatrix),
            t("c", 0, 0, -1),
            t("t", 0, 0, 1),
            t("n1", -1, -1, -1),
            t("n2", 1, -1, -1),
            t("n3", -1, 1, -1),
            t("n4", 1, 1, -1),
            t("f1", -1, -1, 1),
            t("f2", 1, -1, 1),
            t("f3", -1, 1, 1),
            t("f4", 1, 1, 1),
            t("u1", 0.7, 1.1, -1),
            t("u2", -0.7, 1.1, -1),
            t("u3", 0, 2, -1),
            t("cf1", -1, 0, 1),
            t("cf2", 1, 0, 1),
            t("cf3", 0, -1, 1),
            t("cf4", 0, 1, 1),
            t("cn1", -1, 0, -1),
            t("cn2", 1, 0, -1),
            t("cn3", 0, -1, -1),
            t("cn4", 0, 1, -1),
            (e.getAttribute("position").needsUpdate = !0);
        };
      })()),
      ((Wi.prototype = Object.create(ce.prototype)).constructor = Wi),
      (Wi.prototype.update = (function () {
        var t = new K();
        return function (e) {
          if (
            (void 0 !== e &&
              console.warn(
                "THREE.BoxHelper: .update() has no longer arguments."
              ),
            void 0 !== this.object && t.setFromObject(this.object),
            !t.isEmpty())
          ) {
            var n = t.min,
              i = t.max,
              r = this.geometry.attributes.position,
              o = r.array;
            (o[0] = i.x),
              (o[1] = i.y),
              (o[2] = i.z),
              (o[3] = n.x),
              (o[4] = i.y),
              (o[5] = i.z),
              (o[6] = n.x),
              (o[7] = n.y),
              (o[8] = i.z),
              (o[9] = i.x),
              (o[10] = n.y),
              (o[11] = i.z),
              (o[12] = i.x),
              (o[13] = i.y),
              (o[14] = n.z),
              (o[15] = n.x),
              (o[16] = i.y),
              (o[17] = n.z),
              (o[18] = n.x),
              (o[19] = n.y),
              (o[20] = n.z),
              (o[21] = i.x),
              (o[22] = n.y),
              (o[23] = n.z),
              (r.needsUpdate = !0),
              this.geometry.computeBoundingSphere();
          }
        };
      })()),
      (Wi.prototype.setFromObject = function (t) {
        return (this.object = t), this.update(), this;
      }),
      ((Xi.prototype = Object.create(ce.prototype)).constructor = Xi),
      (Xi.prototype.updateMatrixWorld = function (t) {
        var e = this.box;
        e.isEmpty() ||
          (e.getCenter(this.position),
          e.getSize(this.scale),
          this.scale.multiplyScalar(0.5),
          at.prototype.updateMatrixWorld.call(this, t));
      }),
      ((Yi.prototype = Object.create(se.prototype)).constructor = Yi),
      (Yi.prototype.updateMatrixWorld = function (t) {
        var e = -this.plane.constant;
        Math.abs(e) < 1e-8 && (e = 1e-8),
          this.scale.set(0.5 * this.size, 0.5 * this.size, e),
          this.lookAt(this.plane.normal),
          at.prototype.updateMatrixWorld.call(this, t);
      });
    var Ha, ja;
    ((qi.prototype = Object.create(at.prototype)).constructor = qi),
      (qi.prototype.setDirection = (function () {
        var t,
          e = new o();
        return function (n) {
          n.y > 0.99999
            ? this.quaternion.set(0, 0, 0, 1)
            : n.y < -0.99999
            ? this.quaternion.set(1, 0, 0, 0)
            : (e.set(n.z, 0, -n.x).normalize(),
              (t = Math.acos(n.y)),
              this.quaternion.setFromAxisAngle(e, t));
        };
      })()),
      (qi.prototype.setLength = function (t, e, n) {
        void 0 === e && (e = 0.2 * t),
          void 0 === n && (n = 0.2 * e),
          this.line.scale.set(1, Math.max(0, t - e), 1),
          this.line.updateMatrix(),
          this.cone.scale.set(n, e, n),
          (this.cone.position.y = t),
          this.cone.updateMatrix();
      }),
      (qi.prototype.setColor = function (t) {
        this.line.material.color.copy(t), this.cone.material.color.copy(t);
      }),
      (($i.prototype = Object.create(ce.prototype)).constructor = $i);
    var Ga = new o(),
      Va = new Zi(),
      Wa = new Zi(),
      Xa = new Zi();
    ((Ji.prototype = Object.create($n.prototype)).constructor = Ji),
      (Ji.prototype.isCatmullRomCurve3 = !0),
      (Ji.prototype.getPoint = function (t, e) {
        var n = e || new o(),
          i = this.points,
          r = i.length,
          a = (r - (this.closed ? 0 : 1)) * t,
          s = Math.floor(a),
          c = a - s;
        this.closed
          ? (s +=
              s > 0 ? 0 : (Math.floor(Math.abs(s) / i.length) + 1) * i.length)
          : 0 === c && s === r - 1 && ((s = r - 2), (c = 1));
        var l, u, h, p;
        if (
          (this.closed || s > 0
            ? (l = i[(s - 1) % r])
            : (Ga.subVectors(i[0], i[1]).add(i[0]), (l = Ga)),
          (u = i[s % r]),
          (h = i[(s + 1) % r]),
          this.closed || s + 2 < r
            ? (p = i[(s + 2) % r])
            : (Ga.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), (p = Ga)),
          "centripetal" === this.curveType || "chordal" === this.curveType)
        ) {
          var d = "chordal" === this.curveType ? 0.5 : 0.25,
            f = Math.pow(l.distanceToSquared(u), d),
            m = Math.pow(u.distanceToSquared(h), d),
            g = Math.pow(h.distanceToSquared(p), d);
          m < 1e-4 && (m = 1),
            f < 1e-4 && (f = m),
            g < 1e-4 && (g = m),
            Va.initNonuniformCatmullRom(l.x, u.x, h.x, p.x, f, m, g),
            Wa.initNonuniformCatmullRom(l.y, u.y, h.y, p.y, f, m, g),
            Xa.initNonuniformCatmullRom(l.z, u.z, h.z, p.z, f, m, g);
        } else
          "catmullrom" === this.curveType &&
            (Va.initCatmullRom(l.x, u.x, h.x, p.x, this.tension),
            Wa.initCatmullRom(l.y, u.y, h.y, p.y, this.tension),
            Xa.initCatmullRom(l.z, u.z, h.z, p.z, this.tension));
        return n.set(Va.calc(c), Wa.calc(c), Xa.calc(c)), n;
      }),
      (Ji.prototype.copy = function (t) {
        $n.prototype.copy.call(this, t), (this.points = []);
        for (var e = 0, n = t.points.length; e < n; e++) {
          var i = t.points[e];
          this.points.push(i.clone());
        }
        return (
          (this.closed = t.closed),
          (this.curveType = t.curveType),
          (this.tension = t.tension),
          this
        );
      }),
      ((Qi.prototype = Object.create($n.prototype)).constructor = Qi),
      (Qi.prototype.isCubicBezierCurve3 = !0),
      (Qi.prototype.getPoint = function (t, e) {
        var n = e || new o(),
          i = this.v0,
          r = this.v1,
          a = this.v2,
          s = this.v3;
        return (
          n.set(
            qn(t, i.x, r.x, a.x, s.x),
            qn(t, i.y, r.y, a.y, s.y),
            qn(t, i.z, r.z, a.z, s.z)
          ),
          n
        );
      }),
      (Qi.prototype.copy = function (t) {
        return (
          $n.prototype.copy.call(this, t),
          this.v0.copy(t.v0),
          this.v1.copy(t.v1),
          this.v2.copy(t.v2),
          this.v3.copy(t.v3),
          this
        );
      }),
      ((Ki.prototype = Object.create($n.prototype)).constructor = Ki),
      (Ki.prototype.isQuadraticBezierCurve3 = !0),
      (Ki.prototype.getPoint = function (t, e) {
        var n = e || new o(),
          i = this.v0,
          r = this.v1,
          a = this.v2;
        return (
          n.set(
            Yn(t, i.x, r.x, a.x),
            Yn(t, i.y, r.y, a.y),
            Yn(t, i.z, r.z, a.z)
          ),
          n
        );
      }),
      (Ki.prototype.copy = function (t) {
        return (
          $n.prototype.copy.call(this, t),
          this.v0.copy(t.v0),
          this.v1.copy(t.v1),
          this.v2.copy(t.v2),
          this
        );
      }),
      ((tr.prototype = Object.create($n.prototype)).constructor = tr),
      (tr.prototype.isLineCurve3 = !0),
      (tr.prototype.getPoint = function (t, e) {
        var n = e || new o();
        return (
          1 === t
            ? n.copy(this.v2)
            : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
          n
        );
      }),
      (tr.prototype.getPointAt = function (t, e) {
        return this.getPoint(t, e);
      }),
      (tr.prototype.copy = function (t) {
        return (
          $n.prototype.copy.call(this, t),
          this.v1.copy(t.v1),
          this.v2.copy(t.v2),
          this
        );
      }),
      ((er.prototype = Object.create(Qn.prototype)).constructor = er),
      (er.prototype.isArcCurve = !0);
    ($n.create = function (t, e) {
      return (
        console.log("THREE.Curve.create() has been deprecated"),
        (t.prototype = Object.create($n.prototype)),
        (t.prototype.constructor = t),
        (t.prototype.getPoint = e),
        t
      );
    }),
      Object.assign(Jn.prototype, {
        createPointsGeometry: function (t) {
          console.warn(
            "THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
          );
          var e = this.getPoints(t);
          return this.createGeometry(e);
        },
        createSpacedPointsGeometry: function (t) {
          console.warn(
            "THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
          );
          var e = this.getSpacedPoints(t);
          return this.createGeometry(e);
        },
        createGeometry: function (t) {
          console.warn(
            "THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
          );
          for (var e = new ut(), n = 0, i = t.length; n < i; n++) {
            var r = t[n];
            e.vertices.push(new o(r.x, r.y, r.z || 0));
          }
          return e;
        },
      }),
      Object.assign(ni.prototype, {
        fromPoints: function (t) {
          console.warn(
            "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
          ),
            this.setFromPoints(t);
        },
      }),
      (nr.prototype = Object.create(Ji.prototype)),
      (ir.prototype = Object.create(Ji.prototype)),
      (rr.prototype = Object.create(Ji.prototype)),
      Object.assign(rr.prototype, {
        initFromArray: function () {
          console.error("THREE.Spline: .initFromArray() has been removed.");
        },
        getControlPointsArray: function () {
          console.error(
            "THREE.Spline: .getControlPointsArray() has been removed."
          );
        },
        reparametrizeByArcLength: function () {
          console.error(
            "THREE.Spline: .reparametrizeByArcLength() has been removed."
          );
        },
      }),
      (Bi.prototype.setColors = function () {
        console.error(
          "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
        );
      }),
      (Ni.prototype.update = function () {
        console.error(
          "THREE.SkeletonHelper: update() no longer needs to be called."
        );
      }),
      Object.assign(X.prototype, {
        center: function (t) {
          return (
            console.warn(
              "THREE.Box2: .center() has been renamed to .getCenter()."
            ),
            this.getCenter(t)
          );
        },
        empty: function () {
          return (
            console.warn(
              "THREE.Box2: .empty() has been renamed to .isEmpty()."
            ),
            this.isEmpty()
          );
        },
        isIntersectionBox: function (t) {
          return (
            console.warn(
              "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
            ),
            this.intersectsBox(t)
          );
        },
        size: function (t) {
          return (
            console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
            this.getSize(t)
          );
        },
      }),
      Object.assign(K.prototype, {
        center: function (t) {
          return (
            console.warn(
              "THREE.Box3: .center() has been renamed to .getCenter()."
            ),
            this.getCenter(t)
          );
        },
        empty: function () {
          return (
            console.warn(
              "THREE.Box3: .empty() has been renamed to .isEmpty()."
            ),
            this.isEmpty()
          );
        },
        isIntersectionBox: function (t) {
          return (
            console.warn(
              "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
            ),
            this.intersectsBox(t)
          );
        },
        isIntersectionSphere: function (t) {
          return (
            console.warn(
              "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
            ),
            this.intersectsSphere(t)
          );
        },
        size: function (t) {
          return (
            console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
            this.getSize(t)
          );
        },
      }),
      (Ct.prototype.center = function (t) {
        return (
          console.warn(
            "THREE.Line3: .center() has been renamed to .getCenter()."
          ),
          this.getCenter(t)
        );
      }),
      Object.assign(sa, {
        random16: function () {
          return (
            console.warn(
              "THREE.Math: .random16() has been deprecated. Use Math.random() instead."
            ),
            Math.random()
          );
        },
        nearestPowerOfTwo: function (t) {
          return (
            console.warn(
              "THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."
            ),
            sa.floorPowerOfTwo(t)
          );
        },
        nextPowerOfTwo: function (t) {
          return (
            console.warn(
              "THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."
            ),
            sa.ceilPowerOfTwo(t)
          );
        },
      }),
      Object.assign(a.prototype, {
        flattenToArrayOffset: function (t, e) {
          return (
            console.warn(
              "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
            ),
            this.toArray(t, e)
          );
        },
        multiplyVector3: function (t) {
          return (
            console.warn(
              "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
            ),
            t.applyMatrix3(this)
          );
        },
        multiplyVector3Array: function () {
          console.error(
            "THREE.Matrix3: .multiplyVector3Array() has been removed."
          );
        },
        applyToBuffer: function (t) {
          return (
            console.warn(
              "THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."
            ),
            this.applyToBufferAttribute(t)
          );
        },
        applyToVector3Array: function () {
          console.error(
            "THREE.Matrix3: .applyToVector3Array() has been removed."
          );
        },
      }),
      Object.assign(i.prototype, {
        extractPosition: function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
            ),
            this.copyPosition(t)
          );
        },
        flattenToArrayOffset: function (t, e) {
          return (
            console.warn(
              "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
            ),
            this.toArray(t, e)
          );
        },
        getPosition: (function () {
          var t;
          return function () {
            return (
              void 0 === t && (t = new o()),
              console.warn(
                "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
              ),
              t.setFromMatrixColumn(this, 3)
            );
          };
        })(),
        setRotationFromQuaternion: function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
            ),
            this.makeRotationFromQuaternion(t)
          );
        },
        multiplyToArray: function () {
          console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
        },
        multiplyVector3: function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
            ),
            t.applyMatrix4(this)
          );
        },
        multiplyVector4: function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
            ),
            t.applyMatrix4(this)
          );
        },
        multiplyVector3Array: function () {
          console.error(
            "THREE.Matrix4: .multiplyVector3Array() has been removed."
          );
        },
        rotateAxis: function (t) {
          console.warn(
            "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
          ),
            t.transformDirection(this);
        },
        crossVector: function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
            ),
            t.applyMatrix4(this)
          );
        },
        translate: function () {
          console.error("THREE.Matrix4: .translate() has been removed.");
        },
        rotateX: function () {
          console.error("THREE.Matrix4: .rotateX() has been removed.");
        },
        rotateY: function () {
          console.error("THREE.Matrix4: .rotateY() has been removed.");
        },
        rotateZ: function () {
          console.error("THREE.Matrix4: .rotateZ() has been removed.");
        },
        rotateByAxis: function () {
          console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
        },
        applyToBuffer: function (t) {
          return (
            console.warn(
              "THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."
            ),
            this.applyToBufferAttribute(t)
          );
        },
        applyToVector3Array: function () {
          console.error(
            "THREE.Matrix4: .applyToVector3Array() has been removed."
          );
        },
        makeFrustum: function (t, e, n, i, r, o) {
          return (
            console.warn(
              "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
            ),
            this.makePerspective(t, e, i, n, r, o)
          );
        },
      }),
      (et.prototype.isIntersectionLine = function (t) {
        return (
          console.warn(
            "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
          ),
          this.intersectsLine(t)
        );
      }),
      (r.prototype.multiplyVector3 = function (t) {
        return (
          console.warn(
            "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
          ),
          t.applyQuaternion(this)
        );
      }),
      Object.assign(Pt.prototype, {
        isIntersectionBox: function (t) {
          return (
            console.warn(
              "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
            ),
            this.intersectsBox(t)
          );
        },
        isIntersectionPlane: function (t) {
          return (
            console.warn(
              "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
            ),
            this.intersectsPlane(t)
          );
        },
        isIntersectionSphere: function (t) {
          return (
            console.warn(
              "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
            ),
            this.intersectsSphere(t)
          );
        },
      }),
      Object.assign(ii.prototype, {
        extractAllPoints: function (t) {
          return (
            console.warn(
              "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
            ),
            this.extractPoints(t)
          );
        },
        extrude: function (t) {
          return (
            console.warn(
              "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
            ),
            new Ue(this, t)
          );
        },
        makeGeometry: function (t) {
          return (
            console.warn(
              "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
            ),
            new We(this, t)
          );
        },
      }),
      Object.assign(n.prototype, {
        fromAttribute: function (t, e, n) {
          return (
            console.warn(
              "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
            ),
            this.fromBufferAttribute(t, e, n)
          );
        },
        distanceToManhattan: function (t) {
          return (
            console.warn(
              "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
            ),
            this.manhattanDistanceTo(t)
          );
        },
        lengthManhattan: function () {
          return (
            console.warn(
              "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
            ),
            this.manhattanLength()
          );
        },
      }),
      Object.assign(o.prototype, {
        setEulerFromRotationMatrix: function () {
          console.error(
            "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
          );
        },
        setEulerFromQuaternion: function () {
          console.error(
            "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
          );
        },
        getPositionFromMatrix: function (t) {
          return (
            console.warn(
              "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
            ),
            this.setFromMatrixPosition(t)
          );
        },
        getScaleFromMatrix: function (t) {
          return (
            console.warn(
              "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
            ),
            this.setFromMatrixScale(t)
          );
        },
        getColumnFromMatrix: function (t, e) {
          return (
            console.warn(
              "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
            ),
            this.setFromMatrixColumn(e, t)
          );
        },
        applyProjection: function (t) {
          return (
            console.warn(
              "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
            ),
            this.applyMatrix4(t)
          );
        },
        fromAttribute: function (t, e, n) {
          return (
            console.warn(
              "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
            ),
            this.fromBufferAttribute(t, e, n)
          );
        },
        distanceToManhattan: function (t) {
          return (
            console.warn(
              "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
            ),
            this.manhattanDistanceTo(t)
          );
        },
        lengthManhattan: function () {
          return (
            console.warn(
              "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
            ),
            this.manhattanLength()
          );
        },
      }),
      Object.assign(c.prototype, {
        fromAttribute: function (t, e, n) {
          return (
            console.warn(
              "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
            ),
            this.fromBufferAttribute(t, e, n)
          );
        },
        lengthManhattan: function () {
          return (
            console.warn(
              "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
            ),
            this.manhattanLength()
          );
        },
      }),
      (ut.prototype.computeTangents = function () {
        console.warn("THREE.Geometry: .computeTangents() has been removed.");
      }),
      Object.assign(at.prototype, {
        getChildByName: function (t) {
          return (
            console.warn(
              "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
            ),
            this.getObjectByName(t)
          );
        },
        renderDepth: function () {
          console.warn(
            "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
          );
        },
        translate: function (t, e) {
          return (
            console.warn(
              "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
            ),
            this.translateOnAxis(e, t)
          );
        },
      }),
      Object.defineProperties(at.prototype, {
        eulerOrder: {
          get: function () {
            return (
              console.warn(
                "THREE.Object3D: .eulerOrder is now .rotation.order."
              ),
              this.rotation.order
            );
          },
          set: function (t) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
              (this.rotation.order = t);
          },
        },
        useQuaternion: {
          get: function () {
            console.warn(
              "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
          },
          set: function () {
            console.warn(
              "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
            );
          },
        },
      }),
      Object.defineProperties(ne.prototype, {
        objects: {
          get: function () {
            return (
              console.warn("THREE.LOD: .objects has been renamed to .levels."),
              this.levels
            );
          },
        },
      }),
      Object.defineProperty(ie.prototype, "useVertexTexture", {
        get: function () {
          console.warn("THREE.Skeleton: useVertexTexture has been removed.");
        },
        set: function () {
          console.warn("THREE.Skeleton: useVertexTexture has been removed.");
        },
      }),
      Object.defineProperty($n.prototype, "__arcLengthDivisions", {
        get: function () {
          return (
            console.warn(
              "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
            ),
            this.arcLengthDivisions
          );
        },
        set: function (t) {
          console.warn(
            "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
          ),
            (this.arcLengthDivisions = t);
        },
      }),
      (Xt.prototype.setLens = function (t, e) {
        console.warn(
          "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
        ),
          void 0 !== e && (this.filmGauge = e),
          this.setFocalLength(t);
      }),
      Object.defineProperties(vn.prototype, {
        onlyShadow: {
          set: function () {
            console.warn("THREE.Light: .onlyShadow has been removed.");
          },
        },
        shadowCameraFov: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
            ),
              (this.shadow.camera.fov = t);
          },
        },
        shadowCameraLeft: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
            ),
              (this.shadow.camera.left = t);
          },
        },
        shadowCameraRight: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
            ),
              (this.shadow.camera.right = t);
          },
        },
        shadowCameraTop: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
            ),
              (this.shadow.camera.top = t);
          },
        },
        shadowCameraBottom: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
            ),
              (this.shadow.camera.bottom = t);
          },
        },
        shadowCameraNear: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
            ),
              (this.shadow.camera.near = t);
          },
        },
        shadowCameraFar: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
            ),
              (this.shadow.camera.far = t);
          },
        },
        shadowCameraVisible: {
          set: function () {
            console.warn(
              "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
            );
          },
        },
        shadowBias: {
          set: function (t) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
              (this.shadow.bias = t);
          },
        },
        shadowDarkness: {
          set: function () {
            console.warn("THREE.Light: .shadowDarkness has been removed.");
          },
        },
        shadowMapWidth: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
            ),
              (this.shadow.mapSize.width = t);
          },
        },
        shadowMapHeight: {
          set: function (t) {
            console.warn(
              "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
            ),
              (this.shadow.mapSize.height = t);
          },
        },
      }),
      Object.defineProperties(ht.prototype, {
        length: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
              ),
              this.array.length
            );
          },
        },
      }),
      Object.assign(Mt.prototype, {
        addIndex: function (t) {
          console.warn(
            "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
          ),
            this.setIndex(t);
        },
        addDrawCall: function (t, e, n) {
          void 0 !== n &&
            console.warn(
              "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
            ),
            console.warn(
              "THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
            ),
            this.addGroup(t, e);
        },
        clearDrawCalls: function () {
          console.warn(
            "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
          ),
            this.clearGroups();
        },
        computeTangents: function () {
          console.warn(
            "THREE.BufferGeometry: .computeTangents() has been removed."
          );
        },
        computeOffsets: function () {
          console.warn(
            "THREE.BufferGeometry: .computeOffsets() has been removed."
          );
        },
      }),
      Object.defineProperties(Mt.prototype, {
        drawcalls: {
          get: function () {
            return (
              console.error(
                "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
              ),
              this.groups
            );
          },
        },
        offsets: {
          get: function () {
            return (
              console.warn(
                "THREE.BufferGeometry: .offsets has been renamed to .groups."
              ),
              this.groups
            );
          },
        },
      }),
      Object.defineProperties(bi.prototype, {
        dynamic: {
          set: function () {
            console.warn(
              "THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead."
            );
          },
        },
        onUpdate: {
          value: function () {
            return (
              console.warn(
                "THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
              ),
              this
            );
          },
        },
      }),
      Object.defineProperties(Z.prototype, {
        wrapAround: {
          get: function () {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
          set: function () {
            console.warn("THREE.Material: .wrapAround has been removed.");
          },
        },
        wrapRGB: {
          get: function () {
            return (
              console.warn("THREE.Material: .wrapRGB has been removed."),
              new W()
            );
          },
        },
        shading: {
          get: function () {
            console.error(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            );
          },
          set: function (t) {
            console.warn(
              "THREE." +
                this.type +
                ": .shading has been removed. Use the boolean .flatShading instead."
            ),
              (this.flatShading = 1 === t);
          },
        },
      }),
      Object.defineProperties(on.prototype, {
        metal: {
          get: function () {
            return (
              console.warn(
                "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."
              ),
              !1
            );
          },
          set: function () {
            console.warn(
              "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead"
            );
          },
        },
      }),
      Object.defineProperties(Rt.prototype, {
        derivatives: {
          get: function () {
            return (
              console.warn(
                "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
              ),
              this.extensions.derivatives
            );
          },
          set: function (t) {
            console.warn(
              "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
            ),
              (this.extensions.derivatives = t);
          },
        },
      }),
      Object.assign($t.prototype, {
        getCurrentRenderTarget: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
            ),
            this.getRenderTarget()
          );
        },
        getMaxAnisotropy: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
            ),
            this.capabilities.getMaxAnisotropy()
          );
        },
        getPrecision: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
            ),
            this.capabilities.precision
          );
        },
        resetGLState: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
            ),
            this.state.reset()
          );
        },
        supportsFloatTextures: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
            ),
            this.extensions.get("OES_texture_float")
          );
        },
        supportsHalfFloatTextures: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
            ),
            this.extensions.get("OES_texture_half_float")
          );
        },
        supportsStandardDerivatives: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
            ),
            this.extensions.get("OES_standard_derivatives")
          );
        },
        supportsCompressedTextureS3TC: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
            ),
            this.extensions.get("WEBGL_compressed_texture_s3tc")
          );
        },
        supportsCompressedTexturePVRTC: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
            ),
            this.extensions.get("WEBGL_compressed_texture_pvrtc")
          );
        },
        supportsBlendMinMax: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
            ),
            this.extensions.get("EXT_blend_minmax")
          );
        },
        supportsVertexTextures: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
            ),
            this.capabilities.vertexTextures
          );
        },
        supportsInstancedArrays: function () {
          return (
            console.warn(
              "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
            ),
            this.extensions.get("ANGLE_instanced_arrays")
          );
        },
        enableScissorTest: function (t) {
          console.warn(
            "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
          ),
            this.setScissorTest(t);
        },
        initMaterial: function () {
          console.warn(
            "THREE.WebGLRenderer: .initMaterial() has been removed."
          );
        },
        addPrePlugin: function () {
          console.warn(
            "THREE.WebGLRenderer: .addPrePlugin() has been removed."
          );
        },
        addPostPlugin: function () {
          console.warn(
            "THREE.WebGLRenderer: .addPostPlugin() has been removed."
          );
        },
        updateShadowMap: function () {
          console.warn(
            "THREE.WebGLRenderer: .updateShadowMap() has been removed."
          );
        },
      }),
      Object.defineProperties($t.prototype, {
        shadowMapEnabled: {
          get: function () {
            return this.shadowMap.enabled;
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
            ),
              (this.shadowMap.enabled = t);
          },
        },
        shadowMapType: {
          get: function () {
            return this.shadowMap.type;
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
            ),
              (this.shadowMap.type = t);
          },
        },
        shadowMapCullFace: {
          get: function () {
            return this.shadowMap.cullFace;
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace."
            ),
              (this.shadowMap.cullFace = t);
          },
        },
      }),
      Object.defineProperties(it.prototype, {
        cullFace: {
          get: function () {
            return this.renderReverseSided ? cr : sr;
          },
          set: function (t) {
            var e = t !== sr;
            console.warn(
              "WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " +
                e +
                "."
            ),
              (this.renderReverseSided = e);
          },
        },
      }),
      Object.defineProperties(l.prototype, {
        wrapS: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
              ),
              this.texture.wrapS
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
            ),
              (this.texture.wrapS = t);
          },
        },
        wrapT: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
              ),
              this.texture.wrapT
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
            ),
              (this.texture.wrapT = t);
          },
        },
        magFilter: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
              ),
              this.texture.magFilter
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
            ),
              (this.texture.magFilter = t);
          },
        },
        minFilter: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
              ),
              this.texture.minFilter
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
            ),
              (this.texture.minFilter = t);
          },
        },
        anisotropy: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
              ),
              this.texture.anisotropy
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
            ),
              (this.texture.anisotropy = t);
          },
        },
        offset: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .offset is now .texture.offset."
              ),
              this.texture.offset
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .offset is now .texture.offset."
            ),
              (this.texture.offset = t);
          },
        },
        repeat: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
              ),
              this.texture.repeat
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
            ),
              (this.texture.repeat = t);
          },
        },
        format: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .format is now .texture.format."
              ),
              this.texture.format
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .format is now .texture.format."
            ),
              (this.texture.format = t);
          },
        },
        type: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .type is now .texture.type."
              ),
              this.texture.type
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .type is now .texture.type."
            ),
              (this.texture.type = t);
          },
        },
        generateMipmaps: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
              ),
              this.texture.generateMipmaps
            );
          },
          set: function (t) {
            console.warn(
              "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
            ),
              (this.texture.generateMipmaps = t);
          },
        },
      }),
      (hi.prototype.load = function (t) {
        console.warn(
          "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
        );
        var e = this;
        return (
          new si().load(t, function (t) {
            e.setBuffer(t);
          }),
          this
        );
      }),
      (di.prototype.getData = function () {
        return (
          console.warn(
            "THREE.AudioAnalyser: .getData() is now .getFrequencyData()."
          ),
          this.getFrequencyData()
        );
      }),
      (li.prototype.updateCubeMap = function (t, e) {
        return (
          console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
          this.update(t, e)
        );
      });
    (t.WebGLRenderTarget = l),
      (t.WebGLRenderer = $t),
      (t.ShaderLib = ba),
      (t.UniformsUtils = ya),
      (t.Scene = Qt),
      (t.Mesh = It),
      (t.TextureLoader = gn),
      (t.PointLight = wn),
      (t.PerspectiveCamera = Xt),
      (t.OrthographicCamera = ct),
      (t.Object3D = at),
      (t.Vector3 = o),
      (t.Vector2 = n),
      (t.Quaternion = r),
      (t.PlaneBufferGeometry = At),
      (t.RawShaderMaterial = en),
      (t.ShaderMaterial = Rt),
      (t.MeshStandardMaterial = nn),
      (t.DoubleSide = fr),
      (t.EquirectangularReflectionMapping = ro),
      (t.ClampToEdgeWrapping = uo),
      (t.NearestFilter = po),
      (t.FloatType = To),
      (t.HalfFloatType = So),
      (t.RGBAFormat = Io),
      Object.defineProperty(t, "__esModule", { value: !0 });
  }),
    (U = U.exports);
  var N = { left: 0, top: 0 },
    z = function (t, e) {
      e || (e = [0, ""]), (t = String(t));
      var n = parseFloat(t, 10);
      return (e[0] = n), (e[1] = t.match(/[\d.\-\+]*\s*(.*)/)[1] || ""), e;
    },
    k = f,
    F = 96,
    B = {};
  Object.defineProperty(B, "__esModule", { value: !0 });
  var H = (function () {
      function t(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          (i.enumerable = i.enumerable || !1),
            (i.configurable = !0),
            "value" in i && (i.writable = !0),
            Object.defineProperty(t, i.key, i);
        }
      }
      return function (e, n, i) {
        return n && t(e.prototype, n), i && t(e, i), e;
      };
    })(),
    j = m(function (t, e, n) {
      (e = e || t.currentTarget || t.srcElement),
        Array.isArray(n) || (n = [0, 0]);
      var i = t.clientX || 0,
        r = t.clientY || 0,
        o = (function (t) {
          return t === window || t === document || t === document.body
            ? N
            : t.getBoundingClientRect();
        })(e);
      return (n[0] = i - o.left), (n[1] = r - o.top), n;
    }),
    G = m(function (t, e, n) {
      "function" == typeof t && ((n = !!e), (e = t), (t = window));
      var i = k("ex", t),
        r = function (t) {
          n && t.preventDefault();
          var r = t.deltaX || 0,
            o = t.deltaY || 0,
            a = t.deltaZ || 0,
            s = 1;
          switch (t.deltaMode) {
            case 1:
              s = i;
              break;
            case 2:
              s = window.innerHeight;
          }
          if (((r *= s), (o *= s), (a *= s), r || o || a)) return e(r, o, a, t);
        };
      return t.addEventListener("wheel", r), r;
    }),
    V = m(function (t, e, n) {
      return e < n ? (t < e ? e : t > n ? n : t) : t < n ? n : t > e ? e : t;
    }),
    W = new U.Vector3(0, 1, 0),
    X = (function () {
      function t(e) {
        var n =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        !(function (e, n) {
          if (!(e instanceof t))
            throw new TypeError("Cannot call a class as a function");
        })(this),
          (this.onInputDown = this.onInputDown.bind(this)),
          (this.onInputMove = this.onInputMove.bind(this)),
          (this.onInputUp = this.onInputUp.bind(this)),
          (this.handleZoom = this.handleZoom.bind(this)),
          (this.preventDefault = this.preventDefault.bind(this)),
          (this.update = this.update.bind(this)),
          (this.object = e),
          (this.inputDelta = new U.Vector3()),
          (this.offset = new U.Vector3()),
          (this.upQuat = new U.Quaternion()),
          (this.upQuatInverse = new U.Quaternion()),
          (this.enabled = !0),
          (this.target = n.target || new U.Vector3()),
          (this.distance = n.distance || 1),
          (this.damping = n.damping || 0.25),
          (this.rotateSpeed = n.rotateSpeed || 0.28),
          (this.zoomSpeed = n.zoomSpeed || 0.0075),
          (this.rotate = !1 !== n.rotate),
          (this.zoom = !1 !== n.zoom),
          (this._theta = n.theta || 0),
          (this._phi = n.phi || 0.5 * Math.PI),
          (this.phiBounds = n.phiBounds || [0, Math.PI]),
          (this.thetaBounds = n.thetaBounds || [-1 / 0, 1 / 0]),
          (this.distanceBounds = n.distanceBounds || [1, 1 / 0]),
          (this.parent = n.parent || window),
          (this.element = n.element),
          this.pinchHandler,
          (this.mouseStart = new U.Vector2()),
          (this.clientSize = new U.Vector2()),
          (this.tmp = [0, 0]),
          (this.dragging = !1),
          this.addEvents(),
          this.rotateTo(this._theta, this._phi);
      }
      return (
        H(t, [
          {
            key: "dispose",
            value: function () {
              this.removeEvents();
            },
          },
          {
            key: "reset",
            value: function () {
              (this.inputDelta = new U.Vector3()),
                (this.mouseStart = new U.Vector2()),
                (this.theta = 0),
                (this.phi = 0.5 * Math.PI);
            },
          },
          {
            key: "addEvents",
            value: function () {
              this.rotate &&
                (this.parent.addEventListener("mousedown", this.onInputDown),
                this.parent.addEventListener("mousemove", this.onInputMove),
                this.parent.addEventListener("mouseup", this.onInputUp)),
                this.zoom && (0, G.default)(window, this.handleZoom, !0);
            },
          },
          {
            key: "removeEvents",
            value: function () {
              this.parent.removeEventListener("mousedown", this.onInputDown),
                this.parent.removeEventListener("mousemove", this.onInputMove),
                this.parent.removeEventListener("mouseup", this.onInputUp);
            },
          },
          {
            key: "preventDefault",
            value: function (t) {
              t.preventDefault();
            },
          },
          {
            key: "onInputDown",
            value: function (t) {
              if (this.enabled) {
                var e = (0, j.default)(t, this.element);
                this.mouseStart.set(e[0], e[1]),
                  this.insideBounds(this.mouseStart) && (this.dragging = !0);
              }
            },
          },
          {
            key: "onInputUp",
            value: function () {
              this.enabled && (this.dragging = !1);
            },
          },
          {
            key: "onInputMove",
            value: function (t) {
              if (this.enabled) {
                var e = (0, j.default)(t, this.element);
                if (this.dragging) {
                  var n = this.getClientSize(),
                    i = (e[0] - this.mouseStart.x) / n.x,
                    r = (e[1] - this.mouseStart.y) / n.y;
                  this.handleRotate(i, r), this.mouseStart.set(e[0], e[1]);
                }
              }
            },
          },
          {
            key: "insideBounds",
            value: function (t) {
              if (
                this.element === window ||
                this.element === document ||
                this.element === document.body
              )
                return !0;
              var e = this.element.getBoundingClientRect();
              return t.x >= 0 && t.y >= 0 && t.x < e.width && t.y < e.height;
            },
          },
          {
            key: "getClientSize",
            value: function () {
              var t = this.element;
              return (
                (t !== window && t !== document && t !== document.body) ||
                  (t = document.documentElement),
                this.clientSize.set(t.clientWidth, t.clientHeight)
              );
            },
          },
          {
            key: "handleRotate",
            value: function (t, e) {
              var n = 2 * Math.PI;
              (this.inputDelta.x -= n * t * this.rotateSpeed),
                (this.inputDelta.y -= n * e * this.rotateSpeed);
            },
          },
          {
            key: "handleZoom",
            value: function (t, e) {
              this.inputDelta.z += e * this.zoomSpeed;
            },
          },
          {
            key: "rotateTo",
            value: function (t, e) {
              this._prepareOffset(),
                (this.theta = t),
                (this.phi = e),
                this._computeOffset(),
                this._applyTransformation();
            },
          },
          {
            key: "_prepareOffset",
            value: function () {
              this.upQuat.setFromUnitVectors(this.object.up, W),
                this.upQuatInverse.copy(this.upQuat).inverse(),
                this.offset.subVectors(this.object.position, this.target),
                this.offset.applyQuaternion(this.upQuat);
            },
          },
          {
            key: "_computeOffset",
            value: function () {
              var t = Math.abs(this.distance) <= 1e-10 ? 1e-10 : this.distance;
              (this.offset.x = t * Math.sin(this.phi) * Math.sin(this.theta)),
                (this.offset.y = t * Math.cos(this.phi)),
                (this.offset.z = t * Math.sin(this.phi) * Math.cos(this.theta));
            },
          },
          {
            key: "_applyTransformation",
            value: function () {
              this.offset.applyQuaternion(this.upQuatInverse),
                this.object.position.addVectors(this.target, this.offset),
                this.object.lookAt(this.target);
            },
          },
          {
            key: "_applyDamping",
            value: function () {
              var t = "number" == typeof this.damping ? this.damping : 1;
              (this.inputDelta.x *= 1 - t),
                (this.inputDelta.y *= 1 - t),
                (this.inputDelta.z *= 1 - t);
            },
          },
          {
            key: "update",
            value: function () {
              this._prepareOffset();
              var t = Math.atan2(this.offset.x, this.offset.z),
                e = Math.atan2(
                  Math.sqrt(
                    this.offset.x * this.offset.x +
                      this.offset.z * this.offset.z
                  ),
                  this.offset.y
                );
              (t += this.inputDelta.x),
                (e += this.inputDelta.y),
                (this.theta = t),
                (this.phi = e),
                (this.distance += this.inputDelta.z),
                (this.distance = (0, V.default)(
                  this.distance,
                  this.distanceBounds[0],
                  this.distanceBounds[1]
                )),
                this._computeOffset(),
                this._applyTransformation(),
                this._applyDamping();
            },
          },
          {
            key: "theta",
            get: function () {
              return this._theta;
            },
            set: function (t) {
              this._theta = (0, V.default)(
                t,
                this.thetaBounds[0],
                this.thetaBounds[1]
              );
            },
          },
          {
            key: "phi",
            get: function () {
              return this._phi;
            },
            set: function (t) {
              (this._phi = (0, V.default)(
                t,
                this.phiBounds[0],
                this.phiBounds[1]
              )),
                (this._phi = (0, V.default)(this._phi, 1e-10, Math.PI - 1e-10));
            },
          },
        ]),
        t
      );
    })();
  B.default = X;
  var Y = {};
  Object.defineProperty(Y, "__esModule", { value: !0 });
  var q = (function (t) {
    function e() {
      var t =
          arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
        n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      !(function (t, n) {
        if (!(t instanceof e))
          throw new TypeError("Cannot call a class as a function");
      })(this);
      var i = (function (t, e) {
        if (!t)
          throw new ReferenceError(
            "this hasn't been initialised - super() hasn't been called"
          );
        return !e || ("object" != typeof e && "function" != typeof e) ? t : e;
      })(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
      return (
        (i.uniforms = Object.assign(
          U.UniformsUtils.clone(U.ShaderLib.standard.uniforms),
          {
            heightMap: { type: "t", value: n.heightMap },
            amplitude: { type: "f", value: 0 },
          }
        )),
        (i.vertexShader =
          "#define GLSLIFY 1\n#define PHYSICAL\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nuniform sampler2D heightMap;\nuniform float amplitude;\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n#endif\n\n\t#include <begin_vertex>\n\n\tfloat height = texture2D(heightMap, vUv).r;\n\ttransformed.z += height * amplitude;\n\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}"),
        (i.fragmentShader =
          "#define GLSLIFY 1\n#define PHYSICAL\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}"),
        (i.type = "MeshCustomMaterial"),
        (i.isMeshStandardMaterial = !0),
        i.setValues(t),
        i
      );
    }
    return (
      (function (t, e) {
        if ("function" != typeof e && null !== e)
          throw new TypeError(
            "Super expression must either be null or a function, not " +
              typeof e
          );
        (t.prototype = Object.create(e && e.prototype, {
          constructor: {
            value: t,
            enumerable: !1,
            writable: !0,
            configurable: !0,
          },
        })),
          e &&
            (Object.setPrototypeOf
              ? Object.setPrototypeOf(t, e)
              : (t.__proto__ = e));
      })(e, U.MeshStandardMaterial),
      e
    );
  })();
  Y.default = q;
  var $ = {};
  Object.defineProperty($, "__esModule", { value: !0 });
  var Z = (function () {
      function t(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          (i.enumerable = i.enumerable || !1),
            (i.configurable = !0),
            "value" in i && (i.writable = !0),
            Object.defineProperty(t, i.key, i);
        }
      }
      return function (e, n, i) {
        return n && t(e.prototype, n), i && t(e, i), e;
      };
    })(),
    J = (function () {
      function t(e, n) {
        var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        !(function (e, n) {
          if (!(e instanceof t))
            throw new TypeError("Cannot call a class as a function");
        })(this);
        var r = {
          wrapS: U.ClampToEdgeWrapping,
          wrapT: U.ClampToEdgeWrapping,
          minFilter: U.NearestFilter,
          magFilter: U.NearestFilter,
          format: U.RGBAFormat,
          type: i ? U.HalfFloatType : U.FloatType,
          stencilBuffer: !1,
          depthBuffer: !1,
          generateMipmaps: !1,
        };
        (this.renderTarget = new U.WebGLRenderTarget(e, n, r)),
          (this.scene = new U.Scene()),
          (this.camera = new U.OrthographicCamera(
            -0.5,
            0.5,
            0.5,
            -0.5,
            1 / Math.pow(2, 53),
            1e3
          ));
      }
      return (
        Z(t, [
          {
            key: "createSimulationFromShaders",
            value: function (t, e, n) {
              var i =
                  arguments.length > 3 &&
                  void 0 !== arguments[3] &&
                  arguments[3],
                r =
                  (i ? U.ShaderMaterial : U.RawShaderMaterial,
                  { vertexShader: t, fragmentShader: e, uniforms: n }),
                o = i ? new U.RawShaderMaterial(r) : new U.ShaderMaterial(r);
              this.setSimulation(o);
            },
          },
          {
            key: "setSimulation",
            value: function (t) {
              (this.simulation = t),
                (this.simulationMesh = new U.Mesh(
                  new U.PlaneBufferGeometry(1, 1),
                  this.simulation
                )),
                this.scene.add(this.simulationMesh);
            },
          },
          {
            key: "dispose",
            value: function () {
              this.simulationMesh.geometry.dispose(),
                this.renderTarget.dispose();
            },
          },
          {
            key: "update",
            value: function (t) {
              t.render(this.scene, this.camera, this.renderTarget, !0);
            },
          },
          {
            key: "texture",
            get: function () {
              return this.renderTarget.texture;
            },
          },
        ]),
        t
      );
    })();
  $.default = J;
  var Q = {};
  Object.defineProperty(Q, "__esModule", { value: !0 });
  var K = (function () {
      function t(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          (i.enumerable = i.enumerable || !1),
            (i.configurable = !0),
            "value" in i && (i.writable = !0),
            Object.defineProperty(t, i.key, i);
        }
      }
      return function (e, n, i) {
        return n && t(e.prototype, n), i && t(e, i), e;
      };
    })(),
    tt = g(Y),
    et = g($),
    nt =
      (g(x),
      (function (t) {
        function e() {
          !(function (t, n) {
            if (!(t instanceof e))
              throw new TypeError("Cannot call a class as a function");
          })(this);
          var t = (function (t, e) {
            if (!t)
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              );
            return !e || ("object" != typeof e && "function" != typeof e)
              ? t
              : e;
          })(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
          (t._strength = 5),
            (t._level = 4),
            (t.fboDisplacement = new et.default(1024, 1024)),
            t.fboDisplacement.createSimulationFromShaders(
              "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n",
              "#define GLSLIFY 1\nuniform float uTime;\nuniform float\tuAmplitude;\nuniform float\toffset;\nuniform float\ttotal;\nuniform int\tnoiseType;\n\nvarying vec2 vUv;\n\nfloat wave(float period) {\n\treturn sin(period * 6.283185);\n}\n\n// calculate displacement based on uv coordinate\nfloat displace(vec2 uv) {\n\t// large up and down movement\n\tfloat d = wave((uv.x * 0.5) - uTime * 0.01);\n\t// add a large wave from left to right\n\td -= 1.2 * wave((uv.x * 0.9) - uTime * 0.04);\n\t// add diagonal waves from back to front\n\td -= 0.25 * wave(((uv.x + uv.y) * 2.2) - uTime * 0.05);\n\t// add additional waves for increased complexity\n\td += 0.25 * wave((uv.y * 1.2) - uTime * 0.01);\n\td -= 0.15 * wave(((uv.y + uv.x) * 2.8) - uTime * 0.09);\n\td += 0.15 * wave(((uv.y - uv.x) * 1.9) - uTime * 0.08);\n\n\treturn d;\n}\n\n/* -------------------------------------------------------------------------- */\n/* -------------------------------------------------------------------------- */\nconst int noiseSwirlSteps = 2;\nconst float noiseSwirlValue = 1.;\nconst float noiseSwirlStepValue = noiseSwirlValue / float(noiseSwirlSteps);\n\nconst float noiseScale = 2.;\nconst float noiseTimeScale = 0.01;\n\nfloat simplex(vec3 v);\nfloat getNoise(vec3 v);\n\nfloat fbm3(vec3 v) {\n    float result = simplex(v);\n    result += simplex(v * 2.) / 2.;\n    result += simplex(v * 4.) / 4.;\n    result /= (1. + 1./2. + 1./4.);\n    return result;\n}\n\nfloat fbm5(vec3 v) {\n    float result = simplex(v);\n    result += simplex(v * 2.) / 2.;\n    result += simplex(v * 4.) / 4.;\n    result += simplex(v * 8.) / 8.;\n    result += simplex(v * 16.) / 16.;\n    result /= (1. + 1./2. + 1./4. + 1./8. + 1./16.);\n    return result;\n}\n\nfloat getNoise(vec3 v) {\n    //  make it curl\n    for (int i=0; i<noiseSwirlSteps; i++) {\n    \tv.xy += vec2(fbm3(v), fbm3(vec3(v.xy, v.z + 1000.))) * noiseSwirlStepValue;\n    }\n    //  normalize\n    return fbm5(v) / 2. + 0.5;\n}\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat simplex(vec3 v) {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\t// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n\t// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n\t// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z); \n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ ); \n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n\t//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n\t// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n/* -------------------------------------------------------------------------- */\n/* -------------------------------------------------------------------------- */\n\nvoid main() {\n\tif (noiseType == 0) {\n\t\tfloat d = uAmplitude * displace(vUv);\n\t\td = d + offset / total;\n\t\tgl_FragColor = vec4(d, d, d, 1.0);\n\t} else {\n\t\tfloat noise = getNoise(vec3(vUv * noiseScale, uTime * noiseTimeScale));\n\t\tnoise = noise * noise * noise * noise * 2.0;\n\t\tgl_FragColor = vec4(vec3(noise), 1.0);\n\t}\n\t\n}",
              {
                uTime: { type: "f", value: 0 },
                uAmplitude: { type: "f", value: 1 },
                offset: { type: "f", value: 3 },
                total: { type: "f", value: 1 },
                noiseType: { type: "i", value: 0 },
              }
            ),
            (t.fboNormal = new et.default(1024, 1024)),
            t.fboNormal.createSimulationFromShaders(
              "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  vUv = vec2(uv.x, uv.y);\n}",
              "#define GLSLIFY 1\n/*\n  FROM https://github.com/cpetry/NormalMap-Online\n*/\n\nuniform vec3 dimensions;\nuniform float dz;\nuniform float invertR;\nuniform float invertG;\nuniform float invertH;\nuniform int type;\nuniform sampler2D uDisplacement;\n\nvarying vec2 vUv;\n        \nvoid main(void) {\n  vec2 step = vec2(-1.0 / dimensions.x, -1.0 / dimensions.y); // - to switch from glsl orientation to my orientation :D\n\n  vec2 tlv = vec2(vUv.x - step.x, vUv.y + step.y ); \n  vec2 lv  = vec2(vUv.x - step.x, vUv.y \t\t   );\n  vec2 blv = vec2(vUv.x - step.x, vUv.y - step.y);\t\n  vec2 tv  = vec2(vUv.x \t\t  , vUv.y + step.y ); \n  vec2 bv  = vec2(vUv.x \t\t  , vUv.y - step.y);\n  vec2 trv = vec2(vUv.x + step.x, vUv.y + step.y ); \n  vec2 rv  = vec2(vUv.x + step.x, vUv.y \t\t   );\n  vec2 brv = vec2(vUv.x + step.x, vUv.y - step.y);\n\n  tlv = vec2(tlv.x >= 0.0 ? tlv.x : (1.0 + tlv.x), \ttlv.y >= 0.0\t? tlv.y : (1.0  + tlv.y));\n  tlv = vec2(tlv.x < 1.0  ? tlv.x : (tlv.x - 1.0 ), \ttlv.y < 1.0   \t? tlv.y : (tlv.y - 1.0 ));\n  lv  = vec2( lv.x >= 0.0 ?  lv.x : (1.0 + lv.x),  \tlv.y  >= 0.0 \t?  lv.y : (1.0  +  lv.y));\n  lv  = vec2( lv.x < 1.0  ?  lv.x : ( lv.x - 1.0 ),   lv.y  < 1.0  \t?  lv.y : ( lv.y - 1.0 ));\n  blv = vec2(blv.x >= 0.0 ? blv.x : (1.0 + blv.x), \tblv.y >= 0.0 \t? blv.y : (1.0  + blv.y));\n  blv = vec2(blv.x < 1.0  ? blv.x : (blv.x - 1.0 ), \tblv.y < 1.0 \t? blv.y : (blv.y - 1.0 ));\n  tv  = vec2( tv.x >= 0.0 ?  tv.x : (1.0 + tv.x),  \ttv.y  >= 0.0 \t?  tv.y : (1.0  +  tv.y));\n  tv  = vec2( tv.x < 1.0  ?  tv.x : ( tv.x - 1.0 ),   tv.y  < 1.0 \t?  tv.y : ( tv.y - 1.0 ));\n  bv  = vec2( bv.x >= 0.0 ?  bv.x : (1.0 + bv.x),  \tbv.y  >= 0.0 \t?  bv.y : (1.0  +  bv.y));\n  bv  = vec2( bv.x < 1.0  ?  bv.x : ( bv.x - 1.0 ),   bv.y  < 1.0 \t?  bv.y : ( bv.y - 1.0 ));\n  trv = vec2(trv.x >= 0.0 ? trv.x : (1.0 + trv.x), \ttrv.y >= 0.0 \t? trv.y : (1.0  + trv.y));\n  trv = vec2(trv.x < 1.0  ? trv.x : (trv.x - 1.0 ), \ttrv.y < 1.0   \t? trv.y : (trv.y - 1.0 ));\n  rv  = vec2( rv.x >= 0.0 ?  rv.x : (1.0 + rv.x),  \trv.y  >= 0.0 \t?  rv.y : (1.0  +  rv.y));\n  rv  = vec2( rv.x < 1.0  ?  rv.x : ( rv.x - 1.0 ),   rv.y  < 1.0   \t?  rv.y : ( rv.y - 1.0 ));\n  brv = vec2(brv.x >= 0.0 ? brv.x : (1.0 + brv.x), \tbrv.y >= 0.0 \t? brv.y : (1.0  + brv.y));\n  brv = vec2(brv.x < 1.0  ? brv.x : (brv.x - 1.0 ), \tbrv.y < 1.0   \t? brv.y : (brv.y - 1.0 ));\n\n  float tl = abs(texture2D(uDisplacement, tlv).r); \n  float l  = abs(texture2D(uDisplacement, lv ).r);\n  float bl = abs(texture2D(uDisplacement, blv).r);\t\n  float t  = abs(texture2D(uDisplacement, tv ).r); \n  float b  = abs(texture2D(uDisplacement, bv ).r);\n  float tr = abs(texture2D(uDisplacement, trv).r); \n  float r  = abs(texture2D(uDisplacement, rv ).r);\n  float br = abs(texture2D(uDisplacement, brv).r);\n\n  float dx = 0.0, dy = 0.0;\n  if (type == 0) { // Sobel\n    dx = tl + l*2.0 + bl - tr - r*2.0 - br;\n    dy = tl + t*2.0 + tr - bl - b*2.0 - br;\n  } else { // Scharr\n    dx = tl*3.0 + l*10.0 + bl*3.0 - tr*3.0 - r*10.0 - br*3.0;\n    dy = tl*3.0 + t*10.0 + tr*3.0 - bl*3.0 - b*10.0 - br*3.0;\n  }\n  vec4 normal = vec4(normalize(vec3(dx * invertR * invertH * 255.0, dy * invertG * invertH * 255.0, dz)), texture2D(uDisplacement, vUv).a);\n  gl_FragColor = vec4(normal.xy * 0.5 + 0.5, normal.zw);\n}",
              {
                uDisplacement: { type: "t", value: t.fboDisplacement.texture },
                uAmplitude: { type: "f", value: 1e3 },
                uResolution: { type: "v2", value: new U.Vector2(1024, 1024) },
                type: { type: "1i", value: 0 },
                invertR: { type: "1f", value: 1 },
                invertG: { type: "1f", value: 1 },
                invertH: { type: "1f", value: 1 },
                dz: {
                  type: "1f",
                  value: (1 / t._strength) * (1 + Math.pow(2, t._level)),
                },
                dimensions: { type: "fv", value: [1024, 1024, 0] },
              }
            ),
            (t.fboNormal.simulation.extensions.derivatives = !0);
          var n = new U.TextureLoader(),
            i = n.load("assets/tex.jpg"),
            r = n.load("assets/env.jpg");
          r.mapping = U.EquirectangularReflectionMapping;
          var o = new U.PlaneBufferGeometry(1024, 1024, 1024, 1024);
          t.material = new tt.default(
            {
              roughness: 0.5,
              metalness: 0.5,
              map: i,
              normalMap: t.fboNormal.texture,
              envMap: r,
              envMapIntensity: 1,
              side: U.DoubleSide,
            },
            { heightMap: t.fboDisplacement.texture }
          );
          var a = new U.Mesh(o, t.material);
          return (t.amplitude = 100), t.add(a), t; //default ampli
        }
        return (
          (function (t, e) {
            if ("function" != typeof e && null !== e)
              throw new TypeError(
                "Super expression must either be null or a function, not " +
                  typeof e
              );
            (t.prototype = Object.create(e && e.prototype, {
              constructor: {
                value: t,
                enumerable: !1,
                writable: !0,
                configurable: !0,
              },
            })),
              e &&
                (Object.setPrototypeOf
                  ? Object.setPrototypeOf(t, e)
                  : (t.__proto__ = e));
          })(e, U.Object3D),
          K(e, [
            {
              key: "computeDZ",
              value: function () {
                this.fboNormal.simulation.uniforms.dz.value =
                  (1 / this._strength) * (1 + Math.pow(2, this._level));
              },
            },
            {
              key: "update",
              value: function (t, e) {
                (this.fboDisplacement.simulation.uniforms.uTime.value +=
                  0.01 * e),
                  this.fboDisplacement.update(t),
                  this.fboNormal.update(t);
              },
            },
            {
              key: "strength",
              get: function () {
                return this._strength;
              },
              set: function (t) {
                (this._strength = t), this.computeDZ();
              },
            },
            {
              key: "level",
              get: function () {
                return this._level;
              },
              set: function (t) {
                (this._level = t), this.computeDZ();
              },
            },
            {
              key: "amplitude",
              get: function () {
                return this.material.uniforms.amplitude.value;
              },
              set: function (t) {
                this.material.uniforms.amplitude.value = t;
              },
            },
            {
              key: "offset",
              get: function () {
                return this.fboDisplacement.simulation.uniforms.offset.value;
              },
              set: function (t) {
                this.fboDisplacement.simulation.uniforms.offset.value = t;
              },
            },
            {
              key: "total",
              get: function () {
                return this.fboDisplacement.simulation.uniforms.total.value;
              },
              set: function (t) {
                this.fboDisplacement.simulation.uniforms.total.value = t;
              },
            },
            {
              key: "isSobel",
              get: function () {
                return 0 === this.fboNormal.simulation.uniforms.type.value;
              },
              set: function (t) {
                this.fboNormal.simulation.uniforms.type.value = t ? 0 : 1;
              },
            },
            {
              key: "isFBM",
              get: function () {
                return (
                  1 === this.fboDisplacement.simulation.uniforms.noiseType.value
                );
              },
              set: function (t) {
                this.fboDisplacement.simulation.uniforms.noiseType.value = t
                  ? 1
                  : 0;
              },
            },
          ]),
          e
        );
      })());
  Q.default = nt;
  var it = (function (t) {
      function e(i) {
        if (n[i]) return n[i].exports;
        var r = (n[i] = { i: i, l: !1, exports: {} });
        return t[i].call(r.exports, r, r.exports, e), (r.l = !0), r.exports;
      }
      var n = {};
      return (
        (e.m = t),
        (e.c = n),
        (e.i = function (t) {
          return t;
        }),
        (e.d = function (t, n, i) {
          e.o(t, n) ||
            Object.defineProperty(t, n, {
              configurable: !1,
              enumerable: !0,
              get: i,
            });
        }),
        (e.n = function (t) {
          var n =
            t && t.__esModule
              ? function () {
                  return t.default;
                }
              : function () {
                  return t;
                };
          return e.d(n, "a", n), n;
        }),
        (e.o = function (t, e) {
          return Object.prototype.hasOwnProperty.call(t, e);
        }),
        (e.p = ""),
        e((e.s = 50))
      );
    })([
      function (t, e, n) {
        "use strict";
        function i(t) {
          for (
            var e = arguments.length, n = Array(e > 1 ? e - 1 : 0), i = 1;
            i < e;
            i++
          )
            n[i - 1] = arguments[i];
          n.forEach(function (e) {
            return r(t, e);
          });
        }
        function r(t, e) {
          o(t, e) ||
            (t.classList ? t.classList.add(e) : (t.className += " " + e));
        }
        function o(t, e) {
          return t.classList
            ? t.classList.contains(e)
            : new RegExp("(^| )" + e + "( |$)", "gi").test(t.className);
        }
        function a(t, e) {
          o(t, e) &&
            (t.classList
              ? t.classList.remove(e)
              : (t.className = t.className.replace(
                  new RegExp(
                    "(^|\\b)" + e.split(" ").join("|") + "(\\b|$)",
                    "gi"
                  ),
                  " "
                )));
        }
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.createElement = function (t) {
            for (
              var e = document.createElement(t),
                n = arguments.length,
                r = Array(n > 1 ? n - 1 : 0),
                o = 1;
              o < n;
              o++
            )
              r[o - 1] = arguments[o];
            return i.apply(void 0, [e].concat(r)), e;
          }),
          (e.appendElement = function (t) {
            (arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : document.body
            ).appendChild(t);
          }),
          (e.offset = function (t) {
            var e = { left: 0, top: 0 };
            if (t.offsetParent)
              do {
                (e.left += t.offsetLeft), (e.top += t.offsetTop);
              } while ((t = t.offsetParent));
            return e;
          }),
          (e.addClasses = i),
          (e.addClass = r),
          (e.hasClass = o),
          (e.removeClass = a),
          (e.toggleClass = function (t, e) {
            o(t, e) ? a(t, e) : r(t, e);
          });
      },
      function (t, e) {
        t.exports = function () {
          var t = [];
          return (
            (t.toString = function () {
              for (var t = [], e = 0; e < this.length; e++) {
                var n = this[e];
                n[2]
                  ? t.push("@media " + n[2] + "{" + n[1] + "}")
                  : t.push(n[1]);
              }
              return t.join("");
            }),
            (t.i = function (e, n) {
              "string" == typeof e && (e = [[null, e, ""]]);
              for (var i = {}, r = 0; r < this.length; r++) {
                var o = this[r][0];
                "number" == typeof o && (i[o] = !0);
              }
              for (r = 0; r < e.length; r++) {
                var a = e[r];
                ("number" == typeof a[0] && i[a[0]]) ||
                  (n && !a[2]
                    ? (a[2] = n)
                    : n && (a[2] = "(" + a[2] + ") and (" + n + ")"),
                  t.push(a));
              }
            }),
            t
          );
        };
      },
      function (t, e) {
        function n(t, e) {
          for (var n = 0; n < t.length; n++) {
            var i = t[n],
              r = u[i.id];
            if (r) {
              for (r.refs++, a = 0; a < r.parts.length; a++)
                r.parts[a](i.parts[a]);
              for (; a < i.parts.length; a++) r.parts.push(c(i.parts[a], e));
            } else {
              for (var o = [], a = 0; a < i.parts.length; a++)
                o.push(c(i.parts[a], e));
              u[i.id] = { id: i.id, refs: 1, parts: o };
            }
          }
        }
        function i(t) {
          for (var e = [], n = {}, i = 0; i < t.length; i++) {
            var r = t[i],
              o = r[0],
              a = { css: r[1], media: r[2], sourceMap: r[3] };
            n[o] ? n[o].parts.push(a) : e.push((n[o] = { id: o, parts: [a] }));
          }
          return e;
        }
        function r(t, e) {
          var n = d(),
            i = g[g.length - 1];
          if ("top" === t.insertAt)
            i
              ? i.nextSibling
                ? n.insertBefore(e, i.nextSibling)
                : n.appendChild(e)
              : n.insertBefore(e, n.firstChild),
              g.push(e);
          else {
            if ("bottom" !== t.insertAt)
              throw new Error(
                "Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'."
              );
            n.appendChild(e);
          }
        }
        function o(t) {
          t.parentNode.removeChild(t);
          var e = g.indexOf(t);
          e >= 0 && g.splice(e, 1);
        }
        function a(t) {
          var e = document.createElement("style");
          return (e.type = "text/css"), r(t, e), e;
        }
        function s(t) {
          var e = document.createElement("link");
          return (e.rel = "stylesheet"), r(t, e), e;
        }
        function c(t, e) {
          var n, i, r;
          if (e.singleton) {
            var c = m++;
            (n = f || (f = a(e))),
              (i = l.bind(null, n, c, !1)),
              (r = l.bind(null, n, c, !0));
          } else
            t.sourceMap &&
            "function" == typeof URL &&
            "function" == typeof URL.createObjectURL &&
            "function" == typeof URL.revokeObjectURL &&
            "function" == typeof Blob &&
            "function" == typeof btoa
              ? ((n = s(e)),
                (i = function (t, e) {
                  var n = e.css,
                    i = e.sourceMap;
                  i &&
                    (n +=
                      "\n/*# sourceMappingURL=data:application/json;base64," +
                      btoa(unescape(encodeURIComponent(JSON.stringify(i)))) +
                      " */");
                  var r = new Blob([n], { type: "text/css" }),
                    o = t.href;
                  (t.href = URL.createObjectURL(r)),
                    o && URL.revokeObjectURL(o);
                }.bind(null, n)),
                (r = function () {
                  o(n), n.href && URL.revokeObjectURL(n.href);
                }))
              : ((n = a(e)),
                (i = function (t, e) {
                  var n = e.css,
                    i = e.media;
                  if ((i && t.setAttribute("media", i), t.styleSheet))
                    t.styleSheet.cssText = n;
                  else {
                    for (; t.firstChild; ) t.removeChild(t.firstChild);
                    t.appendChild(document.createTextNode(n));
                  }
                }.bind(null, n)),
                (r = function () {
                  o(n);
                }));
          return (
            i(t),
            function (e) {
              if (e) {
                if (
                  e.css === t.css &&
                  e.media === t.media &&
                  e.sourceMap === t.sourceMap
                )
                  return;
                i((t = e));
              } else r();
            }
          );
        }
        function l(t, e, n, i) {
          var r = n ? "" : i.css;
          if (t.styleSheet) t.styleSheet.cssText = v(e, r);
          else {
            var o = document.createTextNode(r),
              a = t.childNodes;
            a[e] && t.removeChild(a[e]),
              a.length ? t.insertBefore(o, a[e]) : t.appendChild(o);
          }
        }
        var u = {},
          h = function (t) {
            var e;
            return function () {
              return void 0 === e && (e = t.apply(this, arguments)), e;
            };
          },
          p = h(function () {
            return /msie [6-9]\b/.test(
              window.navigator.userAgent.toLowerCase()
            );
          }),
          d = h(function () {
            return document.head || document.getElementsByTagName("head")[0];
          }),
          f = null,
          m = 0,
          g = [];
        t.exports = function (t, e) {
          if (
            "undefined" != typeof DEBUG &&
            DEBUG &&
            "object" != typeof document
          )
            throw new Error(
              "The style-loader cannot be used in a non-browser environment"
            );
          void 0 === (e = e || {}).singleton && (e.singleton = p()),
            void 0 === e.insertAt && (e.insertAt = "bottom");
          var r = i(t);
          return (
            n(r, e),
            function (t) {
              for (var o = [], a = 0; a < r.length; a++) {
                var s = r[a];
                (c = u[s.id]).refs--, o.push(c);
              }
              for (t && n(i(t), e), a = 0; a < o.length; a++) {
                var c = o[a];
                if (0 === c.refs) {
                  for (var l = 0; l < c.parts.length; l++) c.parts[l]();
                  delete u[c.id];
                }
              }
            }
          );
        };
        var v = (function () {
          var t = [];
          return function (e, n) {
            return (t[e] = n), t.filter(Boolean).join("\n");
          };
        })();
      },
      function (t, e, n) {
        "use strict";
        function i(t) {
          return t && t.__esModule ? t : { default: t };
        }
        Object.defineProperty(e, "__esModule", { value: !0 });
        var r = (function () {
            function t(t, e) {
              for (var n = 0; n < e.length; n++) {
                var i = e[n];
                (i.enumerable = i.enumerable || !1),
                  (i.configurable = !0),
                  "value" in i && (i.writable = !0),
                  Object.defineProperty(t, i.key, i);
              }
            }
            return function (e, n, i) {
              return n && t(e.prototype, n), i && t(e, i), e;
            };
          })(),
          o = i(n(5)),
          a = i(n(8)),
          s = (function (t) {
            function e(t, n) {
              var i =
                  arguments.length > 2 && void 0 !== arguments[2]
                    ? arguments[2]
                    : {},
                r =
                  arguments.length > 3 && void 0 !== arguments[3]
                    ? arguments[3]
                    : "";
              (function (t, e) {
                if (!(t instanceof e))
                  throw new TypeError("Cannot call a class as a function");
              })(this, e),
                (i.classNames = i.classNames || []),
                i.classNames.push("guigui-component");
              var o = (function (t, e) {
                if (!t)
                  throw new ReferenceError(
                    "this hasn't been initialised - super() hasn't been called"
                  );
                return !e || ("object" != typeof e && "function" != typeof e)
                  ? t
                  : e;
              })(
                this,
                (e.__proto__ || Object.getPrototypeOf(e)).call(this, i, r)
              );
              return (
                (0, a.default)(o),
                (o.onWatch = o.onWatch.bind(o)),
                (o.isWatched = !0 === i.watch),
                (o._targetObject = t),
                (o._targetProperty = n),
                (o._value = t[n]),
                o.onEndInteraction(),
                o
              );
            }
            return (
              (function (t, e) {
                if ("function" != typeof e && null !== e)
                  throw new TypeError(
                    "Super expression must either be null or a function, not " +
                      typeof e
                  );
                (t.prototype = Object.create(e && e.prototype, {
                  constructor: {
                    value: t,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0,
                  },
                })),
                  e &&
                    (Object.setPrototypeOf
                      ? Object.setPrototypeOf(t, e)
                      : (t.__proto__ = e));
              })(e, o.default),
              r(e, [
                {
                  key: "invalidate",
                  value: function () {
                    this._value = this._targetObject[this._targetProperty];
                  },
                },
                {
                  key: "onWatch",
                  value: function () {
                    this._targetObject[this._targetProperty] !== this._value &&
                      this.invalidate();
                  },
                },
                {
                  key: "onStartInteraction",
                  value: function () {
                    this.isWatched && clearInterval(this._watchInterval);
                  },
                },
                {
                  key: "onEndInteraction",
                  value: function () {
                    this.isWatched &&
                      (this._watchInterval = setInterval(this.onWatch, 100));
                  },
                },
              ]),
              e
            );
          })();
        e.default = s;
      },
      function (t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 });
        var i =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function (t) {
                  return typeof t;
                }
              : function (t) {
                  return t &&
                    "function" == typeof Symbol &&
                    t.constructor === Symbol &&
                    t !== Symbol.prototype
                    ? "symbol"
                    : typeof t;
                },
          r =
            ((e.isBoolean = function (t) {
              return !0 === t || !1 === t;
            }),
            (e.isFunction = function (t) {
              return "function" == typeof t;
            }));
        (e.isNumber = function (t) {
          return "number" == typeof t;
        }),
          (e.isArray = function (t) {
            return Array.isArray(t);
          }),
          (e.isObject = function (t) {
            return (
              null !== t && "object" === (void 0 === t ? "undefined" : i(t))
            );
          }),
          (e.isThreejsColor = function (t) {
            return t.isColor && r(t.setHex) && r(t.getHex);
          });
      },
      function (t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 });
        var i = (function () {
            function t(t, e) {
              for (var n = 0; n < e.length; n++) {
                var i = e[n];
                (i.enumerable = i.enumerable || !1),
                  (i.configurable = !0),
                  "value" in i && (i.writable = !0),
                  Object.defineProperty(t, i.key, i);
              }
            }
            return function (e, n, i) {
              return n && t(e.prototype, n), i && t(e, i), e;
            };
          })(),
          r = (function (t) {
            return t && t.__esModule ? t : { default: t };
          })(n(18)),
          o = n(0),
          a = n(19),
          s = (function () {
            function t(e) {
              var n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : "";
              (function (t, e) {
                if (!(t instanceof e))
                  throw new TypeError("Cannot call a class as a function");
              })(this, t),
                (this.classNames = e.classNames || []),
                (this.$el = o.createElement.apply(
                  void 0,
                  ["div"].concat(
                    (function (t) {
                      if (Array.isArray(t)) {
                        for (var e = 0, n = Array(t.length); e < t.length; e++)
                          n[e] = t[e];
                        return n;
                      }
                      return Array.from(t);
                    })(this.classNames)
                  )
                )),
                (this.parent = null),
                (this.$el.innerHTML = n);
            }
            return (
              i(t, [
                { key: "render", value: function () {} },
                {
                  key: "appendTo",
                  value: function (t) {
                    (0, r.default)(t)
                      ? ((this.parent = t), t.appendChild(this.$el))
                      : (0, a.warn)(t + " is not a valid dom element");
                  },
                },
                {
                  key: "remove",
                  value: function () {
                    this.parent &&
                      (this.parent.removeChild(this.$el), (this.parent = null));
                  },
                },
              ]),
              t
            );
          })();
        e.default = s;
      },
      function (t, e, n) {
        "use strict";
        function i(t) {
          return t && t.__esModule ? t : { default: t };
        }
        Object.defineProperty(e, "__esModule", { value: !0 });
        var r = (function () {
            function t(t, e) {
              for (var n = 0; n < e.length; n++) {
                var i = e[n];
                (i.enumerable = i.enumerable || !1),
                  (i.configurable = !0),
                  "value" in i && (i.writable = !0),
                  Object.defineProperty(t, i.key, i);
              }
            }
            return function (e, n, i) {
              return n && t(e.prototype, n), i && t(e, i), e;
            };
          })(),
          o = i(n(17)),
          a = i(n(5)),
          s = n(0),
          c = i(n(7)),
          l = (function (t) {
            function e(t, n) {
              var i =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : void 0;
              (function (t, e) {
                if (!(t instanceof e))
                  throw new TypeError("Cannot call a class as a function");
              })(this, e),
                (n.classNames = n.classNames || ["guigui-folder"]),
                (i =
                  i ||
                  '\n      <div class="guigui-folder-head">\n        <h2 class="guigui-folder-label">' +
                    t +
                    '</h2>\n        <div class="guigui-folder-toggle">\n          <div class="guigui-folder-toggle-line"></div>\n          <div class="guigui-folder-toggle-line"></div>\n        </div>\n      </div>\n      <div class="guigui-folder-content"></div>\n    ');
              var r = (function (t, e) {
                if (!t)
                  throw new ReferenceError(
                    "this hasn't been initialised - super() hasn't been called"
                  );
                return !e || ("object" != typeof e && "function" != typeof e)
                  ? t
                  : e;
              })(
                this,
                (e.__proto__ || Object.getPrototypeOf(e)).call(this, n, i)
              );
              return (
                (r.toggle = r.toggle.bind(r)),
                (r.folderName = t),
                (r.components = []),
                (r.folders = []),
                (r.$content = r.$el.querySelector(
                  "." + n.classNames[0] + "-content"
                )),
                (r.$head = r.$el.querySelector(
                  "." + n.classNames[0] + "-head"
                )),
                r.$head.addEventListener("click", r.toggle),
                r
              );
            }
            return (
              (function (t, e) {
                if ("function" != typeof e && null !== e)
                  throw new TypeError(
                    "Super expression must either be null or a function, not " +
                      typeof e
                  );
                (t.prototype = Object.create(e && e.prototype, {
                  constructor: {
                    value: t,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0,
                  },
                })),
                  e &&
                    (Object.setPrototypeOf
                      ? Object.setPrototypeOf(t, e)
                      : (t.__proto__ = e));
              })(e, a.default),
              r(e, [
                {
                  key: "toggle",
                  value: function () {
                    (0, s.toggleClass)(
                      this.$el,
                      this.classNames[0] + "--opened"
                    );
                  },
                },
                {
                  key: "close",
                  value: function () {
                    (0, s.removeClass)(
                      this.$el,
                      this.classNames[0] + "--opened"
                    );
                  },
                },
                {
                  key: "open",
                  value: function () {
                    (0, s.addClass)(this.$el, this.classNames[0] + "--opened");
                  },
                },
                {
                  key: "addFolder",
                  value: function (t) {
                    var n = new e(
                      t,
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : {}
                    );
                    return this.folders.push(n), n.appendTo(this.$content), n;
                  },
                },
                {
                  key: "add",
                  value: function (t, e, n, i) {
                    var r = (0, o.default)(t, e, n, i);
                    return (
                      this.components.push(r), r.appendTo(this.$content), r
                    );
                  },
                },
                {
                  key: "addColorPicker",
                  value: function () {
                    return this.addColor.apply(this, arguments);
                  },
                },
                {
                  key: "addColor",
                  value: function (t, e, n) {
                    var i = new c.default(t, e, n);
                    return (
                      this.components.push(i), i.appendTo(this.$content), i
                    );
                  },
                },
              ]),
              e
            );
          })();
        e.default = l;
      },
      function (t, e, n) {
        "use strict";
        function i(t) {
          return t && t.__esModule ? t : { default: t };
        }
        Object.defineProperty(e, "__esModule", { value: !0 });
        var r = (function () {
            function t(t, e) {
              for (var n = 0; n < e.length; n++) {
                var i = e[n];
                (i.enumerable = i.enumerable || !1),
                  (i.configurable = !0),
                  "value" in i && (i.writable = !0),
                  Object.defineProperty(t, i.key, i);
              }
            }
            return function (e, n, i) {
              return n && t(e.prototype, n), i && t(e, i), e;
            };
          })(),
          o = i(n(3)),
          a = n(0),
          s = n(4),
          c = i(n(40));
        n(41);
        var l = (function (t) {
          function e(t, n) {
            var i =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : {};
            !(function (t, e) {
              if (!(t instanceof e))
                throw new TypeError("Cannot call a class as a function");
            })(this, e);
            var r = i.label,
              o =
                '\n      <div class="guigui-colorpicker-label">' +
                (void 0 === r ? n : r) +
                '</div>\n      <div class="guigui-colorpicker-state">\n        <input type="text" class="guigui-colorpicker-text" value="#FF0000"/>\n      </div>\n    ',
              a = (function (t, e) {
                if (!t)
                  throw new ReferenceError(
                    "this hasn't been initialised - super() hasn't been called"
                  );
                return !e || ("object" != typeof e && "function" != typeof e)
                  ? t
                  : e;
              })(
                this,
                (e.__proto__ || Object.getPrototypeOf(e)).call(
                  this,
                  t,
                  n,
                  { classNames: ["guigui-colorpicker"] },
                  o
                )
              );
            (a.onColorPickerClick = a.onColorPickerClick.bind(a)),
              (a.onColorPickerUpdate = a.onColorPickerUpdate.bind(a)),
              (a.onPickerMouseLeave = a.onPickerMouseLeave.bind(a)),
              (a.onFinishedInteracting = a.onFinishedInteracting.bind(a)),
              (a.onTextChange = a.onTextChange.bind(a));
            var l = t[n];
            return (
              (a.isThreejsColor = (0, s.isThreejsColor)(l)),
              (a.initialColorFormat =
                (0, s.isNumber)(l) || a.isThreejsColor ? "number" : "string"),
              (a.isOpened = !1),
              (a.$text = a.$el.querySelector(".guigui-colorpicker-text")),
              (a.$state = a.$el.querySelector(".guigui-colorpicker-state")),
              (a.colorPicker = new c.default({
                el: a.$el,
                color: a.isThreejsColor
                  ? a._targetObject[a._targetProperty].getHex()
                  : a._targetObject[a._targetProperty],
                background: "#30343c",
              })),
              (a.$picker = a.colorPicker.$el),
              a.colorPicker.onChange(a.onColorPickerUpdate),
              (a.$text.value = a.colorPicker.color.toHexString()),
              a.onTextChange(),
              a.$state.addEventListener("click", a.onColorPickerClick),
              a.$text.addEventListener("change", a.onTextChange),
              a
            );
          }
          return (
            (function (t, e) {
              if ("function" != typeof e && null !== e)
                throw new TypeError(
                  "Super expression must either be null or a function, not " +
                    typeof e
                );
              (t.prototype = Object.create(e && e.prototype, {
                constructor: {
                  value: t,
                  enumerable: !1,
                  writable: !0,
                  configurable: !0,
                },
              })),
                e &&
                  (Object.setPrototypeOf
                    ? Object.setPrototypeOf(t, e)
                    : (t.__proto__ = e));
            })(e, o.default),
            r(e, [
              {
                key: "remove",
                value: function () {
                  this.$state.removeEventListener(
                    "click",
                    this.onColorPickerClick
                  ),
                    this.$picker.removeEventListener(
                      "mouseleave",
                      this.onPickerMouseLeave
                    ),
                    window.removeEventListener(
                      "mouseup",
                      this.onFinishedInteracting
                    ),
                    (function t(e, n, i) {
                      null === e && (e = Function.prototype);
                      var r = Object.getOwnPropertyDescriptor(e, n);
                      if (void 0 === r) {
                        var o = Object.getPrototypeOf(e);
                        return null === o ? void 0 : t(o, n, i);
                      }
                      if ("value" in r) return r.value;
                      var a = r.get;
                      return void 0 !== a ? a.call(i) : void 0;
                    })(
                      e.prototype.__proto__ ||
                        Object.getPrototypeOf(e.prototype),
                      "remove",
                      this
                    ).call(this);
                },
              },
              {
                key: "getColor",
                value: function () {
                  return "number" === this.initialColorFormat
                    ? this.colorPicker.getHexNumber()
                    : this.colorPicker.getHexString();
                },
              },
              {
                key: "_closePicker",
                value: function () {
                  (this.isOpened = !1),
                    (0, a.removeClass)(this.$el, "guigui-colorpicker--opened"),
                    this.onEndInteraction();
                },
              },
              {
                key: "invalidate",
                value: function () {
                  this.colorPicker.setColor(this._value),
                    this.onColorPickerUpdate();
                },
              },
              {
                key: "onTextChange",
                value: function () {
                  this.colorPicker.setColor(this.$text.value);
                },
              },
              {
                key: "onColorPickerClick",
                value: function () {
                  (this.isOpened = !this.isOpened),
                    this.isOpened
                      ? (this.onStartInteraction(),
                        (0, a.addClass)(this.$el, "guigui-colorpicker--opened"),
                        this.$picker.addEventListener(
                          "mouseleave",
                          this.onPickerMouseLeave
                        ))
                      : this._closePicker();
                },
              },
              {
                key: "onPickerMouseLeave",
                value: function () {
                  this.$picker.removeEventListener(
                    "mouseleave",
                    this.onPickerMouseLeave
                  ),
                    this.colorPicker.choosing
                      ? window.addEventListener(
                          "mouseup",
                          this.onFinishedInteracting
                        )
                      : this._closePicker();
                },
              },
              {
                key: "onFinishedInteracting",
                value: function () {
                  window.removeEventListener(
                    "mouseup",
                    this.onFinishedInteracting
                  ),
                    this._closePicker();
                },
              },
              {
                key: "onColorPickerUpdate",
                value: function () {
                  var t = this.colorPicker.getHexString(),
                    e = this.getColor();
                  (this._value = e),
                    (this.$state.style.background = t),
                    (this.$text.value = t),
                    (this.$text.style.color = this.colorPicker.isDark()
                      ? "white"
                      : "black"),
                    this.isThreejsColor
                      ? this._targetObject[this._targetProperty].setHex(e)
                      : (this._targetObject[this._targetProperty] = e),
                    this.emit("update", e);
                },
              },
            ]),
            e
          );
        })();
        e.default = l;
      },
      function (t, e, n) {
        function i(t) {
          if (t)
            return (function (t) {
              for (var e in i.prototype) t[e] = i.prototype[e];
              return t;
            })(t);
        }
        (t.exports = i),
          (i.prototype.on = i.prototype.addEventListener =
            function (t, e) {
              return (
                (this._callbacks = this._callbacks || {}),
                (this._callbacks["$" + t] =
                  this._callbacks["$" + t] || []).push(e),
                this
              );
            }),
          (i.prototype.once = function (t, e) {
            function n() {
              this.off(t, n), e.apply(this, arguments);
            }
            return (n.fn = e), this.on(t, n), this;
          }),
          (i.prototype.off =
            i.prototype.removeListener =
            i.prototype.removeAllListeners =
            i.prototype.removeEventListener =
              function (t, e) {
                if (
                  ((this._callbacks = this._callbacks || {}),
                  0 == arguments.length)
                )
                  return (this._callbacks = {}), this;
                var n = this._callbacks["$" + t];
                if (!n) return this;
                if (1 == arguments.length)
                  return delete this._callbacks["$" + t], this;
                for (var i, r = 0; r < n.length; r++)
                  if ((i = n[r]) === e || i.fn === e) {
                    n.splice(r, 1);
                    break;
                  }
                return this;
              }),
          (i.prototype.emit = function (t) {
            this._callbacks = this._callbacks || {};
            var e = [].slice.call(arguments, 1),
              n = this._callbacks["$" + t];
            if (n)
              for (var i = 0, r = (n = n.slice(0)).length; i < r; ++i)
                n[i].apply(this, e);
            return this;
          }),
          (i.prototype.listeners = function (t) {
            return (
              (this._callbacks = this._callbacks || {}),
              this._callbacks["$" + t] || []
            );
          }),
          (i.prototype.hasListeners = function (t) {
            return !!this.listeners(t).length;
          });
      },
      function (t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 });
        var i = (function () {
            function t(t, e) {
              for (var n = 0; n < e.length; n++) {
                var i = e[n];
                (i.enumerable = i.enumerable || !1),
                  (i.configurable = !0),
                  "value" in i && (i.writable = !0),
                  Object.defineProperty(t, i.key, i);
              }
            }
            return function (e, n, i) {
              return n && t(e.prototype, n), i && t(e, i), e;
            };
          })(),
          r = (function (t) {
            return t && t.__esModule ? t : { default: t };
          })(n(5)),
          o = n(0),
          a = (function (t) {
            function e(t, n) {
              !(function (t, e) {
                if (!(t instanceof e))
                  throw new TypeError("Cannot call a class as a function");
              })(this, e);
              var i = (function (t, e) {
                if (!t)
                  throw new ReferenceError(
                    "this hasn't been initialised - super() hasn't been called"
                  );
                return !e || ("object" != typeof e && "function" != typeof e)
                  ? t
                  : e;
              })(
                this,
                (e.__proto__ || Object.getPrototypeOf(e)).call(
                  this,
                  { classNames: ["guigui-toggle"] },
                  '\n      <div class="guigui-toggle-line"></div>\n      <div class="guigui-toggle-line"></div>\n    '
                )
              );
              return (
                (i.toggle = i.toggle.bind(i)),
                (i.$container = t),
                (i.containerClass = n),
                i.$el.addEventListener("click", i.toggle),
                i
              );
            }
            return (
              (function (t, e) {
                if ("function" != typeof e && null !== e)
                  throw new TypeError(
                    "Super expression must either be null or a function, not " +
                      typeof e
                  );
                (t.prototype = Object.create(e && e.prototype, {
                  constructor: {
                    value: t,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0,
                  },
                })),
                  e &&
                    (Object.setPrototypeOf
                      ? Object.setPrototypeOf(t, e)
                      : (t.__proto__ = e));
              })(e, r.default),
              i(e, [
                {
                  key: "toggle",
                  value: function () {
                    (0, o.toggleClass)(
                      this.$el,
                      this.classNames[0] + "--opened"
                    ),
                      (0, o.toggleClass)(
                        this.$container,
                        this.containerClass + "--opened"
                      );
                  },
                },
              ]),
              e
            );
          })();
        e.default = a;
      },
      function (t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 });
        var i = (function (t) {
            return t && t.__esModule ? t : { default: t };
          })(n(6)),
          r = (function (t) {
            function e() {
              var t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : "";
              !(function (t, e) {
                if (!(t instanceof e))
                  throw new TypeError("Cannot call a class as a function");
              })(this, e);
              var n =
                '\n      <div class="guigui-panel-head">\n        <h2 class="guigui-panel-label">' +
                t +
                '</h2>\n      </div>\n      <div class="guigui-panel-content"></div>\n    ';
              return (function (t, e) {
                if (!t)
                  throw new ReferenceError(
                    "this hasn't been initialised - super() hasn't been called"
                  );
                return !e || ("object" != typeof e && "function" != typeof e)
                  ? t
                  : e;
              })(
                this,
                (e.__proto__ || Object.getPrototypeOf(e)).call(
                  this,
                  t,
                  { classNames: ["guigui-panel", "guigui-panel--opened"] },
                  n
                )
              );
            }
            return (
              (function (t, e) {
                if ("function" != typeof e && null !== e)
                  throw new TypeError(
                    "Super expression must either be null or a function, not " +
                      typeof e
                  );
                (t.prototype = Object.create(e && e.prototype, {
                  constructor: {
                    value: t,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0,
                  },
                })),
                  e &&
                    (Object.setPrototypeOf
                      ? Object.setPrototypeOf(t, e)
                      : (t.__proto__ = e));
              })(e, i.default),
              e
            );
          })();
        e.default = r;
      },
      function (t, e, n) {
        var i = n(29);
        "string" == typeof i && (i = [[t.i, i, ""]]),
          n(2)(i, {}),
          i.locals && (t.exports = i.locals);
      },
      function (t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 });
        var i = (function () {
            function t(t, e) {
              for (var n = 0; n < e.length; n++) {
                var i = e[n];
                (i.enumerable = i.enumerable || !1),
                  (i.configurable = !0),
                  "value" in i && (i.writable = !0),
                  Object.defineProperty(t, i.key, i);
              }
            }
            return function (e, n, i) {
              return n && t(e.prototype, n), i && t(e, i), e;
            };
          })(),
          r = (function (t) {
            return t && t.__esModule ? t : { default: t };
          })(n(3)),
          o = n(0);
        n(42);
        var a = (function (t) {
          function e(t, n) {
            var i =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : {};
            !(function (t, e) {
              if (!(t instanceof e))
                throw new TypeError("Cannot call a class as a function");
            })(this, e);
            var r = i.label,
              o = void 0 === r ? n : r,
              a = i.scope,
              s = void 0 === a ? t : a,
              c =
                '\n      <div class="guigui-launcher-label">' +
                o +
                "<span>()</span></div>\n    ",
              l = (function (t, e) {
                if (!t)
                  throw new ReferenceError(
                    "this hasn't been initialised - super() hasn't been called"
                  );
                return !e || ("object" != typeof e && "function" != typeof e)
                  ? t
                  : e;
              })(
                this,
                (e.__proto__ || Object.getPrototypeOf(e)).call(
                  this,
                  t,
                  n,
                  { classNames: ["guigui-launcher"] },
                  c
                )
              );
            return (
              (l.onButtonClick = l.onButtonClick.bind(l)),
              (l.onMouseDown = l.onMouseDown.bind(l)),
              (l.onMouseUp = l.onMouseUp.bind(l)),
              (l.labelText = o),
              (l.callbackScope = s),
              l.$el.addEventListener("click", l.onButtonClick),
              l.$el.addEventListener("mousedown", l.onMouseDown),
              l
            );
          }
          return (
            (function (t, e) {
              if ("function" != typeof e && null !== e)
                throw new TypeError(
                  "Super expression must either be null or a function, not " +
                    typeof e
                );
              (t.prototype = Object.create(e && e.prototype, {
                constructor: {
                  value: t,
                  enumerable: !1,
                  writable: !0,
                  configurable: !0,
                },
              })),
                e &&
                  (Object.setPrototypeOf
                    ? Object.setPrototypeOf(t, e)
                    : (t.__proto__ = e));
            })(e, r.default),
            i(e, [
              {
                key: "remove",
                value: function () {
                  this.$el.removeEventListener("click", this.onButtonClick),
                    this.$el.removeEventListener("mousedown", this.onMouseDown),
                    window.removeEventListener("mouseup", this.onMouseUp),
                    (function t(e, n, i) {
                      null === e && (e = Function.prototype);
                      var r = Object.getOwnPropertyDescriptor(e, n);
                      if (void 0 === r) {
                        var o = Object.getPrototypeOf(e);
                        return null === o ? void 0 : t(o, n, i);
                      }
                      if ("value" in r) return r.value;
                      var a = r.get;
                      return void 0 !== a ? a.call(i) : void 0;
                    })(
                      e.prototype.__proto__ ||
                        Object.getPrototypeOf(e.prototype),
                      "remove",
                      this
                    ).call(this);
                },
              },
              {
                key: "onButtonClick",
                value: function (t) {
                  this._targetObject[this._targetProperty].call(
                    this.callbackScope
                  );
                },
              },
              {
                key: "onMouseDown",
                value: function (t) {
                  (0, o.addClass)(this.$el, "guigui-launcher--pressed"),
                    window.addEventListener("mouseup", this.onMouseUp);
                },
              },
              {
                key: "onMouseUp",
                value: function (t) {
                  window.removeEventListener("mouseup", this.onMouseUp),
                    (0, o.removeClass)(this.$el, "guigui-launcher--pressed");
                },
              },
            ]),
            e
          );
        })();
        e.default = a;
      },
      function (t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 });
        var i = (function () {
            function t(t, e) {
              for (var n = 0; n < e.length; n++) {
                var i = e[n];
                (i.enumerable = i.enumerable || !1),
                  (i.configurable = !0),
                  "value" in i && (i.writable = !0),
                  Object.defineProperty(t, i.key, i);
              }
            }
            return function (e, n, i) {
              return n && t(e.prototype, n), i && t(e, i), e;
            };
          })(),
          r = (function (t) {
            return t && t.__esModule ? t : { default: t };
          })(n(3)),
          o = (n(0), n(4));
        n(43);
        var a = (function (t) {
          function e(t, n, i) {
            var r =
              arguments.length > 3 && void 0 !== arguments[3]
                ? arguments[3]
                : {};
            !(function (t, e) {
              if (!(t instanceof e))
                throw new TypeError("Cannot call a class as a function");
            })(this, e);
            var a = r.label,
              s = void 0 === a ? n : a,
              c = t[n],
              l =
                '\n      <div class="guigui-select-label">' +
                s +
                "</div>\n      <select>\n        " +
                (i = i.map(function (t) {
                  return (0, o.isObject)(t) && t.name && t.value
                    ? t
                    : { name: t, value: t };
                }))
                  .map(function (t) {
                    var e = t.value,
                      n = t.name;
                    return (
                      "<option " +
                      (e === c ? "selected" : "") +
                      ' value="' +
                      e +
                      '">' +
                      n +
                      "</option>"
                    );
                  })
                  .join("") +
                "\n      </select>\n    ",
              u = (function (t, e) {
                if (!t)
                  throw new ReferenceError(
                    "this hasn't been initialised - super() hasn't been called"
                  );
                return !e || ("object" != typeof e && "function" != typeof e)
                  ? t
                  : e;
              })(
                this,
                (e.__proto__ || Object.getPrototypeOf(e)).call(
                  this,
                  t,
                  n,
                  { classNames: ["guigui-select"] },
                  l
                )
              );
            return (
              (u.onSelectChange = u.onSelectChange.bind(u)),
              (u.$select = u.$el.querySelector("select")),
              (u.value = c),
              u.$select.addEventListener("change", u.onSelectChange),
              u
            );
          }
          return (
            (function (t, e) {
              if ("function" != typeof e && null !== e)
                throw new TypeError(
                  "Super expression must either be null or a function, not " +
                    typeof e
                );
              (t.prototype = Object.create(e && e.prototype, {
                constructor: {
                  value: t,
                  enumerable: !1,
                  writable: !0,
                  configurable: !0,
                },
              })),
                e &&
                  (Object.setPrototypeOf
                    ? Object.setPrototypeOf(t, e)
                    : (t.__proto__ = e));
            })(e, r.default),
            i(e, [
              {
                key: "onSelectChange",
                value: function (t) {
                  this.value = this.$select.value;
                },
              },
              {
                key: "invalidate",
                value: function () {
                  (function t(e, n, i) {
                    null === e && (e = Function.prototype);
                    var r = Object.getOwnPropertyDescriptor(e, n);
                    if (void 0 === r) {
                      var o = Object.getPrototypeOf(e);
                      return null === o ? void 0 : t(o, n, i);
                    }
                    if ("value" in r) return r.value;
                    var a = r.get;
                    return void 0 !== a ? a.call(i) : void 0;
                  })(
                    e.prototype.__proto__ || Object.getPrototypeOf(e.prototype),
                    "invalidate",
                    this
                  ).call(this),
                    (this.value = this._value);
                },
              },
              {
                key: "value",
                get: function () {
                  return this.$select.value;
                },
                set: function (t) {
                  (this.$select.value = t),
                    (this._value = t),
                    (this._targetObject[this._targetProperty] = t),
                    this.emit("update", this.sliderValue);
                },
              },
            ]),
            e
          );
        })();
        e.default = a;
      },
      function (t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 });
        var i = (function () {
            function t(t, e) {
              for (var n = 0; n < e.length; n++) {
                var i = e[n];
                (i.enumerable = i.enumerable || !1),
                  (i.configurable = !0),
                  "value" in i && (i.writable = !0),
                  Object.defineProperty(t, i.key, i);
              }
            }
            return function (e, n, i) {
              return n && t(e.prototype, n), i && t(e, i), e;
            };
          })(),
          r = function t(e, n, i) {
            null === e && (e = Function.prototype);
            var r = Object.getOwnPropertyDescriptor(e, n);
            if (void 0 === r) {
              var o = Object.getPrototypeOf(e);
              return null === o ? void 0 : t(o, n, i);
            }
            if ("value" in r) return r.value;
            var a = r.get;
            return void 0 !== a ? a.call(i) : void 0;
          },
          o = (function (t) {
            return t && t.__esModule ? t : { default: t };
          })(n(3)),
          a = n(20),
          s = n(0);
        n(44);
        var c = (function (t) {
          function e(t, n) {
            var i =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : {};
            !(function (t, e) {
              if (!(t instanceof e))
                throw new TypeError("Cannot call a class as a function");
            })(this, e);
            var r = i.step,
              o = void 0 === r ? 1 : r,
              s = i.min,
              c = void 0 === s ? 0 : s,
              l = i.max,
              u = void 0 === l ? 100 : l,
              h = i.watch,
              p = void 0 !== h && h,
              d = i.label,
              f = void 0 === d ? n : d,
              m = i.minText,
              g = void 0 === m ? (0, a.format)(c, o.toString()) : m,
              v = i.maxText,
              y = void 0 === v ? (0, a.format)(u, o.toString()) : v,
              x =
                '\n      <div class="guigui-slider-label">' +
                f +
                '</div>\n      <div class="guigui-slider-container">\n        <div class="guigui-slider-background"></div>\n        <div class="guigui-slider-handle"></div>\n          <div class="guigui-slider-indice guigui-slider-indice--min">' +
                g +
                '</div>\n          <div class="guigui-slider-indice guigui-slider-indice--max">' +
                y +
                '</div>\n        </div>\n        <input type="text" class="guigui-slider-value" value="0"/>\n      </div>\n    ',
              b = (function (t, e) {
                if (!t)
                  throw new ReferenceError(
                    "this hasn't been initialised - super() hasn't been called"
                  );
                return !e || ("object" != typeof e && "function" != typeof e)
                  ? t
                  : e;
              })(
                this,
                (e.__proto__ || Object.getPrototypeOf(e)).call(
                  this,
                  t,
                  n,
                  { watch: p, classNames: ["guigui-slider"] },
                  x
                )
              );
            return (
              (b.onSliderStartDrag = b.onSliderStartDrag.bind(b)),
              (b.onSliderStopDrag = b.onSliderStopDrag.bind(b)),
              (b.onSliderDrag = b.onSliderDrag.bind(b)),
              (b.onTextStartDrag = b.onTextStartDrag.bind(b)),
              (b.onTextStopDrag = b.onTextStopDrag.bind(b)),
              (b.onTextDrag = b.onTextDrag.bind(b)),
              (b.onTextKeyDown = b.onTextKeyDown.bind(b)),
              (b.onTextChange = b.onTextChange.bind(b)),
              (b.step = o),
              (b.min = c),
              (b.max = u),
              (b.labelText = f || n),
              (b.isWatched = !0 === p),
              (b.minText = g),
              (b.maxText = y),
              (b.textValueSlowingFactor = 0.1),
              (b.sliderValue = 0),
              (b.$container = b.$el.querySelector(".guigui-slider-container")),
              (b.$handle = b.$el.querySelector(".guigui-slider-handle")),
              (b.$background = b.$el.querySelector(
                ".guigui-slider-background"
              )),
              (b.$value = b.$el.querySelector(".guigui-slider-value")),
              b.$container.addEventListener("mousedown", b.onSliderStartDrag),
              b.$value.addEventListener("mousedown", b.onTextStartDrag),
              b.$value.addEventListener("keydown", b.onTextKeyDown),
              b.$value.addEventListener("change", b.onTextChange),
              (b.value = b._targetObject[b._targetProperty]),
              b
            );
          }
          return (
            (function (t, e) {
              if ("function" != typeof e && null !== e)
                throw new TypeError(
                  "Super expression must either be null or a function, not " +
                    typeof e
                );
              (t.prototype = Object.create(e && e.prototype, {
                constructor: {
                  value: t,
                  enumerable: !1,
                  writable: !0,
                  configurable: !0,
                },
              })),
                e &&
                  (Object.setPrototypeOf
                    ? Object.setPrototypeOf(t, e)
                    : (t.__proto__ = e));
            })(e, o.default),
            i(e, [
              {
                key: "remove",
                value: function () {
                  this.$container.removeEventListener(
                    "mousedown",
                    this.onSliderStartDrag
                  ),
                    this.$value.removeEventListener(
                      "mousedown",
                      this.onTextStartDrag
                    ),
                    this.$value.removeEventListener(
                      "keydown",
                      this.onTextKeyDown
                    ),
                    this.$value.removeEventListener(
                      "change",
                      this.onTextChange
                    ),
                    this.onSliderStopDrag(),
                    this.onTextStopDrag(),
                    r(
                      e.prototype.__proto__ ||
                        Object.getPrototypeOf(e.prototype),
                      "remove",
                      this
                    ).call(this);
                },
              },
              {
                key: "onSliderStartDrag",
                value: function (t) {
                  this.onStartInteraction(),
                    this.onSliderDrag(t),
                    window.addEventListener("mouseup", this.onSliderStopDrag),
                    window.addEventListener("mousemove", this.onSliderDrag),
                    t.preventDefault();
                },
              },
              {
                key: "onSliderStopDrag",
                value: function (t) {
                  window.removeEventListener("mouseup", this.onSliderStopDrag),
                    window.removeEventListener("mousemove", this.onSliderDrag),
                    this.onEndInteraction(),
                    t.preventDefault();
                },
              },
              {
                key: "onSliderDrag",
                value: function (t) {
                  var e =
                    (t.clientX - (0, s.offset)(this.$handle).left) /
                    this.$background.offsetWidth;
                  (this.value = this.min + (this.max - this.min) * e),
                    t.preventDefault();
                },
              },
              {
                key: "onTextStartDrag",
                value: function (t) {
                  (this.startY = t.clientY),
                    (this.startValue = this.value),
                    window.addEventListener("mouseup", this.onTextStopDrag),
                    window.addEventListener("mousemove", this.onTextDrag),
                    t.preventDefault();
                },
              },
              {
                key: "onTextStopDrag",
                value: function (t) {
                  window.removeEventListener("mouseup", this.onTextStopDrag),
                    window.removeEventListener("mousemove", this.onTextDrag),
                    t.preventDefault();
                },
              },
              {
                key: "onTextDrag",
                value: function (t) {
                  var e = this.startY - t.clientY;
                  (this.value =
                    this.startValue +
                    e * this.step * this.textValueSlowingFactor),
                    t.preventDefault();
                },
              },
              {
                key: "onTextKeyDown",
                value: function (t) {
                  if (38 === t.keyCode) this.value += this.step;
                  else {
                    if (40 !== t.keyCode) return;
                    this.value -= this.step;
                  }
                  t.preventDefault();
                },
              },
              {
                key: "onTextChange",
                value: function () {
                  this.$value.value.match(/^[+-]?\d+(\.\d+)?$/g)
                    ? (this.value = Number(this.$value.value))
                    : (this.value = this.sliderValue);
                },
              },
              {
                key: "updateTarget",
                value: function () {
                  return (
                    (this._targetObject[this._targetProperty] =
                      this.sliderValue),
                    this
                  );
                },
              },
              {
                key: "updateText",
                value: function () {
                  return (
                    isNaN(this.sliderValue) ||
                      (this.$value.value = (0, a.format)(
                        this.sliderValue,
                        this.step.toString()
                      )),
                    this
                  );
                },
              },
              {
                key: "updateSlider",
                value: function () {
                  return (
                    (this.$handle.style.transform =
                      "scaleX(" +
                      (1 -
                        (this.sliderValue - this.min) / (this.max - this.min)) +
                      ")"),
                    this
                  );
                },
              },
              {
                key: "invalidate",
                value: function () {
                  r(
                    e.prototype.__proto__ || Object.getPrototypeOf(e.prototype),
                    "invalidate",
                    this
                  ).call(this),
                    (this.value = this._value);
                },
              },
              {
                key: "value",
                get: function () {
                  return this.sliderValue;
                },
                set: function (t) {
                  (this.sliderValue = (0, a.clamp)(
                    (0, a.toPrecision)(t, this.step),
                    this.min,
                    this.max
                  )),
                    (this._value = this.sliderValue),
                    this.updateTarget().updateSlider().updateText(),
                    this.emit("update", this.sliderValue);
                },
              },
            ]),
            e
          );
        })();
        e.default = c;
      },
      function (t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 });
        var i = (function () {
            function t(t, e) {
              for (var n = 0; n < e.length; n++) {
                var i = e[n];
                (i.enumerable = i.enumerable || !1),
                  (i.configurable = !0),
                  "value" in i && (i.writable = !0),
                  Object.defineProperty(t, i.key, i);
              }
            }
            return function (e, n, i) {
              return n && t(e.prototype, n), i && t(e, i), e;
            };
          })(),
          r = (function (t) {
            return t && t.__esModule ? t : { default: t };
          })(n(3));
        n(0), n(4), n(45);
        var o = (function (t) {
          function e(t, n) {
            var i =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : {};
            !(function (t, e) {
              if (!(t instanceof e))
                throw new TypeError("Cannot call a class as a function");
            })(this, e);
            var r = i.label,
              o = void 0 === r ? n : r,
              a = t[n],
              s =
                '\n      <div class="guigui-text-label">' +
                o +
                '</div>\n      <input type="text" class="guigui-text-value" value="' +
                a +
                '"/>\n    ',
              c = (function (t, e) {
                if (!t)
                  throw new ReferenceError(
                    "this hasn't been initialised - super() hasn't been called"
                  );
                return !e || ("object" != typeof e && "function" != typeof e)
                  ? t
                  : e;
              })(
                this,
                (e.__proto__ || Object.getPrototypeOf(e)).call(
                  this,
                  t,
                  n,
                  { classNames: ["guigui-text"] },
                  s
                )
              );
            return (
              (c.onInputChange = c.onInputChange.bind(c)),
              (c.$input = c.$el.querySelector("input")),
              (c.value = a),
              c.$input.addEventListener("input", c.onInputChange),
              c
            );
          }
          return (
            (function (t, e) {
              if ("function" != typeof e && null !== e)
                throw new TypeError(
                  "Super expression must either be null or a function, not " +
                    typeof e
                );
              (t.prototype = Object.create(e && e.prototype, {
                constructor: {
                  value: t,
                  enumerable: !1,
                  writable: !0,
                  configurable: !0,
                },
              })),
                e &&
                  (Object.setPrototypeOf
                    ? Object.setPrototypeOf(t, e)
                    : (t.__proto__ = e));
            })(e, r.default),
            i(e, [
              {
                key: "onInputChange",
                value: function (t) {
                  (this.value = this.$input.value),
                    console.log("onInputChange", this.value);
                },
              },
              {
                key: "invalidate",
                value: function () {
                  (function t(e, n, i) {
                    null === e && (e = Function.prototype);
                    var r = Object.getOwnPropertyDescriptor(e, n);
                    if (void 0 === r) {
                      var o = Object.getPrototypeOf(e);
                      return null === o ? void 0 : t(o, n, i);
                    }
                    if ("value" in r) return r.value;
                    var a = r.get;
                    return void 0 !== a ? a.call(i) : void 0;
                  })(
                    e.prototype.__proto__ || Object.getPrototypeOf(e.prototype),
                    "invalidate",
                    this
                  ).call(this),
                    (this.value = this._value);
                },
              },
              {
                key: "value",
                get: function () {
                  return this.$input.value;
                },
                set: function (t) {
                  (this.$input.value = t),
                    (this._value = t),
                    (this._targetObject[this._targetProperty] = t),
                    this.emit("update", this.sliderValue);
                },
              },
            ]),
            e
          );
        })();
        e.default = o;
      },
      function (t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 });
        var i = (function () {
            function t(t, e) {
              for (var n = 0; n < e.length; n++) {
                var i = e[n];
                (i.enumerable = i.enumerable || !1),
                  (i.configurable = !0),
                  "value" in i && (i.writable = !0),
                  Object.defineProperty(t, i.key, i);
              }
            }
            return function (e, n, i) {
              return n && t(e.prototype, n), i && t(e, i), e;
            };
          })(),
          r = (function (t) {
            return t && t.__esModule ? t : { default: t };
          })(n(3)),
          o = n(0);
        n(46);
        var a = (function (t) {
          function e(t, n) {
            var i =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : {};
            !(function (t, e) {
              if (!(t instanceof e))
                throw new TypeError("Cannot call a class as a function");
            })(this, e);
            var r = i.label,
              o = void 0 === r ? n : r,
              a =
                '\n      <div class="guigui-toggler-label">' +
                o +
                '</div>\n      <div class="guigui-toggler-state">\n        <div class="guigui-toggler-handle"></div>\n      </div>\n    ',
              s = (function (t, e) {
                if (!t)
                  throw new ReferenceError(
                    "this hasn't been initialised - super() hasn't been called"
                  );
                return !e || ("object" != typeof e && "function" != typeof e)
                  ? t
                  : e;
              })(
                this,
                (e.__proto__ || Object.getPrototypeOf(e)).call(
                  this,
                  t,
                  n,
                  { classNames: ["guigui-toggler"] },
                  a
                )
              );
            return (
              (s.onTogglerClick = s.onTogglerClick.bind(s)),
              (s.labelText = o),
              (s.isSelected = !1),
              (s.value = !0 === s._targetObject[s._targetProperty]),
              s.$el.addEventListener("click", s.onTogglerClick),
              s
            );
          }
          return (
            (function (t, e) {
              if ("function" != typeof e && null !== e)
                throw new TypeError(
                  "Super expression must either be null or a function, not " +
                    typeof e
                );
              (t.prototype = Object.create(e && e.prototype, {
                constructor: {
                  value: t,
                  enumerable: !1,
                  writable: !0,
                  configurable: !0,
                },
              })),
                e &&
                  (Object.setPrototypeOf
                    ? Object.setPrototypeOf(t, e)
                    : (t.__proto__ = e));
            })(e, r.default),
            i(e, [
              {
                key: "onTogglerClick",
                value: function (t) {
                  this.onStartInteraction(),
                    (this.value = !this.value),
                    this.onEndInteraction();
                },
              },
              {
                key: "value",
                get: function () {
                  return this.isSelected;
                },
                set: function (t) {
                  t
                    ? ((this.isSelected = !0),
                      (0, o.addClass)(this.$el, "guigui-toggler--selected"))
                    : ((this.isSelected = !1),
                      (0, o.removeClass)(this.$el, "guigui-toggler--selected")),
                    (this._targetObject[this._targetProperty] = t),
                    this.emit("update", t);
                },
              },
            ]),
            e
          );
        })();
        e.default = a;
      },
      function (t, e, n) {
        "use strict";
        function i(t) {
          return t && t.__esModule ? t : { default: t };
        }
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.default = function (t, e, n, i) {
            var u = t[e];
            return (0, r.isArray)(n)
              ? new l.default(t, e, n, i)
              : ((i = n),
                (0, r.isBoolean)(u)
                  ? new o.default(t, e, i)
                  : (0, r.isNumber)(u)
                  ? new a.default(t, e, i)
                  : (0, r.isFunction)(u)
                  ? new s.default(t, e, i)
                  : new c.default(t, e, i));
          });
        var r = n(4),
          o = i(n(16)),
          a = i(n(14)),
          s = i(n(12)),
          c = i(n(15)),
          l = i((i(n(7)), n(13)));
      },
      function (t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 });
        var i =
          "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t &&
                  "function" == typeof Symbol &&
                  t.constructor === Symbol &&
                  t !== Symbol.prototype
                  ? "symbol"
                  : typeof t;
              };
        e.default = function (t) {
          return "object" ===
            ("undefined" == typeof Node ? "undefined" : i(Node))
            ? t instanceof Node
            : t &&
                "object" === (void 0 === t ? "undefined" : i(t)) &&
                "number" == typeof t.nodeType &&
                "string" == typeof t.nodeName;
        };
      },
      function (t, e, n) {
        "use strict";
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.warn = function (t) {
            console.warn("[guigui]", t);
          });
      },
      function (t, e, n) {
        "use strict";
        function i(t, e) {
          var n = Math.pow(10, e);
          return (Math.round(t * n) / n).toFixed(e);
        }
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.toFixed = i),
          (e.format = function (t, e) {
            var n = String(e).split(".")[1];
            return i(t, n ? n.length : 0);
          }),
          (e.clamp = function (t, e, n) {
            return Math.min(Math.max(t, e), n);
          }),
          (e.toPrecision = function (t, e) {
            return Math.round(t / e) * e;
          });
      },
      function (t, e, n) {
        "use strict";
        function i(t) {
          var e = t.length;
          if (e % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4");
          return "=" === t[e - 2] ? 2 : "=" === t[e - 1] ? 1 : 0;
        }
        function r(t) {
          return (
            a[(t >> 18) & 63] + a[(t >> 12) & 63] + a[(t >> 6) & 63] + a[63 & t]
          );
        }
        function o(t, e, n) {
          for (var i, o = [], a = e; a < n; a += 3)
            (i = (t[a] << 16) + (t[a + 1] << 8) + t[a + 2]), o.push(r(i));
          return o.join("");
        }
        (e.byteLength = function (t) {
          return (3 * t.length) / 4 - i(t);
        }),
          (e.toByteArray = function (t) {
            var e,
              n,
              r,
              o,
              a,
              l,
              u = t.length;
            (a = i(t)), (l = new c((3 * u) / 4 - a)), (r = a > 0 ? u - 4 : u);
            var h = 0;
            for (e = 0, n = 0; e < r; e += 4, n += 3)
              (o =
                (s[t.charCodeAt(e)] << 18) |
                (s[t.charCodeAt(e + 1)] << 12) |
                (s[t.charCodeAt(e + 2)] << 6) |
                s[t.charCodeAt(e + 3)]),
                (l[h++] = (o >> 16) & 255),
                (l[h++] = (o >> 8) & 255),
                (l[h++] = 255 & o);
            return (
              2 === a
                ? ((o =
                    (s[t.charCodeAt(e)] << 2) | (s[t.charCodeAt(e + 1)] >> 4)),
                  (l[h++] = 255 & o))
                : 1 === a &&
                  ((o =
                    (s[t.charCodeAt(e)] << 10) |
                    (s[t.charCodeAt(e + 1)] << 4) |
                    (s[t.charCodeAt(e + 2)] >> 2)),
                  (l[h++] = (o >> 8) & 255),
                  (l[h++] = 255 & o)),
              l
            );
          }),
          (e.fromByteArray = function (t) {
            for (
              var e,
                n = t.length,
                i = n % 3,
                r = "",
                s = [],
                c = 16383,
                l = 0,
                u = n - i;
              l < u;
              l += c
            )
              s.push(o(t, l, l + c > u ? u : l + c));
            return (
              1 === i
                ? ((e = t[n - 1]),
                  (r += a[e >> 2]),
                  (r += a[(e << 4) & 63]),
                  (r += "=="))
                : 2 === i &&
                  ((e = (t[n - 2] << 8) + t[n - 1]),
                  (r += a[e >> 10]),
                  (r += a[(e >> 4) & 63]),
                  (r += a[(e << 2) & 63]),
                  (r += "=")),
              s.push(r),
              s.join("")
            );
          });
        for (
          var a = [],
            s = [],
            c = "undefined" != typeof Uint8Array ? Uint8Array : Array,
            l =
              "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
            u = 0,
            h = l.length;
          u < h;
          ++u
        )
          (a[u] = l[u]), (s[l.charCodeAt(u)] = u);
        (s["-".charCodeAt(0)] = 62), (s["_".charCodeAt(0)] = 63);
      },
      function (t, e, n) {
        "use strict";
        (function (t) {
          function i() {
            return o.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
          }
          function r(t, e) {
            if (i() < e) throw new RangeError("Invalid typed array length");
            return (
              o.TYPED_ARRAY_SUPPORT
                ? ((t = new Uint8Array(e)), (t.__proto__ = o.prototype))
                : (null === t && (t = new o(e)), (t.length = e)),
              t
            );
          }
          function o(t, e, n) {
            if (!(o.TYPED_ARRAY_SUPPORT || this instanceof o))
              return new o(t, e, n);
            if ("number" == typeof t) {
              if ("string" == typeof e)
                throw new Error(
                  "If encoding is specified then the first argument must be a string"
                );
              return c(this, t);
            }
            return a(this, t, e, n);
          }
          function a(t, e, n, i) {
            if ("number" == typeof e)
              throw new TypeError('"value" argument must not be a number');
            return "undefined" != typeof ArrayBuffer && e instanceof ArrayBuffer
              ? (function (t, e, n, i) {
                  if ((e.byteLength, n < 0 || e.byteLength < n))
                    throw new RangeError("'offset' is out of bounds");
                  if (e.byteLength < n + (i || 0))
                    throw new RangeError("'length' is out of bounds");
                  return (
                    (e =
                      void 0 === n && void 0 === i
                        ? new Uint8Array(e)
                        : void 0 === i
                        ? new Uint8Array(e, n)
                        : new Uint8Array(e, n, i)),
                    o.TYPED_ARRAY_SUPPORT
                      ? ((t = e), (t.__proto__ = o.prototype))
                      : (t = l(t, e)),
                    t
                  );
                })(t, e, n, i)
              : "string" == typeof e
              ? (function (t, e, n) {
                  if (
                    (("string" == typeof n && "" !== n) || (n = "utf8"),
                    !o.isEncoding(n))
                  )
                    throw new TypeError(
                      '"encoding" must be a valid string encoding'
                    );
                  var i = 0 | h(e, n),
                    a = (t = r(t, i)).write(e, n);
                  return a !== i && (t = t.slice(0, a)), t;
                })(t, e, n)
              : (function (t, e) {
                  if (o.isBuffer(e)) {
                    var n = 0 | u(e.length);
                    return 0 === (t = r(t, n)).length
                      ? t
                      : (e.copy(t, 0, 0, n), t);
                  }
                  if (e) {
                    if (
                      ("undefined" != typeof ArrayBuffer &&
                        e.buffer instanceof ArrayBuffer) ||
                      "length" in e
                    )
                      return "number" != typeof e.length ||
                        (function (t) {
                          return t != t;
                        })(e.length)
                        ? r(t, 0)
                        : l(t, e);
                    if ("Buffer" === e.type && D(e.data)) return l(t, e.data);
                  }
                  throw new TypeError(
                    "First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object."
                  );
                })(t, e);
          }
          function s(t) {
            if ("number" != typeof t)
              throw new TypeError('"size" argument must be a number');
            if (t < 0)
              throw new RangeError('"size" argument must not be negative');
          }
          function c(t, e) {
            if (
              (s(e), (t = r(t, e < 0 ? 0 : 0 | u(e))), !o.TYPED_ARRAY_SUPPORT)
            )
              for (var n = 0; n < e; ++n) t[n] = 0;
            return t;
          }
          function l(t, e) {
            var n = e.length < 0 ? 0 : 0 | u(e.length);
            t = r(t, n);
            for (var i = 0; i < n; i += 1) t[i] = 255 & e[i];
            return t;
          }
          function u(t) {
            if (t >= i())
              throw new RangeError(
                "Attempt to allocate Buffer larger than maximum size: 0x" +
                  i().toString(16) +
                  " bytes"
              );
            return 0 | t;
          }
          function h(t, e) {
            if (o.isBuffer(t)) return t.length;
            if (
              "undefined" != typeof ArrayBuffer &&
              "function" == typeof ArrayBuffer.isView &&
              (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)
            )
              return t.byteLength;
            "string" != typeof t && (t = "" + t);
            var n = t.length;
            if (0 === n) return 0;
            for (var i = !1; ; )
              switch (e) {
                case "ascii":
                case "latin1":
                case "binary":
                  return n;
                case "utf8":
                case "utf-8":
                case void 0:
                  return R(t).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return 2 * n;
                case "hex":
                  return n >>> 1;
                case "base64":
                  return P(t).length;
                default:
                  if (i) return R(t).length;
                  (e = ("" + e).toLowerCase()), (i = !0);
              }
          }
          function p(t, e, n) {
            var i = t[e];
            (t[e] = t[n]), (t[n] = i);
          }
          function d(t, e, n, i, r) {
            if (0 === t.length) return -1;
            if (
              ("string" == typeof n
                ? ((i = n), (n = 0))
                : n > 2147483647
                ? (n = 2147483647)
                : n < -2147483648 && (n = -2147483648),
              (n = +n),
              isNaN(n) && (n = r ? 0 : t.length - 1),
              n < 0 && (n = t.length + n),
              n >= t.length)
            ) {
              if (r) return -1;
              n = t.length - 1;
            } else if (n < 0) {
              if (!r) return -1;
              n = 0;
            }
            if (("string" == typeof e && (e = o.from(e, i)), o.isBuffer(e)))
              return 0 === e.length ? -1 : f(t, e, n, i, r);
            if ("number" == typeof e)
              return (
                (e &= 255),
                o.TYPED_ARRAY_SUPPORT &&
                "function" == typeof Uint8Array.prototype.indexOf
                  ? r
                    ? Uint8Array.prototype.indexOf.call(t, e, n)
                    : Uint8Array.prototype.lastIndexOf.call(t, e, n)
                  : f(t, [e], n, i, r)
              );
            throw new TypeError("val must be string, number or Buffer");
          }
          function f(t, e, n, i, r) {
            function o(t, e) {
              return 1 === a ? t[e] : t.readUInt16BE(e * a);
            }
            var a = 1,
              s = t.length,
              c = e.length;
            if (
              void 0 !== i &&
              ("ucs2" === (i = String(i).toLowerCase()) ||
                "ucs-2" === i ||
                "utf16le" === i ||
                "utf-16le" === i)
            ) {
              if (t.length < 2 || e.length < 2) return -1;
              (a = 2), (s /= 2), (c /= 2), (n /= 2);
            }
            var l;
            if (r) {
              var u = -1;
              for (l = n; l < s; l++)
                if (o(t, l) === o(e, -1 === u ? 0 : l - u)) {
                  if ((-1 === u && (u = l), l - u + 1 === c)) return u * a;
                } else -1 !== u && (l -= l - u), (u = -1);
            } else
              for (n + c > s && (n = s - c), l = n; l >= 0; l--) {
                for (var h = !0, p = 0; p < c; p++)
                  if (o(t, l + p) !== o(e, p)) {
                    h = !1;
                    break;
                  }
                if (h) return l;
              }
            return -1;
          }
          function m(t, e, n, i) {
            n = Number(n) || 0;
            var r = t.length - n;
            i ? (i = Number(i)) > r && (i = r) : (i = r);
            var o = e.length;
            if (o % 2 != 0) throw new TypeError("Invalid hex string");
            i > o / 2 && (i = o / 2);
            for (var a = 0; a < i; ++a) {
              var s = parseInt(e.substr(2 * a, 2), 16);
              if (isNaN(s)) return a;
              t[n + a] = s;
            }
            return a;
          }
          function g(t, e, n, i) {
            return C(R(e, t.length - n), t, n, i);
          }
          function v(t, e, n, i) {
            return C(
              (function (t) {
                for (var e = [], n = 0; n < t.length; ++n)
                  e.push(255 & t.charCodeAt(n));
                return e;
              })(e),
              t,
              n,
              i
            );
          }
          function y(t, e, n, i) {
            return v(t, e, n, i);
          }
          function x(t, e, n, i) {
            return C(P(e), t, n, i);
          }
          function b(t, e, n, i) {
            return C(
              (function (t, e) {
                for (
                  var n, i, r, o = [], a = 0;
                  a < t.length && !((e -= 2) < 0);
                  ++a
                )
                  (n = t.charCodeAt(a)),
                    (i = n >> 8),
                    (r = n % 256),
                    o.push(r),
                    o.push(i);
                return o;
              })(e, t.length - n),
              t,
              n,
              i
            );
          }
          function _(t, e, n) {
            n = Math.min(t.length, n);
            for (var i = [], r = e; r < n; ) {
              var o = t[r],
                a = null,
                s = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
              if (r + s <= n) {
                var c, l, u, h;
                switch (s) {
                  case 1:
                    o < 128 && (a = o);
                    break;
                  case 2:
                    128 == (192 & (c = t[r + 1])) &&
                      (h = ((31 & o) << 6) | (63 & c)) > 127 &&
                      (a = h);
                    break;
                  case 3:
                    (c = t[r + 1]),
                      (l = t[r + 2]),
                      128 == (192 & c) &&
                        128 == (192 & l) &&
                        (h = ((15 & o) << 12) | ((63 & c) << 6) | (63 & l)) >
                          2047 &&
                        (h < 55296 || h > 57343) &&
                        (a = h);
                    break;
                  case 4:
                    (c = t[r + 1]),
                      (l = t[r + 2]),
                      (u = t[r + 3]),
                      128 == (192 & c) &&
                        128 == (192 & l) &&
                        128 == (192 & u) &&
                        (h =
                          ((15 & o) << 18) |
                          ((63 & c) << 12) |
                          ((63 & l) << 6) |
                          (63 & u)) > 65535 &&
                        h < 1114112 &&
                        (a = h);
                }
              }
              null === a
                ? ((a = 65533), (s = 1))
                : a > 65535 &&
                  ((a -= 65536),
                  i.push(((a >>> 10) & 1023) | 55296),
                  (a = 56320 | (1023 & a))),
                i.push(a),
                (r += s);
            }
            return (function (t) {
              var e = t.length;
              if (e <= U) return String.fromCharCode.apply(String, t);
              for (var n = "", i = 0; i < e; )
                n += String.fromCharCode.apply(String, t.slice(i, (i += U)));
              return n;
            })(i);
          }
          function w(t, e, n) {
            if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint");
            if (t + e > n)
              throw new RangeError("Trying to access beyond buffer length");
          }
          function M(t, e, n, i, r, a) {
            if (!o.isBuffer(t))
              throw new TypeError(
                '"buffer" argument must be a Buffer instance'
              );
            if (e > r || e < a)
              throw new RangeError('"value" argument is out of bounds');
            if (n + i > t.length) throw new RangeError("Index out of range");
          }
          function E(t, e, n, i) {
            e < 0 && (e = 65535 + e + 1);
            for (var r = 0, o = Math.min(t.length - n, 2); r < o; ++r)
              t[n + r] =
                (e & (255 << (8 * (i ? r : 1 - r)))) >>> (8 * (i ? r : 1 - r));
          }
          function T(t, e, n, i) {
            e < 0 && (e = 4294967295 + e + 1);
            for (var r = 0, o = Math.min(t.length - n, 4); r < o; ++r)
              t[n + r] = (e >>> (8 * (i ? r : 3 - r))) & 255;
          }
          function S(t, e, n, i, r, o) {
            if (n + i > t.length) throw new RangeError("Index out of range");
            if (n < 0) throw new RangeError("Index out of range");
          }
          function A(t, e, n, i, r) {
            return r || S(t, 0, n, 4), I.write(t, e, n, i, 23, 4), n + 4;
          }
          function L(t, e, n, i, r) {
            return r || S(t, 0, n, 8), I.write(t, e, n, i, 52, 8), n + 8;
          }
          function R(t, e) {
            e = e || 1 / 0;
            for (var n, i = t.length, r = null, o = [], a = 0; a < i; ++a) {
              if ((n = t.charCodeAt(a)) > 55295 && n < 57344) {
                if (!r) {
                  if (n > 56319) {
                    (e -= 3) > -1 && o.push(239, 191, 189);
                    continue;
                  }
                  if (a + 1 === i) {
                    (e -= 3) > -1 && o.push(239, 191, 189);
                    continue;
                  }
                  r = n;
                  continue;
                }
                if (n < 56320) {
                  (e -= 3) > -1 && o.push(239, 191, 189), (r = n);
                  continue;
                }
                n = 65536 + (((r - 55296) << 10) | (n - 56320));
              } else r && (e -= 3) > -1 && o.push(239, 191, 189);
              if (((r = null), n < 128)) {
                if ((e -= 1) < 0) break;
                o.push(n);
              } else if (n < 2048) {
                if ((e -= 2) < 0) break;
                o.push((n >> 6) | 192, (63 & n) | 128);
              } else if (n < 65536) {
                if ((e -= 3) < 0) break;
                o.push((n >> 12) | 224, ((n >> 6) & 63) | 128, (63 & n) | 128);
              } else {
                if (!(n < 1114112)) throw new Error("Invalid code point");
                if ((e -= 4) < 0) break;
                o.push(
                  (n >> 18) | 240,
                  ((n >> 12) & 63) | 128,
                  ((n >> 6) & 63) | 128,
                  (63 & n) | 128
                );
              }
            }
            return o;
          }
          function P(t) {
            return O.toByteArray(
              (function (t) {
                if (
                  (t = (function (t) {
                    return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "");
                  })(t).replace(N, "")).length < 2
                )
                  return "";
                for (; t.length % 4 != 0; ) t += "=";
                return t;
              })(t)
            );
          }
          function C(t, e, n, i) {
            for (var r = 0; r < i && !(r + n >= e.length || r >= t.length); ++r)
              e[r + n] = t[r];
            return r;
          }
          var O = n(21),
            I = n(33),
            D = n(37);
          (e.Buffer = o),
            (e.SlowBuffer = function (t) {
              return +t != t && (t = 0), o.alloc(+t);
            }),
            (e.INSPECT_MAX_BYTES = 50),
            (o.TYPED_ARRAY_SUPPORT =
              void 0 !== t.TYPED_ARRAY_SUPPORT
                ? t.TYPED_ARRAY_SUPPORT
                : (function () {
                    try {
                      var t = new Uint8Array(1);
                      return (
                        (t.__proto__ = {
                          __proto__: Uint8Array.prototype,
                          foo: function () {
                            return 42;
                          },
                        }),
                        42 === t.foo() &&
                          "function" == typeof t.subarray &&
                          0 === t.subarray(1, 1).byteLength
                      );
                    } catch (t) {
                      return !1;
                    }
                  })()),
            (e.kMaxLength = i()),
            (o.poolSize = 8192),
            (o._augment = function (t) {
              return (t.__proto__ = o.prototype), t;
            }),
            (o.from = function (t, e, n) {
              return a(null, t, e, n);
            }),
            o.TYPED_ARRAY_SUPPORT &&
              ((o.prototype.__proto__ = Uint8Array.prototype),
              (o.__proto__ = Uint8Array),
              "undefined" != typeof Symbol &&
                Symbol.species &&
                o[Symbol.species] === o &&
                Object.defineProperty(o, Symbol.species, {
                  value: null,
                  configurable: !0,
                })),
            (o.alloc = function (t, e, n) {
              return (function (t, e, n, i) {
                return (
                  s(e),
                  e <= 0
                    ? r(t, e)
                    : void 0 !== n
                    ? "string" == typeof i
                      ? r(t, e).fill(n, i)
                      : r(t, e).fill(n)
                    : r(t, e)
                );
              })(null, t, e, n);
            }),
            (o.allocUnsafe = function (t) {
              return c(null, t);
            }),
            (o.allocUnsafeSlow = function (t) {
              return c(null, t);
            }),
            (o.isBuffer = function (t) {
              return !(null == t || !t._isBuffer);
            }),
            (o.compare = function (t, e) {
              if (!o.isBuffer(t) || !o.isBuffer(e))
                throw new TypeError("Arguments must be Buffers");
              if (t === e) return 0;
              for (
                var n = t.length, i = e.length, r = 0, a = Math.min(n, i);
                r < a;
                ++r
              )
                if (t[r] !== e[r]) {
                  (n = t[r]), (i = e[r]);
                  break;
                }
              return n < i ? -1 : i < n ? 1 : 0;
            }),
            (o.isEncoding = function (t) {
              switch (String(t).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return !0;
                default:
                  return !1;
              }
            }),
            (o.concat = function (t, e) {
              if (!D(t))
                throw new TypeError(
                  '"list" argument must be an Array of Buffers'
                );
              if (0 === t.length) return o.alloc(0);
              var n;
              if (void 0 === e)
                for (e = 0, n = 0; n < t.length; ++n) e += t[n].length;
              var i = o.allocUnsafe(e),
                r = 0;
              for (n = 0; n < t.length; ++n) {
                var a = t[n];
                if (!o.isBuffer(a))
                  throw new TypeError(
                    '"list" argument must be an Array of Buffers'
                  );
                a.copy(i, r), (r += a.length);
              }
              return i;
            }),
            (o.byteLength = h),
            (o.prototype._isBuffer = !0),
            (o.prototype.swap16 = function () {
              var t = this.length;
              if (t % 2 != 0)
                throw new RangeError(
                  "Buffer size must be a multiple of 16-bits"
                );
              for (var e = 0; e < t; e += 2) p(this, e, e + 1);
              return this;
            }),
            (o.prototype.swap32 = function () {
              var t = this.length;
              if (t % 4 != 0)
                throw new RangeError(
                  "Buffer size must be a multiple of 32-bits"
                );
              for (var e = 0; e < t; e += 4)
                p(this, e, e + 3), p(this, e + 1, e + 2);
              return this;
            }),
            (o.prototype.swap64 = function () {
              var t = this.length;
              if (t % 8 != 0)
                throw new RangeError(
                  "Buffer size must be a multiple of 64-bits"
                );
              for (var e = 0; e < t; e += 8)
                p(this, e, e + 7),
                  p(this, e + 1, e + 6),
                  p(this, e + 2, e + 5),
                  p(this, e + 3, e + 4);
              return this;
            }),
            (o.prototype.toString = function () {
              var t = 0 | this.length;
              return 0 === t
                ? ""
                : 0 === arguments.length
                ? _(this, 0, t)
                : function (t, e, n) {
                    var i = !1;
                    if (((void 0 === e || e < 0) && (e = 0), e > this.length))
                      return "";
                    if (
                      ((void 0 === n || n > this.length) && (n = this.length),
                      n <= 0)
                    )
                      return "";
                    if (((n >>>= 0), (e >>>= 0), n <= e)) return "";
                    for (t || (t = "utf8"); ; )
                      switch (t) {
                        case "hex":
                          return (function (t, e, n) {
                            var i = t.length;
                            (!e || e < 0) && (e = 0),
                              (!n || n < 0 || n > i) && (n = i);
                            for (var r = "", o = e; o < n; ++o)
                              r += (function (t) {
                                return t < 16
                                  ? "0" + t.toString(16)
                                  : t.toString(16);
                              })(t[o]);
                            return r;
                          })(this, e, n);
                        case "utf8":
                        case "utf-8":
                          return _(this, e, n);
                        case "ascii":
                          return (function (t, e, n) {
                            var i = "";
                            n = Math.min(t.length, n);
                            for (var r = e; r < n; ++r)
                              i += String.fromCharCode(127 & t[r]);
                            return i;
                          })(this, e, n);
                        case "latin1":
                        case "binary":
                          return (function (t, e, n) {
                            var i = "";
                            n = Math.min(t.length, n);
                            for (var r = e; r < n; ++r)
                              i += String.fromCharCode(t[r]);
                            return i;
                          })(this, e, n);
                        case "base64":
                          return (function (t, e, n) {
                            return 0 === e && n === t.length
                              ? O.fromByteArray(t)
                              : O.fromByteArray(t.slice(e, n));
                          })(this, e, n);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                          return (function (t, e, n) {
                            for (
                              var i = t.slice(e, n), r = "", o = 0;
                              o < i.length;
                              o += 2
                            )
                              r += String.fromCharCode(i[o] + 256 * i[o + 1]);
                            return r;
                          })(this, e, n);
                        default:
                          if (i) throw new TypeError("Unknown encoding: " + t);
                          (t = (t + "").toLowerCase()), (i = !0);
                      }
                  }.apply(this, arguments);
            }),
            (o.prototype.equals = function (t) {
              if (!o.isBuffer(t))
                throw new TypeError("Argument must be a Buffer");
              return this === t || 0 === o.compare(this, t);
            }),
            (o.prototype.inspect = function () {
              var t = "",
                n = e.INSPECT_MAX_BYTES;
              return (
                this.length > 0 &&
                  ((t = this.toString("hex", 0, n).match(/.{2}/g).join(" ")),
                  this.length > n && (t += " ... ")),
                "<Buffer " + t + ">"
              );
            }),
            (o.prototype.compare = function (t, e, n, i, r) {
              if (!o.isBuffer(t))
                throw new TypeError("Argument must be a Buffer");
              if (
                (void 0 === e && (e = 0),
                void 0 === n && (n = t ? t.length : 0),
                void 0 === i && (i = 0),
                void 0 === r && (r = this.length),
                e < 0 || n > t.length || i < 0 || r > this.length)
              )
                throw new RangeError("out of range index");
              if (i >= r && e >= n) return 0;
              if (i >= r) return -1;
              if (e >= n) return 1;
              if (((e >>>= 0), (n >>>= 0), (i >>>= 0), (r >>>= 0), this === t))
                return 0;
              for (
                var a = r - i,
                  s = n - e,
                  c = Math.min(a, s),
                  l = this.slice(i, r),
                  u = t.slice(e, n),
                  h = 0;
                h < c;
                ++h
              )
                if (l[h] !== u[h]) {
                  (a = l[h]), (s = u[h]);
                  break;
                }
              return a < s ? -1 : s < a ? 1 : 0;
            }),
            (o.prototype.includes = function (t, e, n) {
              return -1 !== this.indexOf(t, e, n);
            }),
            (o.prototype.indexOf = function (t, e, n) {
              return d(this, t, e, n, !0);
            }),
            (o.prototype.lastIndexOf = function (t, e, n) {
              return d(this, t, e, n, !1);
            }),
            (o.prototype.write = function (t, e, n, i) {
              if (void 0 === e) (i = "utf8"), (n = this.length), (e = 0);
              else if (void 0 === n && "string" == typeof e)
                (i = e), (n = this.length), (e = 0);
              else {
                if (!isFinite(e))
                  throw new Error(
                    "Buffer.write(string, encoding, offset[, length]) is no longer supported"
                  );
                (e |= 0),
                  isFinite(n)
                    ? ((n |= 0), void 0 === i && (i = "utf8"))
                    : ((i = n), (n = void 0));
              }
              var r = this.length - e;
              if (
                ((void 0 === n || n > r) && (n = r),
                (t.length > 0 && (n < 0 || e < 0)) || e > this.length)
              )
                throw new RangeError("Attempt to write outside buffer bounds");
              i || (i = "utf8");
              for (var o = !1; ; )
                switch (i) {
                  case "hex":
                    return m(this, t, e, n);
                  case "utf8":
                  case "utf-8":
                    return g(this, t, e, n);
                  case "ascii":
                    return v(this, t, e, n);
                  case "latin1":
                  case "binary":
                    return y(this, t, e, n);
                  case "base64":
                    return x(this, t, e, n);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return b(this, t, e, n);
                  default:
                    if (o) throw new TypeError("Unknown encoding: " + i);
                    (i = ("" + i).toLowerCase()), (o = !0);
                }
            }),
            (o.prototype.toJSON = function () {
              return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0),
              };
            });
          var U = 4096;
          (o.prototype.slice = function (t, e) {
            var n = this.length;
            (t = ~~t),
              (e = void 0 === e ? n : ~~e),
              t < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n),
              e < 0 ? (e += n) < 0 && (e = 0) : e > n && (e = n),
              e < t && (e = t);
            var i;
            if (o.TYPED_ARRAY_SUPPORT)
              (i = this.subarray(t, e)), (i.__proto__ = o.prototype);
            else {
              var r = e - t;
              i = new o(r, void 0);
              for (var a = 0; a < r; ++a) i[a] = this[a + t];
            }
            return i;
          }),
            (o.prototype.readUIntLE = function (t, e, n) {
              (t |= 0), (e |= 0), n || w(t, e, this.length);
              for (var i = this[t], r = 1, o = 0; ++o < e && (r *= 256); )
                i += this[t + o] * r;
              return i;
            }),
            (o.prototype.readUIntBE = function (t, e, n) {
              (t |= 0), (e |= 0), n || w(t, e, this.length);
              for (var i = this[t + --e], r = 1; e > 0 && (r *= 256); )
                i += this[t + --e] * r;
              return i;
            }),
            (o.prototype.readUInt8 = function (t, e) {
              return e || w(t, 1, this.length), this[t];
            }),
            (o.prototype.readUInt16LE = function (t, e) {
              return e || w(t, 2, this.length), this[t] | (this[t + 1] << 8);
            }),
            (o.prototype.readUInt16BE = function (t, e) {
              return e || w(t, 2, this.length), (this[t] << 8) | this[t + 1];
            }),
            (o.prototype.readUInt32LE = function (t, e) {
              return (
                e || w(t, 4, this.length),
                (this[t] | (this[t + 1] << 8) | (this[t + 2] << 16)) +
                  16777216 * this[t + 3]
              );
            }),
            (o.prototype.readUInt32BE = function (t, e) {
              return (
                e || w(t, 4, this.length),
                16777216 * this[t] +
                  ((this[t + 1] << 16) | (this[t + 2] << 8) | this[t + 3])
              );
            }),
            (o.prototype.readIntLE = function (t, e, n) {
              (t |= 0), (e |= 0), n || w(t, e, this.length);
              for (var i = this[t], r = 1, o = 0; ++o < e && (r *= 256); )
                i += this[t + o] * r;
              return (r *= 128), i >= r && (i -= Math.pow(2, 8 * e)), i;
            }),
            (o.prototype.readIntBE = function (t, e, n) {
              (t |= 0), (e |= 0), n || w(t, e, this.length);
              for (var i = e, r = 1, o = this[t + --i]; i > 0 && (r *= 256); )
                o += this[t + --i] * r;
              return (r *= 128), o >= r && (o -= Math.pow(2, 8 * e)), o;
            }),
            (o.prototype.readInt8 = function (t, e) {
              return (
                e || w(t, 1, this.length),
                128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
              );
            }),
            (o.prototype.readInt16LE = function (t, e) {
              e || w(t, 2, this.length);
              var n = this[t] | (this[t + 1] << 8);
              return 32768 & n ? 4294901760 | n : n;
            }),
            (o.prototype.readInt16BE = function (t, e) {
              e || w(t, 2, this.length);
              var n = this[t + 1] | (this[t] << 8);
              return 32768 & n ? 4294901760 | n : n;
            }),
            (o.prototype.readInt32LE = function (t, e) {
              return (
                e || w(t, 4, this.length),
                this[t] |
                  (this[t + 1] << 8) |
                  (this[t + 2] << 16) |
                  (this[t + 3] << 24)
              );
            }),
            (o.prototype.readInt32BE = function (t, e) {
              return (
                e || w(t, 4, this.length),
                (this[t] << 24) |
                  (this[t + 1] << 16) |
                  (this[t + 2] << 8) |
                  this[t + 3]
              );
            }),
            (o.prototype.readFloatLE = function (t, e) {
              return e || w(t, 4, this.length), I.read(this, t, !0, 23, 4);
            }),
            (o.prototype.readFloatBE = function (t, e) {
              return e || w(t, 4, this.length), I.read(this, t, !1, 23, 4);
            }),
            (o.prototype.readDoubleLE = function (t, e) {
              return e || w(t, 8, this.length), I.read(this, t, !0, 52, 8);
            }),
            (o.prototype.readDoubleBE = function (t, e) {
              return e || w(t, 8, this.length), I.read(this, t, !1, 52, 8);
            }),
            (o.prototype.writeUIntLE = function (t, e, n, i) {
              (t = +t),
                (e |= 0),
                (n |= 0),
                i || M(this, t, e, n, Math.pow(2, 8 * n) - 1, 0);
              var r = 1,
                o = 0;
              for (this[e] = 255 & t; ++o < n && (r *= 256); )
                this[e + o] = (t / r) & 255;
              return e + n;
            }),
            (o.prototype.writeUIntBE = function (t, e, n, i) {
              (t = +t),
                (e |= 0),
                (n |= 0),
                i || M(this, t, e, n, Math.pow(2, 8 * n) - 1, 0);
              var r = n - 1,
                o = 1;
              for (this[e + r] = 255 & t; --r >= 0 && (o *= 256); )
                this[e + r] = (t / o) & 255;
              return e + n;
            }),
            (o.prototype.writeUInt8 = function (t, e, n) {
              return (
                (t = +t),
                (e |= 0),
                n || M(this, t, e, 1, 255, 0),
                o.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)),
                (this[e] = 255 & t),
                e + 1
              );
            }),
            (o.prototype.writeUInt16LE = function (t, e, n) {
              return (
                (t = +t),
                (e |= 0),
                n || M(this, t, e, 2, 65535, 0),
                o.TYPED_ARRAY_SUPPORT
                  ? ((this[e] = 255 & t), (this[e + 1] = t >>> 8))
                  : E(this, t, e, !0),
                e + 2
              );
            }),
            (o.prototype.writeUInt16BE = function (t, e, n) {
              return (
                (t = +t),
                (e |= 0),
                n || M(this, t, e, 2, 65535, 0),
                o.TYPED_ARRAY_SUPPORT
                  ? ((this[e] = t >>> 8), (this[e + 1] = 255 & t))
                  : E(this, t, e, !1),
                e + 2
              );
            }),
            (o.prototype.writeUInt32LE = function (t, e, n) {
              return (
                (t = +t),
                (e |= 0),
                n || M(this, t, e, 4, 4294967295, 0),
                o.TYPED_ARRAY_SUPPORT
                  ? ((this[e + 3] = t >>> 24),
                    (this[e + 2] = t >>> 16),
                    (this[e + 1] = t >>> 8),
                    (this[e] = 255 & t))
                  : T(this, t, e, !0),
                e + 4
              );
            }),
            (o.prototype.writeUInt32BE = function (t, e, n) {
              return (
                (t = +t),
                (e |= 0),
                n || M(this, t, e, 4, 4294967295, 0),
                o.TYPED_ARRAY_SUPPORT
                  ? ((this[e] = t >>> 24),
                    (this[e + 1] = t >>> 16),
                    (this[e + 2] = t >>> 8),
                    (this[e + 3] = 255 & t))
                  : T(this, t, e, !1),
                e + 4
              );
            }),
            (o.prototype.writeIntLE = function (t, e, n, i) {
              if (((t = +t), (e |= 0), !i)) {
                var r = Math.pow(2, 8 * n - 1);
                M(this, t, e, n, r - 1, -r);
              }
              var o = 0,
                a = 1,
                s = 0;
              for (this[e] = 255 & t; ++o < n && (a *= 256); )
                t < 0 && 0 === s && 0 !== this[e + o - 1] && (s = 1),
                  (this[e + o] = (((t / a) >> 0) - s) & 255);
              return e + n;
            }),
            (o.prototype.writeIntBE = function (t, e, n, i) {
              if (((t = +t), (e |= 0), !i)) {
                var r = Math.pow(2, 8 * n - 1);
                M(this, t, e, n, r - 1, -r);
              }
              var o = n - 1,
                a = 1,
                s = 0;
              for (this[e + o] = 255 & t; --o >= 0 && (a *= 256); )
                t < 0 && 0 === s && 0 !== this[e + o + 1] && (s = 1),
                  (this[e + o] = (((t / a) >> 0) - s) & 255);
              return e + n;
            }),
            (o.prototype.writeInt8 = function (t, e, n) {
              return (
                (t = +t),
                (e |= 0),
                n || M(this, t, e, 1, 127, -128),
                o.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)),
                t < 0 && (t = 255 + t + 1),
                (this[e] = 255 & t),
                e + 1
              );
            }),
            (o.prototype.writeInt16LE = function (t, e, n) {
              return (
                (t = +t),
                (e |= 0),
                n || M(this, t, e, 2, 32767, -32768),
                o.TYPED_ARRAY_SUPPORT
                  ? ((this[e] = 255 & t), (this[e + 1] = t >>> 8))
                  : E(this, t, e, !0),
                e + 2
              );
            }),
            (o.prototype.writeInt16BE = function (t, e, n) {
              return (
                (t = +t),
                (e |= 0),
                n || M(this, t, e, 2, 32767, -32768),
                o.TYPED_ARRAY_SUPPORT
                  ? ((this[e] = t >>> 8), (this[e + 1] = 255 & t))
                  : E(this, t, e, !1),
                e + 2
              );
            }),
            (o.prototype.writeInt32LE = function (t, e, n) {
              return (
                (t = +t),
                (e |= 0),
                n || M(this, t, e, 4, 2147483647, -2147483648),
                o.TYPED_ARRAY_SUPPORT
                  ? ((this[e] = 255 & t),
                    (this[e + 1] = t >>> 8),
                    (this[e + 2] = t >>> 16),
                    (this[e + 3] = t >>> 24))
                  : T(this, t, e, !0),
                e + 4
              );
            }),
            (o.prototype.writeInt32BE = function (t, e, n) {
              return (
                (t = +t),
                (e |= 0),
                n || M(this, t, e, 4, 2147483647, -2147483648),
                t < 0 && (t = 4294967295 + t + 1),
                o.TYPED_ARRAY_SUPPORT
                  ? ((this[e] = t >>> 24),
                    (this[e + 1] = t >>> 16),
                    (this[e + 2] = t >>> 8),
                    (this[e + 3] = 255 & t))
                  : T(this, t, e, !1),
                e + 4
              );
            }),
            (o.prototype.writeFloatLE = function (t, e, n) {
              return A(this, t, e, !0, n);
            }),
            (o.prototype.writeFloatBE = function (t, e, n) {
              return A(this, t, e, !1, n);
            }),
            (o.prototype.writeDoubleLE = function (t, e, n) {
              return L(this, t, e, !0, n);
            }),
            (o.prototype.writeDoubleBE = function (t, e, n) {
              return L(this, t, e, !1, n);
            }),
            (o.prototype.copy = function (t, e, n, i) {
              if (
                (n || (n = 0),
                i || 0 === i || (i = this.length),
                e >= t.length && (e = t.length),
                e || (e = 0),
                i > 0 && i < n && (i = n),
                i === n)
              )
                return 0;
              if (0 === t.length || 0 === this.length) return 0;
              if (e < 0) throw new RangeError("targetStart out of bounds");
              if (n < 0 || n >= this.length)
                throw new RangeError("sourceStart out of bounds");
              if (i < 0) throw new RangeError("sourceEnd out of bounds");
              i > this.length && (i = this.length),
                t.length - e < i - n && (i = t.length - e + n);
              var r,
                a = i - n;
              if (this === t && n < e && e < i)
                for (r = a - 1; r >= 0; --r) t[r + e] = this[r + n];
              else if (a < 1e3 || !o.TYPED_ARRAY_SUPPORT)
                for (r = 0; r < a; ++r) t[r + e] = this[r + n];
              else Uint8Array.prototype.set.call(t, this.subarray(n, n + a), e);
              return a;
            }),
            (o.prototype.fill = function (t, e, n, i) {
              if ("string" == typeof t) {
                if (
                  ("string" == typeof e
                    ? ((i = e), (e = 0), (n = this.length))
                    : "string" == typeof n && ((i = n), (n = this.length)),
                  1 === t.length)
                ) {
                  var r = t.charCodeAt(0);
                  r < 256 && (t = r);
                }
                if (void 0 !== i && "string" != typeof i)
                  throw new TypeError("encoding must be a string");
                if ("string" == typeof i && !o.isEncoding(i))
                  throw new TypeError("Unknown encoding: " + i);
              } else "number" == typeof t && (t &= 255);
              if (e < 0 || this.length < e || this.length < n)
                throw new RangeError("Out of range index");
              if (n <= e) return this;
              (e >>>= 0),
                (n = void 0 === n ? this.length : n >>> 0),
                t || (t = 0);
              var a;
              if ("number" == typeof t) for (a = e; a < n; ++a) this[a] = t;
              else {
                var s = o.isBuffer(t) ? t : R(new o(t, i).toString()),
                  c = s.length;
                for (a = 0; a < n - e; ++a) this[a + e] = s[a % c];
              }
              return this;
            });
          var N = /[^+\/0-9A-Za-z-_]/g;
        }.call(e, n(49)));
      },
      function (t, e, n) {
        (t.exports = n(1)()).push([
          t.i,
          ".guigui-colorpicker-label{font-size:12px;line-height:18px;font-style:italic;text-align:center;overflow:hidden;text-overflow:ellipsis;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;float:left;width:calc(31.5% - 20px);padding:0 5px;margin-right:10px}.guigui-colorpicker{clear:both}.guigui-colorpicker-state{background:#b89089;width:calc(68.5% - 8px);height:10px;float:left;padding:4px;box-shadow:inset 0 1px 8px rgba(0,0,0,.2),inset 0 -1px 1px hsla(0,0%,100%,.0980392)}.guigui-colorpicker-text{color:#000;background:none;font-size:11px;line-height:12px;font-family:Arial;margin:0;border:0;padding:3px 0;display:inline-block;vertical-align:middle;white-space:normal;box-sizing:content-box;outline:0;position:relative;top:-4px}@-moz-document url-prefix(){.guigui-colorpicker-text{top:-6px}}.guigui-colorpicker .Scp{padding:5px;background:#30343c;width:175px;height:150px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:absolute;z-index:999;top:26px;right:4px;display:none;box-shadow:inset 0 1px 1px hsla(0,0%,100%,.0588235);border:1px solid #1d1f24}.guigui-colorpicker .Scp-saturation{background:-webkit-linear-gradient(left,#fff,#ff2600);background:linear-gradient(90deg,#fff 0,#ff2600);position:relative;width:calc(100% - 25px);height:100%;float:left;margin-right:5px}.guigui-colorpicker .Scp-hue{width:20px;height:100%;position:relative;float:left;background:-webkit-linear-gradient(red,#f0f 17%,#00f 34%,#0ff 50%,#0f0 67%,#ff0 84%,red);background:linear-gradient(red,#f0f 17%,#00f 34%,#0ff 50%,#0f0 67%,#ff0 84%,red)}.guigui-colorpicker .Scp-brightness{width:100%;height:100%;background:-webkit-linear-gradient(hsla(0,0%,100%,0),#000);background:linear-gradient(hsla(0,0%,100%,0),#000)}.guigui-colorpicker .Scp-sbSelector{-webkit-transform:translateX(38.3152px) translateY(41.7647px);transform:translateX(38.3152px) translateY(41.7647px);background:#b89089;border:2px solid #000;position:absolute;width:14px;height:14px;border-radius:10px;top:-7px;left:-7px;box-sizing:border-box;z-index:10}.guigui-colorpicker .Scp-hSelector{-webkit-transform:translateY(146.277px);transform:translateY(146.277px);position:absolute;background:#fff;border-bottom:1px solid #000;right:-3px;width:10px;height:2px}.guigui-colorpicker--opened .Scp{display:block}",
          "",
        ]);
      },
      function (t, e, n) {
        (t.exports = n(1)()).push([
          t.i,
          ".guigui-launcher-label{font-size:12px;line-height:18px;font-style:italic;text-align:center;overflow:hidden;text-overflow:ellipsis}.guigui-launcher,.guigui-launcher-label{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.guigui-launcher{cursor:pointer}.guigui .guigui-launcher--pressed{background:#36383f}.guigui-launcher-label{text-transform:capitalize}.guigui-launcher-label span{position:relative;top:-1px;left:4px;color:#3d77eb}",
          "",
        ]);
      },
      function (t, e, n) {
        (t.exports = n(1)()).push([
          t.i,
          ".guigui-select-label{font-size:12px;line-height:18px;font-style:italic;text-align:center;overflow:hidden;text-overflow:ellipsis;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;float:left;width:calc(31.5% - 20px);padding:0 5px;margin-right:10px}.guigui-select select{width:calc(68.5% - 10px);background:#22252b;color:#3d77eb;line-height:12px;box-sizing:content-box}.guigui-select{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.guigui-select select{border:none;-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:3px 5px;border-radius:0;background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjwhRE9DVFlQRSBzdmcgIFBVQkxJQyAnLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4nICAnaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkJz48c3ZnIGhlaWdodD0iNTEycHgiIGZpbGw9IiMzRDc3RUIiIGlkPSJMYXllcl8xIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA1MTIgNTEyOyIgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIwIDAgNTEyIDUxMiIgd2lkdGg9IjUxMnB4IiB4bWw6c3BhY2U9InByZXNlcnZlIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48cGF0aCBkPSJNOTguOSwxODQuN2wxLjgsMi4xbDEzNiwxNTYuNWM0LjYsNS4zLDExLjUsOC42LDE5LjIsOC42YzcuNywwLDE0LjYtMy40LDE5LjItOC42TDQxMSwxODcuMWwyLjMtMi42ICBjMS43LTIuNSwyLjctNS41LDIuNy04LjdjMC04LjctNy40LTE1LjgtMTYuNi0xNS44djBIMTEyLjZ2MGMtOS4yLDAtMTYuNiw3LjEtMTYuNiwxNS44Qzk2LDE3OS4xLDk3LjEsMTgyLjIsOTguOSwxODQuN3oiLz48L3N2Zz4=);background-repeat:no-repeat;background-size:14px 14px;background-position:calc(100% - 2px) 50%}.guigui-select select:focus{outline:none}.guigui-select select::-moz-focus-inner{border:0}@-moz-document url-prefix(){.guigui-select select{padding:1px 5px;position:relative;top:-3px}}",
          "",
        ]);
      },
      function (t, e, n) {
        (t.exports = n(1)()).push([
          t.i,
          ".guigui-slider-label{font-size:12px;line-height:18px;font-style:italic;text-align:center;overflow:hidden;text-overflow:ellipsis;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;float:left;width:calc(29.5% - 10px);padding:0 5px}.guigui-slider-container{float:left;width:calc(50% - 20px);margin:0 10px;height:100%;position:relative;cursor:ew-resize}.guigui-slider-background,.guigui-slider-handle{position:absolute;width:100%;height:18%;top:5%;pointer-events:none}.guigui-slider-background{background:-webkit-linear-gradient(left,#3d77eb,#00d2da);background:linear-gradient(90deg,#3d77eb 0,#00d2da);pointer-events:none}.guigui-slider-handle{background:#22252b;right:0;-webkit-transform-origin:right center 0;transform-origin:right center 0}.guigui-slider-indice{color:#6b6b6b;font-size:9px;line-height:7px;bottom:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:absolute;pointer-events:none}.guigui-slider-indice.guigui-slider-indice--min{left:0}.guigui-slider-indice.guigui-slider-indice--max{right:0}.guigui-slider-value{float:left;font-family:Courier New,Arial;background:#22252b;color:#3d77eb;height:100%;line-height:1;width:20.5%;font-size:10px;text-align:center;margin:0;border:0;padding:0;display:inline-block;vertical-align:middle;white-space:normal;box-sizing:content-box;outline:0}",
          "",
        ]);
      },
      function (t, e, n) {
        (t.exports = n(1)()).push([
          t.i,
          ".guigui-text-label{font-size:12px;line-height:18px;font-style:italic;text-align:center;overflow:hidden;text-overflow:ellipsis;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;float:left;width:calc(31.5% - 20px);padding:0 5px;margin-right:10px}.guigui-text-value{width:calc(68.5% - 10px);background:#22252b;color:#3d77eb;line-height:12px;box-sizing:content-box}.guigui-text{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.guigui-text-value{float:left;height:10px;font-size:11px;text-align:left;margin:0;border:0;padding:4px 5px;display:inline-block;vertical-align:middle;white-space:normal;outline:0}",
          "",
        ]);
      },
      function (t, e, n) {
        (t.exports = n(1)()).push([
          t.i,
          ".guigui-toggler-label{font-size:12px;line-height:18px;font-style:italic;text-align:center;overflow:hidden;text-overflow:ellipsis}.guigui-toggler,.guigui-toggler-label{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.guigui-toggler{cursor:pointer}.guigui-toggler-label{float:left;width:calc(90% - 27px);padding:0 5px}.guigui-toggler-handle,.guigui-toggler-state{border-radius:2px}.guigui-toggler-state{position:relative;background:#1d1f24;height:100%;width:17px;float:left;margin:0 0 0 10px;box-shadow:0 2px 1px hsla(0,0%,100%,.0470588)}.guigui-toggler-handle{position:absolute;background:#3d77eb;width:54%;height:50%;top:25%;left:23%;display:none}.guigui-toggler--selected .guigui-toggler-handle{display:block}",
          "",
        ]);
      },
      function (t, e, n) {
        (t.exports = n(1)()).push([
          t.i,
          ".guigui-component,.guigui-folder,.guigui-panel,.guigui-toggle{border:1px solid #111;box-shadow:inset 0 1px 1px hsla(0,0%,100%,.06);background:-webkit-linear-gradient(hsla(0,0%,100%,.0196078),hsla(0,0%,100%,0)) #292c33;background:linear-gradient(hsla(0,0%,100%,.0196078),hsla(0,0%,100%,0)) #292c33}.guigui{position:absolute;z-index:999;top:10px;right:10px;width:calc(100% - 20px);color:#fff}.guigui-container{margin-top:30px;display:none}.guigui-container--opened{display:block}.guigui-component,.guigui-folder,.guigui-panel{box-sizing:border-box;padding:5px;position:relative}.guigui-folder,.guigui-panel{background:-webkit-linear-gradient(hsla(0,0%,100%,.0196078),hsla(0,0%,100%,0)) #22252b;background:linear-gradient(hsla(0,0%,100%,.0196078),hsla(0,0%,100%,0)) #22252b}.guigui-panel{width:300px;float:right;margin:10px 0 0 10px}.guigui-panel>.guigui-panel-content{display:none}.guigui-panel-label{margin:0;text-align:center;width:100%;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.guigui-panel--opened>.guigui-panel-content{display:block}.guigui-folder{margin:5px 0}.guigui-folder>.guigui-folder-content{margin-top:5px;display:none}.guigui-folder-head{padding:1px 0}.guigui-folder-label{margin:0;text-align:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.guigui-folder--opened>.guigui-folder-content{display:block}.guigui-component{margin-top:3px;height:17px;box-sizing:content-box}.guigui-component+.guigui-component{margin-top:-1px}.guigui{font-family:Arial,sans-serif;color:#bbbdc0}.guigui-folder-label,.guigui-panel-label{font-weight:400}.guigui-folder-label{font-size:13px}.guigui-panel-label{font-size:14px;line-height:21px}.guigui-toggle{position:absolute;top:0;right:0;width:30px;height:30px}.guigui-toggle-line{-webkit-transition:-webkit-transform .5s cubic-bezier(.19,1,.22,1);transition:-webkit-transform .5s cubic-bezier(.19,1,.22,1);transition:transform .5s cubic-bezier(.19,1,.22,1);transition:transform .5s cubic-bezier(.19,1,.22,1),-webkit-transform .5s cubic-bezier(.19,1,.22,1)}.guigui-toggle--opened .guigui-toggle-line{-webkit-transform:translate3d(-50%,-50%,1px) rotate(45deg);transform:translate3d(-50%,-50%,1px) rotate(45deg)}.guigui-toggle--opened .guigui-toggle-line:first-child{-webkit-transform:translate3d(-50%,-50%,1px) rotate(135deg);transform:translate3d(-50%,-50%,1px) rotate(135deg)}.guigui-folder-head,.guigui-panel-head,.guigui-toggle{cursor:pointer}.guigui-folder-toggle,.guigui-panel-toggle{position:absolute}.guigui-panel-toggle{top:11px;right:11px;width:14px;height:14px}.guigui-folder-toggle{top:7px;right:7px;width:12px;height:12px}.guigui-folder-toggle-line,.guigui-panel-toggle-line,.guigui-toggle-line{position:absolute;top:50%;left:50%;-webkit-transform:translate3d(-50%,-50%,1px);transform:translate3d(-50%,-50%,1px);width:2px;height:100%;background:#3d77eb}.guigui-folder-toggle-line:first-child,.guigui-panel-toggle-line:first-child,.guigui-toggle-line:first-child{-webkit-transform:translate3d(-50%,-50%,1px) rotate(90deg);transform:translate3d(-50%,-50%,1px) rotate(90deg)}.guigui-toggle-line{height:60%}.guigui-folder>.guigui-folder-head .guigui-folder-toggle-line:last-child{display:block}.guigui-folder--opened>.guigui-folder-head .guigui-folder-toggle-line:last-child{display:none}",
          "",
        ]);
      },
      function (t, e, n) {
        "use strict";
        function i() {
          return Object.keys(a).map(function (t) {
            return t;
          });
        }
        var r = n(39),
          o = n(34),
          a = n(32),
          s = n(31),
          c = Object.prototype.hasOwnProperty,
          l = r("transform"),
          u = {
            x: "translateX",
            y: "translateY",
            z: "translateZ",
            origin: "transformOrigin",
          };
        ((e = t.exports =
          function (t, e) {
            var n,
              i,
              h,
              p = [];
            !(function (t) {
              var e;
              for (e in t) c.call(u, e) && ((t[u[e]] = t[e]), delete t[e]);
            })(e);
            for (n in e)
              c.call(e, n) &&
                ((i = e[n]),
                c.call(a.transform, n)
                  ? ((h = a.transform[n]),
                    o(i) && (i = i.join(h.separator)),
                    p.push(n + "(" + s(i, h.defaultUnit, h.separator) + ")"))
                  : c.call(a, n)
                  ? ((h = a[n]),
                    o(i) && (i = i.join(h.separator)),
                    (t.style[r(n)] = s(i, h.defaultUnit, h.separator)))
                  : console.warn(
                      "dom-transform: this property (`" +
                        n +
                        "`) is not supported."
                    ));
            t.style[l] = p.join(" ");
          }).get = function (t, e) {
          var n = t.style;
          if ("string" == typeof e)
            return c.call(a.transform, e) ? n[l] : n[r(e)];
          e || (e = i());
          var o = {};
          return (
            e.forEach(function (t) {
              o[t] = n[r(t)];
            }),
            o
          );
        }),
          (e.reset = function (t, e) {
            var n = t.style;
            return "string" == typeof e
              ? void (n[r(e)] = null)
              : (e || (e = i()),
                void e.forEach(function (t) {
                  n[r(t)] = null;
                }));
          }),
          (e.isSupported = function () {
            return l.length > 0;
          });
      },
      function (t, e, n) {
        "use strict";
        var i = n(48),
          r = /^-?\d+(\.\d+)?$/;
        t.exports = function (t, e, n) {
          if (((n = n || ","), "number" == typeof t)) return "" + t + e;
          var o = new RegExp(n, "g");
          return t
            .split(o.test(t) ? n : " ")
            .map(function (t) {
              return (t = i(t)), r.test(t) && (t += e), t;
            })
            .join(n);
        };
      },
      function (t, e, n) {
        "use strict";
        t.exports = {
          transform: {
            translate: { defaultUnit: "px" },
            translate3d: { defaultUnit: "px" },
            translateX: { defaultUnit: "px" },
            translateY: { defaultUnit: "px" },
            translateZ: { defaultUnit: "px" },
            scale: { defaultUnit: "" },
            scale3d: { defaultUnit: "" },
            scaleX: { defaultUnit: "" },
            scaleY: { defaultUnit: "" },
            scaleZ: { defaultUnit: "" },
            rotate: { defaultUnit: "deg" },
            rotate3d: { defaultUnit: "" },
            rotateX: { defaultUnit: "deg" },
            rotateY: { defaultUnit: "deg" },
            rotateZ: { defaultUnit: "deg" },
            skew: { defaultUnit: "deg" },
            skewX: { defaultUnit: "deg" },
            skewY: { defaultUnit: "deg" },
            perspective: { defaultUnit: "px" },
            matrix: { defaultUnit: "" },
            matrix3d: { defaultUnit: "" },
          },
          transformOrigin: { defaultUnit: "px", separator: " " },
        };
      },
      function (t, e) {
        (e.read = function (t, e, n, i, r) {
          var o,
            a,
            s = 8 * r - i - 1,
            c = (1 << s) - 1,
            l = c >> 1,
            u = -7,
            h = n ? r - 1 : 0,
            p = n ? -1 : 1,
            d = t[e + h];
          for (
            h += p, o = d & ((1 << -u) - 1), d >>= -u, u += s;
            u > 0;
            o = 256 * o + t[e + h], h += p, u -= 8
          );
          for (
            a = o & ((1 << -u) - 1), o >>= -u, u += i;
            u > 0;
            a = 256 * a + t[e + h], h += p, u -= 8
          );
          if (0 === o) o = 1 - l;
          else {
            if (o === c) return a ? NaN : (1 / 0) * (d ? -1 : 1);
            (a += Math.pow(2, i)), (o -= l);
          }
          return (d ? -1 : 1) * a * Math.pow(2, o - i);
        }),
          (e.write = function (t, e, n, i, r, o) {
            var a,
              s,
              c,
              l = 8 * o - r - 1,
              u = (1 << l) - 1,
              h = u >> 1,
              p = 23 === r ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
              d = i ? 0 : o - 1,
              f = i ? 1 : -1,
              m = e < 0 || (0 === e && 1 / e < 0) ? 1 : 0;
            for (
              e = Math.abs(e),
                isNaN(e) || e === 1 / 0
                  ? ((s = isNaN(e) ? 1 : 0), (a = u))
                  : ((a = Math.floor(Math.log(e) / Math.LN2)),
                    e * (c = Math.pow(2, -a)) < 1 && (a--, (c *= 2)),
                    (e += a + h >= 1 ? p / c : p * Math.pow(2, 1 - h)) * c >=
                      2 && (a++, (c /= 2)),
                    a + h >= u
                      ? ((s = 0), (a = u))
                      : a + h >= 1
                      ? ((s = (e * c - 1) * Math.pow(2, r)), (a += h))
                      : ((s = e * Math.pow(2, h - 1) * Math.pow(2, r)),
                        (a = 0)));
              r >= 8;
              t[n + d] = 255 & s, d += f, s /= 256, r -= 8
            );
            for (
              a = (a << r) | s, l += r;
              l > 0;
              t[n + d] = 255 & a, d += f, a /= 256, l -= 8
            );
            t[n + d - f] |= 128 * m;
          });
      },
      function (t, e) {
        var n = Array.isArray,
          i = Object.prototype.toString;
        t.exports =
          n ||
          function (t) {
            return !!t && "[object Array]" == i.call(t);
          };
      },
      function (t, e) {
        function n(t) {
          return (
            !!t.constructor &&
            "function" == typeof t.constructor.isBuffer &&
            t.constructor.isBuffer(t)
          );
        }
        t.exports = function (t) {
          return (
            null != t &&
            (n(t) ||
              (function (t) {
                return (
                  "function" == typeof t.readFloatLE &&
                  "function" == typeof t.slice &&
                  n(t.slice(0, 0))
                );
              })(t) ||
              !!t._isBuffer)
          );
        };
      },
      function (t, e, n) {
        "use strict";
        var i = n(38);
        t.exports = function (t) {
          var e = i(t);
          if ("string" === e) {
            if (!t.trim()) return !1;
          } else if ("number" !== e) return !1;
          return t - t + 1 >= 0;
        };
      },
      function (t, e) {
        var n = {}.toString;
        t.exports =
          Array.isArray ||
          function (t) {
            return "[object Array]" == n.call(t);
          };
      },
      function (t, e, n) {
        (function (e) {
          var i = n(35),
            r = Object.prototype.toString;
          t.exports = function (t) {
            if (void 0 === t) return "undefined";
            if (null === t) return "null";
            if (!0 === t || !1 === t || t instanceof Boolean) return "boolean";
            if ("string" == typeof t || t instanceof String) return "string";
            if ("number" == typeof t || t instanceof Number) return "number";
            if ("function" == typeof t || t instanceof Function)
              return "function";
            if (void 0 !== Array.isArray && Array.isArray(t)) return "array";
            if (t instanceof RegExp) return "regexp";
            if (t instanceof Date) return "date";
            var n = r.call(t);
            return "[object RegExp]" === n
              ? "regexp"
              : "[object Date]" === n
              ? "date"
              : "[object Arguments]" === n
              ? "arguments"
              : "[object Error]" === n
              ? "error"
              : void 0 !== e && i(t)
              ? "buffer"
              : "[object Set]" === n
              ? "set"
              : "[object WeakSet]" === n
              ? "weakset"
              : "[object Map]" === n
              ? "map"
              : "[object WeakMap]" === n
              ? "weakmap"
              : "[object Symbol]" === n
              ? "symbol"
              : "[object Int8Array]" === n
              ? "int8array"
              : "[object Uint8Array]" === n
              ? "uint8array"
              : "[object Uint8ClampedArray]" === n
              ? "uint8clampedarray"
              : "[object Int16Array]" === n
              ? "int16array"
              : "[object Uint16Array]" === n
              ? "uint16array"
              : "[object Int32Array]" === n
              ? "int32array"
              : "[object Uint32Array]" === n
              ? "uint32array"
              : "[object Float32Array]" === n
              ? "float32array"
              : "[object Float64Array]" === n
              ? "float64array"
              : "object";
          };
        }.call(e, n(22).Buffer));
      },
      function (t, e) {
        function n(t) {
          if (
            ((t = t.replace(/-([a-z])/g, function (t, e) {
              return e.toUpperCase();
            })),
            void 0 !== i[t])
          )
            return t;
          for (
            var e = t.charAt(0).toUpperCase() + t.slice(1), n = r.length;
            n--;

          ) {
            var o = r[n] + e;
            if (void 0 !== i[o]) return o;
          }
          return t;
        }
        var i =
            "undefined" != typeof document
              ? document.createElement("p").style
              : {},
          r = ["O", "ms", "Moz", "Webkit"],
          o = /([A-Z])/g,
          a = {};
        (t.exports = function (t) {
          return t in a ? a[t] : (a[t] = n(t));
        }),
          (t.exports.dash = function (t) {
            return (
              (t = n(t)),
              o.test(t) && ((t = "-" + t.replace(o, "-$1")), (o.lastIndex = 0)),
              t.toLowerCase()
            );
          });
      },
      function (t, e, n) {
        "use strict";
        !(function () {
          function e(t) {
            return (
              (t = t || {}),
              (this.color = null),
              (this.width = 0),
              (this.widthUnits = "px"),
              (this.height = 0),
              (this.heightUnits = "px"),
              (this.hue = 0),
              (this.position = { x: 0, y: 0 }),
              (this.huePosition = 0),
              (this.saturationWidth = 0),
              (this.hueHeight = 0),
              (this.maxHue = 0),
              (this.inputIsNumber = !1),
              (this._onSaturationMouseDown =
                this._onSaturationMouseDown.bind(this)),
              (this._onSaturationMouseMove =
                this._onSaturationMouseMove.bind(this)),
              (this._onSaturationMouseUp =
                this._onSaturationMouseUp.bind(this)),
              (this._onHueMouseDown = this._onHueMouseDown.bind(this)),
              (this._onHueMouseMove = this._onHueMouseMove.bind(this)),
              (this._onHueMouseUp = this._onHueMouseUp.bind(this)),
              (this.$el = document.createElement("div")),
              (this.$el.className = "Scp"),
              (this.$el.innerHTML = [
                '<div class="Scp-saturation">',
                '<div class="Scp-brightness"></div>',
                '<div class="Scp-sbSelector"></div>',
                "</div>",
                '<div class="Scp-hue">',
                '<div class="Scp-hSelector"></div>',
                "</div>",
              ].join("")),
              (this.$saturation = this.$el.querySelector(".Scp-saturation")),
              (this.$hue = this.$el.querySelector(".Scp-hue")),
              (this.$sbSelector = this.$el.querySelector(".Scp-sbSelector")),
              (this.$hSelector = this.$el.querySelector(".Scp-hSelector")),
              this.$saturation.addEventListener(
                "mousedown",
                this._onSaturationMouseDown
              ),
              this.$saturation.addEventListener(
                "touchstart",
                this._onSaturationMouseDown
              ),
              this.$hue.addEventListener("mousedown", this._onHueMouseDown),
              this.$hue.addEventListener("touchstart", this._onHueMouseDown),
              t.el && this.appendTo(t.el),
              t.background && this.setBackgroundColor(t.background),
              t.widthUnits && (this.widthUnits = t.widthUnits),
              t.heightUnits && (this.heightUnits = t.heightUnits),
              this.setSize(t.width || 175, t.height || 150),
              this.setColor(t.color),
              this
            );
          }
          function i(t, e, n) {
            return Math.min(Math.max(t, e), n);
          }
          function r(t) {
            return (
              (t = 0 === t.type.indexOf("touch") ? t.touches[0] : t),
              { x: t.clientX, y: t.clientY }
            );
          }
          function o(t) {
            return (t = "#" + ("00000" + (0 | t).toString(16)).substr(-6));
          }
          var a = n(8),
            s = n(36),
            c = n(47),
            l = n(30);
          a(e.prototype),
            (e.prototype.appendTo = function (t) {
              return t.appendChild(this.$el), this;
            }),
            (e.prototype.remove = function () {
              this._onSaturationMouseUp(),
                this._onHueMouseUp(),
                this.$saturation.removeEventListener(
                  "mousedown",
                  this._onSaturationMouseDown
                ),
                this.$saturation.removeEventListener(
                  "touchstart",
                  this._onSaturationMouseDown
                ),
                this.$hue.removeEventListener(
                  "mousedown",
                  this._onHueMouseDown
                ),
                this.$hue.removeEventListener(
                  "touchstart",
                  this._onHueMouseDown
                ),
                this.off(),
                this.$el.parentNode &&
                  this.$el.parentNode.removeChild(this.$el);
            }),
            (e.prototype.setColor = function (t) {
              s(t)
                ? ((this.inputIsNumber = !0), (t = o(t)))
                : (this.inputIsNumber = !1),
                (this.color = c(t));
              var e = this.color.toHsv();
              return (
                isNaN(e.h) || (this.hue = e.h),
                this._moveSelectorTo(
                  this.saturationWidth * e.s,
                  (1 - e.v) * this.hueHeight
                ),
                this._moveHueTo((1 - this.hue / 360) * this.hueHeight),
                this._updateHue(),
                this
              );
            }),
            (e.prototype.setSize = function (t, e) {
              return (
                (this.width = t),
                (this.height = e),
                (this.$el.style.width = this.width + this.widthUnits),
                (this.$el.style.height = this.height + this.heightUnits),
                (this.saturationWidth = this.width - 25),
                (this.$saturation.style.width = this.saturationWidth + "px"),
                (this.hueHeight = this.height),
                (this.maxHue = this.hueHeight - 2),
                this
              );
            }),
            (e.prototype.setBackgroundColor = function (t) {
              return (
                s(t) && (t = o(t)),
                (this.$el.style.padding = "5px"),
                (this.$el.style.background = c(t).toHexString()),
                this
              );
            }),
            (e.prototype.setNoBackground = function () {
              (this.$el.style.padding = "0px"),
                (this.$el.style.background = "none");
            }),
            (e.prototype.onChange = function (t) {
              return (
                this.on("update", t),
                this.emit("update", this.getHexString()),
                this
              );
            }),
            (e.prototype.getColor = function () {
              return this.inputIsNumber
                ? this.getHexNumber()
                : this.color.toString();
            }),
            (e.prototype.getHexString = function () {
              return this.color.toHexString().toUpperCase();
            }),
            (e.prototype.getHexNumber = function () {
              return parseInt(this.color.toHex(), 16);
            }),
            (e.prototype.getRGB = function () {
              return this.color.toRgb();
            }),
            (e.prototype.getHSV = function () {
              return this.color.toHsv();
            }),
            (e.prototype.isDark = function () {
              return this.color.isDark();
            }),
            (e.prototype.isLight = function () {
              return this.color.isLight();
            }),
            (e.prototype._moveSelectorTo = function (t, e) {
              (this.position.x = i(t, 0, this.saturationWidth)),
                (this.position.y = i(e, 0, this.hueHeight)),
                l(this.$sbSelector, { x: this.position.x, y: this.position.y });
            }),
            (e.prototype._updateColorFromPosition = function () {
              (this.color = c({
                h: this.hue,
                s: this.position.x / this.saturationWidth,
                v: 1 - this.position.y / this.hueHeight,
              })),
                this._updateColor();
            }),
            (e.prototype._moveHueTo = function (t) {
              (this.huePosition = i(t, 0, this.maxHue)),
                l(this.$hSelector, { y: this.huePosition });
            }),
            (e.prototype._updateHueFromPosition = function () {
              var t = this.color.toHsv();
              (this.hue = 360 * (1 - this.huePosition / this.maxHue)),
                (this.color = c({ h: this.hue, s: t.s, v: t.v })),
                this._updateHue();
            }),
            (e.prototype._updateHue = function () {
              var t = c({ h: this.hue, s: 1, v: 1 });
              (this.$saturation.style.background =
                "linear-gradient(to right, #fff, " + t.toHexString() + ")"),
                this._updateColor();
            }),
            (e.prototype._updateColor = function () {
              (this.$sbSelector.style.background = this.color.toHexString()),
                (this.$sbSelector.style.borderColor = this.color.isDark()
                  ? "#fff"
                  : "#000"),
                this.emit("update", this.color.toHexString());
            }),
            (e.prototype._onSaturationMouseDown = function (t) {
              var e = this.$saturation.getBoundingClientRect(),
                n = r(t).x,
                i = r(t).y;
              this._moveSelectorTo(n - e.left, i - e.top),
                this._updateColorFromPosition(),
                window.addEventListener("mouseup", this._onSaturationMouseUp),
                window.addEventListener("touchend", this._onSaturationMouseUp),
                window.addEventListener(
                  "mousemove",
                  this._onSaturationMouseMove
                ),
                window.addEventListener(
                  "touchmove",
                  this._onSaturationMouseMove
                ),
                t.preventDefault();
            }),
            (e.prototype._onSaturationMouseMove = function (t) {
              var e = this.$saturation.getBoundingClientRect(),
                n = r(t).x,
                i = r(t).y;
              this._moveSelectorTo(n - e.left, i - e.top),
                this._updateColorFromPosition();
            }),
            (e.prototype._onSaturationMouseUp = function () {
              window.removeEventListener("mouseup", this._onSaturationMouseUp),
                window.removeEventListener(
                  "touchend",
                  this._onSaturationMouseUp
                ),
                window.removeEventListener(
                  "mousemove",
                  this._onSaturationMouseMove
                ),
                window.removeEventListener(
                  "touchmove",
                  this._onSaturationMouseMove
                );
            }),
            (e.prototype._onHueMouseDown = function (t) {
              var e = this.$hue.getBoundingClientRect(),
                n = r(t).y;
              this._moveHueTo(n - e.top),
                this._updateHueFromPosition(),
                window.addEventListener("mouseup", this._onHueMouseUp),
                window.addEventListener("touchend", this._onHueMouseUp),
                window.addEventListener("mousemove", this._onHueMouseMove),
                window.addEventListener("touchmove", this._onHueMouseMove),
                t.preventDefault();
            }),
            (e.prototype._onHueMouseMove = function (t) {
              var e = this.$hue.getBoundingClientRect(),
                n = r(t).y;
              this._moveHueTo(n - e.top), this._updateHueFromPosition();
            }),
            (e.prototype._onHueMouseUp = function () {
              window.removeEventListener("mouseup", this._onHueMouseUp),
                window.removeEventListener("touchend", this._onHueMouseUp),
                window.removeEventListener("mousemove", this._onHueMouseMove),
                window.removeEventListener("touchmove", this._onHueMouseMove);
            }),
            void 0 !== t && t.exports && (t.exports = e);
        })();
      },
      function (t, e, n) {
        var i = n(23);
        "string" == typeof i && (i = [[t.i, i, ""]]),
          n(2)(i, {}),
          i.locals && (t.exports = i.locals);
      },
      function (t, e, n) {
        var i = n(24);
        "string" == typeof i && (i = [[t.i, i, ""]]),
          n(2)(i, {}),
          i.locals && (t.exports = i.locals);
      },
      function (t, e, n) {
        var i = n(25);
        "string" == typeof i && (i = [[t.i, i, ""]]),
          n(2)(i, {}),
          i.locals && (t.exports = i.locals);
      },
      function (t, e, n) {
        var i = n(26);
        "string" == typeof i && (i = [[t.i, i, ""]]),
          n(2)(i, {}),
          i.locals && (t.exports = i.locals);
      },
      function (t, e, n) {
        var i = n(27);
        "string" == typeof i && (i = [[t.i, i, ""]]),
          n(2)(i, {}),
          i.locals && (t.exports = i.locals);
      },
      function (t, e, n) {
        var i = n(28);
        "string" == typeof i && (i = [[t.i, i, ""]]),
          n(2)(i, {}),
          i.locals && (t.exports = i.locals);
      },
      function (t, e, n) {
        var i;
        !(function (r) {
          function o(t, e) {
            if (((t = t || ""), (e = e || {}), t instanceof o)) return t;
            if (!(this instanceof o)) return new o(t, e);
            var n = (function (t) {
              var e = { r: 0, g: 0, b: 0 },
                n = 1,
                i = null,
                r = null,
                o = null,
                a = !1,
                s = !1;
              return (
                "string" == typeof t &&
                  (t = (function (t) {
                    t = t.replace(I, "").replace(D, "").toLowerCase();
                    var e = !1;
                    if (B[t]) (t = B[t]), (e = !0);
                    else if ("transparent" == t)
                      return { r: 0, g: 0, b: 0, a: 0, format: "name" };
                    var n;
                    return (n = j.rgb.exec(t))
                      ? { r: n[1], g: n[2], b: n[3] }
                      : (n = j.rgba.exec(t))
                      ? { r: n[1], g: n[2], b: n[3], a: n[4] }
                      : (n = j.hsl.exec(t))
                      ? { h: n[1], s: n[2], l: n[3] }
                      : (n = j.hsla.exec(t))
                      ? { h: n[1], s: n[2], l: n[3], a: n[4] }
                      : (n = j.hsv.exec(t))
                      ? { h: n[1], s: n[2], v: n[3] }
                      : (n = j.hsva.exec(t))
                      ? { h: n[1], s: n[2], v: n[3], a: n[4] }
                      : (n = j.hex8.exec(t))
                      ? {
                          r: A(n[1]),
                          g: A(n[2]),
                          b: A(n[3]),
                          a: C(n[4]),
                          format: e ? "name" : "hex8",
                        }
                      : (n = j.hex6.exec(t))
                      ? {
                          r: A(n[1]),
                          g: A(n[2]),
                          b: A(n[3]),
                          format: e ? "name" : "hex",
                        }
                      : (n = j.hex4.exec(t))
                      ? {
                          r: A(n[1] + "" + n[1]),
                          g: A(n[2] + "" + n[2]),
                          b: A(n[3] + "" + n[3]),
                          a: C(n[4] + "" + n[4]),
                          format: e ? "name" : "hex8",
                        }
                      : !!(n = j.hex3.exec(t)) && {
                          r: A(n[1] + "" + n[1]),
                          g: A(n[2] + "" + n[2]),
                          b: A(n[3] + "" + n[3]),
                          format: e ? "name" : "hex",
                        };
                  })(t)),
                "object" == typeof t &&
                  (O(t.r) && O(t.g) && O(t.b)
                    ? ((e = (function (t, e, n) {
                        return {
                          r: 255 * T(t, 255),
                          g: 255 * T(e, 255),
                          b: 255 * T(n, 255),
                        };
                      })(t.r, t.g, t.b)),
                      (a = !0),
                      (s = "%" === String(t.r).substr(-1) ? "prgb" : "rgb"))
                    : O(t.h) && O(t.s) && O(t.v)
                    ? ((i = R(t.s)),
                      (r = R(t.v)),
                      (e = c(t.h, i, r)),
                      (a = !0),
                      (s = "hsv"))
                    : O(t.h) &&
                      O(t.s) &&
                      O(t.l) &&
                      ((i = R(t.s)),
                      (o = R(t.l)),
                      (e = (function (t, e, n) {
                        function i(t, e, n) {
                          return (
                            n < 0 && (n += 1),
                            n > 1 && (n -= 1),
                            n < 1 / 6
                              ? t + 6 * (e - t) * n
                              : n < 0.5
                              ? e
                              : n < 2 / 3
                              ? t + (e - t) * (2 / 3 - n) * 6
                              : t
                          );
                        }
                        var r, o, a;
                        if (
                          ((t = T(t, 360)),
                          (e = T(e, 100)),
                          (n = T(n, 100)),
                          0 === e)
                        )
                          r = o = a = n;
                        else {
                          var s = n < 0.5 ? n * (1 + e) : n + e - n * e,
                            c = 2 * n - s;
                          (r = i(c, s, t + 1 / 3)),
                            (o = i(c, s, t)),
                            (a = i(c, s, t - 1 / 3));
                        }
                        return { r: 255 * r, g: 255 * o, b: 255 * a };
                      })(t.h, i, o)),
                      (a = !0),
                      (s = "hsl")),
                  t.hasOwnProperty("a") && (n = t.a)),
                (n = E(n)),
                {
                  ok: a,
                  format: t.format || s,
                  r: z(255, k(e.r, 0)),
                  g: z(255, k(e.g, 0)),
                  b: z(255, k(e.b, 0)),
                  a: n,
                }
              );
            })(t);
            (this._originalInput = t),
              (this._r = n.r),
              (this._g = n.g),
              (this._b = n.b),
              (this._a = n.a),
              (this._roundA = N(100 * this._a) / 100),
              (this._format = e.format || n.format),
              (this._gradientType = e.gradientType),
              this._r < 1 && (this._r = N(this._r)),
              this._g < 1 && (this._g = N(this._g)),
              this._b < 1 && (this._b = N(this._b)),
              (this._ok = n.ok),
              (this._tc_id = U++);
          }
          function a(t, e, n) {
            (t = T(t, 255)), (e = T(e, 255)), (n = T(n, 255));
            var i,
              r,
              o = k(t, e, n),
              a = z(t, e, n),
              s = (o + a) / 2;
            if (o == a) i = r = 0;
            else {
              var c = o - a;
              switch (((r = s > 0.5 ? c / (2 - o - a) : c / (o + a)), o)) {
                case t:
                  i = (e - n) / c + (e < n ? 6 : 0);
                  break;
                case e:
                  i = (n - t) / c + 2;
                  break;
                case n:
                  i = (t - e) / c + 4;
              }
              i /= 6;
            }
            return { h: i, s: r, l: s };
          }
          function s(t, e, n) {
            (t = T(t, 255)), (e = T(e, 255)), (n = T(n, 255));
            var i,
              r,
              o = k(t, e, n),
              a = z(t, e, n),
              s = o - a;
            if (((r = 0 === o ? 0 : s / o), o == a)) i = 0;
            else {
              switch (o) {
                case t:
                  i = (e - n) / s + (e < n ? 6 : 0);
                  break;
                case e:
                  i = (n - t) / s + 2;
                  break;
                case n:
                  i = (t - e) / s + 4;
              }
              i /= 6;
            }
            return { h: i, s: r, v: o };
          }
          function c(t, e, n) {
            (t = 6 * T(t, 360)), (e = T(e, 100)), (n = T(n, 100));
            var i = r.floor(t),
              o = t - i,
              a = n * (1 - e),
              s = n * (1 - o * e),
              c = n * (1 - (1 - o) * e),
              l = i % 6;
            return {
              r: 255 * [n, s, a, a, c, n][l],
              g: 255 * [c, n, n, s, a, a][l],
              b: 255 * [a, a, c, n, n, s][l],
            };
          }
          function l(t, e, n, i) {
            var r = [
              L(N(t).toString(16)),
              L(N(e).toString(16)),
              L(N(n).toString(16)),
            ];
            return i &&
              r[0].charAt(0) == r[0].charAt(1) &&
              r[1].charAt(0) == r[1].charAt(1) &&
              r[2].charAt(0) == r[2].charAt(1)
              ? r[0].charAt(0) + r[1].charAt(0) + r[2].charAt(0)
              : r.join("");
          }
          function u(t, e, n, i) {
            return [
              L(P(i)),
              L(N(t).toString(16)),
              L(N(e).toString(16)),
              L(N(n).toString(16)),
            ].join("");
          }
          function h(t, e) {
            e = 0 === e ? 0 : e || 10;
            var n = o(t).toHsl();
            return (n.s -= e / 100), (n.s = S(n.s)), o(n);
          }
          function p(t, e) {
            e = 0 === e ? 0 : e || 10;
            var n = o(t).toHsl();
            return (n.s += e / 100), (n.s = S(n.s)), o(n);
          }
          function d(t) {
            return o(t).desaturate(100);
          }
          function f(t, e) {
            e = 0 === e ? 0 : e || 10;
            var n = o(t).toHsl();
            return (n.l += e / 100), (n.l = S(n.l)), o(n);
          }
          function m(t, e) {
            e = 0 === e ? 0 : e || 10;
            var n = o(t).toRgb();
            return (
              (n.r = k(0, z(255, n.r - N((-e / 100) * 255)))),
              (n.g = k(0, z(255, n.g - N((-e / 100) * 255)))),
              (n.b = k(0, z(255, n.b - N((-e / 100) * 255)))),
              o(n)
            );
          }
          function g(t, e) {
            e = 0 === e ? 0 : e || 10;
            var n = o(t).toHsl();
            return (n.l -= e / 100), (n.l = S(n.l)), o(n);
          }
          function v(t, e) {
            var n = o(t).toHsl(),
              i = (n.h + e) % 360;
            return (n.h = i < 0 ? 360 + i : i), o(n);
          }
          function y(t) {
            var e = o(t).toHsl();
            return (e.h = (e.h + 180) % 360), o(e);
          }
          function x(t) {
            var e = o(t).toHsl(),
              n = e.h;
            return [
              o(t),
              o({ h: (n + 120) % 360, s: e.s, l: e.l }),
              o({ h: (n + 240) % 360, s: e.s, l: e.l }),
            ];
          }
          function b(t) {
            var e = o(t).toHsl(),
              n = e.h;
            return [
              o(t),
              o({ h: (n + 90) % 360, s: e.s, l: e.l }),
              o({ h: (n + 180) % 360, s: e.s, l: e.l }),
              o({ h: (n + 270) % 360, s: e.s, l: e.l }),
            ];
          }
          function _(t) {
            var e = o(t).toHsl(),
              n = e.h;
            return [
              o(t),
              o({ h: (n + 72) % 360, s: e.s, l: e.l }),
              o({ h: (n + 216) % 360, s: e.s, l: e.l }),
            ];
          }
          function w(t, e, n) {
            (e = e || 6), (n = n || 30);
            var i = o(t).toHsl(),
              r = 360 / n,
              a = [o(t)];
            for (i.h = (i.h - ((r * e) >> 1) + 720) % 360; --e; )
              (i.h = (i.h + r) % 360), a.push(o(i));
            return a;
          }
          function M(t, e) {
            e = e || 6;
            for (
              var n = o(t).toHsv(),
                i = n.h,
                r = n.s,
                a = n.v,
                s = [],
                c = 1 / e;
              e--;

            )
              s.push(o({ h: i, s: r, v: a })), (a = (a + c) % 1);
            return s;
          }
          function E(t) {
            return (
              (t = parseFloat(t)), (isNaN(t) || t < 0 || t > 1) && (t = 1), t
            );
          }
          function T(t, e) {
            (function (t) {
              return (
                "string" == typeof t &&
                -1 != t.indexOf(".") &&
                1 === parseFloat(t)
              );
            })(t) && (t = "100%");
            var n = (function (t) {
              return "string" == typeof t && -1 != t.indexOf("%");
            })(t);
            return (
              (t = z(e, k(0, parseFloat(t)))),
              n && (t = parseInt(t * e, 10) / 100),
              r.abs(t - e) < 1e-6 ? 1 : (t % e) / parseFloat(e)
            );
          }
          function S(t) {
            return z(1, k(0, t));
          }
          function A(t) {
            return parseInt(t, 16);
          }
          function L(t) {
            return 1 == t.length ? "0" + t : "" + t;
          }
          function R(t) {
            return t <= 1 && (t = 100 * t + "%"), t;
          }
          function P(t) {
            return r.round(255 * parseFloat(t)).toString(16);
          }
          function C(t) {
            return A(t) / 255;
          }
          function O(t) {
            return !!j.CSS_UNIT.exec(t);
          }
          var I = /^\s+/,
            D = /\s+$/,
            U = 0,
            N = r.round,
            z = r.min,
            k = r.max,
            F = r.random;
          (o.prototype = {
            isDark: function () {
              return this.getBrightness() < 128;
            },
            isLight: function () {
              return !this.isDark();
            },
            isValid: function () {
              return this._ok;
            },
            getOriginalInput: function () {
              return this._originalInput;
            },
            getFormat: function () {
              return this._format;
            },
            getAlpha: function () {
              return this._a;
            },
            getBrightness: function () {
              var t = this.toRgb();
              return (299 * t.r + 587 * t.g + 114 * t.b) / 1e3;
            },
            getLuminance: function () {
              var t,
                e,
                n,
                i,
                o,
                a,
                s = this.toRgb();
              return (
                (t = s.r / 255),
                (e = s.g / 255),
                (n = s.b / 255),
                (i =
                  t <= 0.03928 ? t / 12.92 : r.pow((t + 0.055) / 1.055, 2.4)),
                (o =
                  e <= 0.03928 ? e / 12.92 : r.pow((e + 0.055) / 1.055, 2.4)),
                (a =
                  n <= 0.03928 ? n / 12.92 : r.pow((n + 0.055) / 1.055, 2.4)),
                0.2126 * i + 0.7152 * o + 0.0722 * a
              );
            },
            setAlpha: function (t) {
              return (
                (this._a = E(t)), (this._roundA = N(100 * this._a) / 100), this
              );
            },
            toHsv: function () {
              var t = s(this._r, this._g, this._b);
              return { h: 360 * t.h, s: t.s, v: t.v, a: this._a };
            },
            toHsvString: function () {
              var t = s(this._r, this._g, this._b),
                e = N(360 * t.h),
                n = N(100 * t.s),
                i = N(100 * t.v);
              return 1 == this._a
                ? "hsv(" + e + ", " + n + "%, " + i + "%)"
                : "hsva(" +
                    e +
                    ", " +
                    n +
                    "%, " +
                    i +
                    "%, " +
                    this._roundA +
                    ")";
            },
            toHsl: function () {
              var t = a(this._r, this._g, this._b);
              return { h: 360 * t.h, s: t.s, l: t.l, a: this._a };
            },
            toHslString: function () {
              var t = a(this._r, this._g, this._b),
                e = N(360 * t.h),
                n = N(100 * t.s),
                i = N(100 * t.l);
              return 1 == this._a
                ? "hsl(" + e + ", " + n + "%, " + i + "%)"
                : "hsla(" +
                    e +
                    ", " +
                    n +
                    "%, " +
                    i +
                    "%, " +
                    this._roundA +
                    ")";
            },
            toHex: function (t) {
              return l(this._r, this._g, this._b, t);
            },
            toHexString: function (t) {
              return "#" + this.toHex(t);
            },
            toHex8: function (t) {
              return (function (t, e, n, i, r) {
                var o = [
                  L(N(t).toString(16)),
                  L(N(e).toString(16)),
                  L(N(n).toString(16)),
                  L(P(i)),
                ];
                return r &&
                  o[0].charAt(0) == o[0].charAt(1) &&
                  o[1].charAt(0) == o[1].charAt(1) &&
                  o[2].charAt(0) == o[2].charAt(1) &&
                  o[3].charAt(0) == o[3].charAt(1)
                  ? o[0].charAt(0) +
                      o[1].charAt(0) +
                      o[2].charAt(0) +
                      o[3].charAt(0)
                  : o.join("");
              })(this._r, this._g, this._b, this._a, t);
            },
            toHex8String: function (t) {
              return "#" + this.toHex8(t);
            },
            toRgb: function () {
              return {
                r: N(this._r),
                g: N(this._g),
                b: N(this._b),
                a: this._a,
              };
            },
            toRgbString: function () {
              return 1 == this._a
                ? "rgb(" +
                    N(this._r) +
                    ", " +
                    N(this._g) +
                    ", " +
                    N(this._b) +
                    ")"
                : "rgba(" +
                    N(this._r) +
                    ", " +
                    N(this._g) +
                    ", " +
                    N(this._b) +
                    ", " +
                    this._roundA +
                    ")";
            },
            toPercentageRgb: function () {
              return {
                r: N(100 * T(this._r, 255)) + "%",
                g: N(100 * T(this._g, 255)) + "%",
                b: N(100 * T(this._b, 255)) + "%",
                a: this._a,
              };
            },
            toPercentageRgbString: function () {
              return 1 == this._a
                ? "rgb(" +
                    N(100 * T(this._r, 255)) +
                    "%, " +
                    N(100 * T(this._g, 255)) +
                    "%, " +
                    N(100 * T(this._b, 255)) +
                    "%)"
                : "rgba(" +
                    N(100 * T(this._r, 255)) +
                    "%, " +
                    N(100 * T(this._g, 255)) +
                    "%, " +
                    N(100 * T(this._b, 255)) +
                    "%, " +
                    this._roundA +
                    ")";
            },
            toName: function () {
              return 0 === this._a
                ? "transparent"
                : !(this._a < 1) && (H[l(this._r, this._g, this._b, !0)] || !1);
            },
            toFilter: function (t) {
              var e = "#" + u(this._r, this._g, this._b, this._a),
                n = e,
                i = this._gradientType ? "GradientType = 1, " : "";
              if (t) {
                var r = o(t);
                n = "#" + u(r._r, r._g, r._b, r._a);
              }
              return (
                "progid:DXImageTransform.Microsoft.gradient(" +
                i +
                "startColorstr=" +
                e +
                ",endColorstr=" +
                n +
                ")"
              );
            },
            toString: function (t) {
              var e = !!t;
              t = t || this._format;
              var n = !1,
                i = this._a < 1 && this._a >= 0;
              return e ||
                !i ||
                ("hex" !== t &&
                  "hex6" !== t &&
                  "hex3" !== t &&
                  "hex4" !== t &&
                  "hex8" !== t &&
                  "name" !== t)
                ? ("rgb" === t && (n = this.toRgbString()),
                  "prgb" === t && (n = this.toPercentageRgbString()),
                  ("hex" !== t && "hex6" !== t) || (n = this.toHexString()),
                  "hex3" === t && (n = this.toHexString(!0)),
                  "hex4" === t && (n = this.toHex8String(!0)),
                  "hex8" === t && (n = this.toHex8String()),
                  "name" === t && (n = this.toName()),
                  "hsl" === t && (n = this.toHslString()),
                  "hsv" === t && (n = this.toHsvString()),
                  n || this.toHexString())
                : "name" === t && 0 === this._a
                ? this.toName()
                : this.toRgbString();
            },
            clone: function () {
              return o(this.toString());
            },
            _applyModification: function (t, e) {
              var n = t.apply(null, [this].concat([].slice.call(e)));
              return (
                (this._r = n._r),
                (this._g = n._g),
                (this._b = n._b),
                this.setAlpha(n._a),
                this
              );
            },
            lighten: function () {
              return this._applyModification(f, arguments);
            },
            brighten: function () {
              return this._applyModification(m, arguments);
            },
            darken: function () {
              return this._applyModification(g, arguments);
            },
            desaturate: function () {
              return this._applyModification(h, arguments);
            },
            saturate: function () {
              return this._applyModification(p, arguments);
            },
            greyscale: function () {
              return this._applyModification(d, arguments);
            },
            spin: function () {
              return this._applyModification(v, arguments);
            },
            _applyCombination: function (t, e) {
              return t.apply(null, [this].concat([].slice.call(e)));
            },
            analogous: function () {
              return this._applyCombination(w, arguments);
            },
            complement: function () {
              return this._applyCombination(y, arguments);
            },
            monochromatic: function () {
              return this._applyCombination(M, arguments);
            },
            splitcomplement: function () {
              return this._applyCombination(_, arguments);
            },
            triad: function () {
              return this._applyCombination(x, arguments);
            },
            tetrad: function () {
              return this._applyCombination(b, arguments);
            },
          }),
            (o.fromRatio = function (t, e) {
              if ("object" == typeof t) {
                var n = {};
                for (var i in t)
                  t.hasOwnProperty(i) && (n[i] = "a" === i ? t[i] : R(t[i]));
                t = n;
              }
              return o(t, e);
            }),
            (o.equals = function (t, e) {
              return !(!t || !e) && o(t).toRgbString() == o(e).toRgbString();
            }),
            (o.random = function () {
              return o.fromRatio({ r: F(), g: F(), b: F() });
            }),
            (o.mix = function (t, e, n) {
              n = 0 === n ? 0 : n || 50;
              var i = o(t).toRgb(),
                r = o(e).toRgb(),
                a = n / 100;
              return o({
                r: (r.r - i.r) * a + i.r,
                g: (r.g - i.g) * a + i.g,
                b: (r.b - i.b) * a + i.b,
                a: (r.a - i.a) * a + i.a,
              });
            }),
            (o.readability = function (t, e) {
              var n = o(t),
                i = o(e);
              return (
                (r.max(n.getLuminance(), i.getLuminance()) + 0.05) /
                (r.min(n.getLuminance(), i.getLuminance()) + 0.05)
              );
            }),
            (o.isReadable = function (t, e, n) {
              var i,
                r,
                a = o.readability(t, e);
              switch (
                ((r = !1),
                (i = (function (t) {
                  var e, n;
                  return (
                    (t = t || { level: "AA", size: "small" }),
                    (e = (t.level || "AA").toUpperCase()),
                    (n = (t.size || "small").toLowerCase()),
                    "AA" !== e && "AAA" !== e && (e = "AA"),
                    "small" !== n && "large" !== n && (n = "small"),
                    { level: e, size: n }
                  );
                })(n)).level + i.size)
              ) {
                case "AAsmall":
                case "AAAlarge":
                  r = a >= 4.5;
                  break;
                case "AAlarge":
                  r = a >= 3;
                  break;
                case "AAAsmall":
                  r = a >= 7;
              }
              return r;
            }),
            (o.mostReadable = function (t, e, n) {
              var i,
                r,
                a,
                s,
                c = null,
                l = 0;
              (r = (n = n || {}).includeFallbackColors),
                (a = n.level),
                (s = n.size);
              for (var u = 0; u < e.length; u++)
                (i = o.readability(t, e[u])) > l && ((l = i), (c = o(e[u])));
              return o.isReadable(t, c, { level: a, size: s }) || !r
                ? c
                : ((n.includeFallbackColors = !1),
                  o.mostReadable(t, ["#fff", "#000"], n));
            });
          var B = (o.names = {
              aliceblue: "f0f8ff",
              antiquewhite: "faebd7",
              aqua: "0ff",
              aquamarine: "7fffd4",
              azure: "f0ffff",
              beige: "f5f5dc",
              bisque: "ffe4c4",
              black: "000",
              blanchedalmond: "ffebcd",
              blue: "00f",
              blueviolet: "8a2be2",
              brown: "a52a2a",
              burlywood: "deb887",
              burntsienna: "ea7e5d",
              cadetblue: "5f9ea0",
              chartreuse: "7fff00",
              chocolate: "d2691e",
              coral: "ff7f50",
              cornflowerblue: "6495ed",
              cornsilk: "fff8dc",
              crimson: "dc143c",
              cyan: "0ff",
              darkblue: "00008b",
              darkcyan: "008b8b",
              darkgoldenrod: "b8860b",
              darkgray: "a9a9a9",
              darkgreen: "006400",
              darkgrey: "a9a9a9",
              darkkhaki: "bdb76b",
              darkmagenta: "8b008b",
              darkolivegreen: "556b2f",
              darkorange: "ff8c00",
              darkorchid: "9932cc",
              darkred: "8b0000",
              darksalmon: "e9967a",
              darkseagreen: "8fbc8f",
              darkslateblue: "483d8b",
              darkslategray: "2f4f4f",
              darkslategrey: "2f4f4f",
              darkturquoise: "00ced1",
              darkviolet: "9400d3",
              deeppink: "ff1493",
              deepskyblue: "00bfff",
              dimgray: "696969",
              dimgrey: "696969",
              dodgerblue: "1e90ff",
              firebrick: "b22222",
              floralwhite: "fffaf0",
              forestgreen: "228b22",
              fuchsia: "f0f",
              gainsboro: "dcdcdc",
              ghostwhite: "f8f8ff",
              gold: "ffd700",
              goldenrod: "daa520",
              gray: "808080",
              green: "008000",
              greenyellow: "adff2f",
              grey: "808080",
              honeydew: "f0fff0",
              hotpink: "ff69b4",
              indianred: "cd5c5c",
              indigo: "4b0082",
              ivory: "fffff0",
              khaki: "f0e68c",
              lavender: "e6e6fa",
              lavenderblush: "fff0f5",
              lawngreen: "7cfc00",
              lemonchiffon: "fffacd",
              lightblue: "add8e6",
              lightcoral: "f08080",
              lightcyan: "e0ffff",
              lightgoldenrodyellow: "fafad2",
              lightgray: "d3d3d3",
              lightgreen: "90ee90",
              lightgrey: "d3d3d3",
              lightpink: "ffb6c1",
              lightsalmon: "ffa07a",
              lightseagreen: "20b2aa",
              lightskyblue: "87cefa",
              lightslategray: "789",
              lightslategrey: "789",
              lightsteelblue: "b0c4de",
              lightyellow: "ffffe0",
              lime: "0f0",
              limegreen: "32cd32",
              linen: "faf0e6",
              magenta: "f0f",
              maroon: "800000",
              mediumaquamarine: "66cdaa",
              mediumblue: "0000cd",
              mediumorchid: "ba55d3",
              mediumpurple: "9370db",
              mediumseagreen: "3cb371",
              mediumslateblue: "7b68ee",
              mediumspringgreen: "00fa9a",
              mediumturquoise: "48d1cc",
              mediumvioletred: "c71585",
              midnightblue: "191970",
              mintcream: "f5fffa",
              mistyrose: "ffe4e1",
              moccasin: "ffe4b5",
              navajowhite: "ffdead",
              navy: "000080",
              oldlace: "fdf5e6",
              olive: "808000",
              olivedrab: "6b8e23",
              orange: "ffa500",
              orangered: "ff4500",
              orchid: "da70d6",
              palegoldenrod: "eee8aa",
              palegreen: "98fb98",
              paleturquoise: "afeeee",
              palevioletred: "db7093",
              papayawhip: "ffefd5",
              peachpuff: "ffdab9",
              peru: "cd853f",
              pink: "ffc0cb",
              plum: "dda0dd",
              powderblue: "b0e0e6",
              purple: "800080",
              rebeccapurple: "663399",
              red: "f00",
              rosybrown: "bc8f8f",
              royalblue: "4169e1",
              saddlebrown: "8b4513",
              salmon: "fa8072",
              sandybrown: "f4a460",
              seagreen: "2e8b57",
              seashell: "fff5ee",
              sienna: "a0522d",
              silver: "c0c0c0",
              skyblue: "87ceeb",
              slateblue: "6a5acd",
              slategray: "708090",
              slategrey: "708090",
              snow: "fffafa",
              springgreen: "00ff7f",
              steelblue: "4682b4",
              tan: "d2b48c",
              teal: "008080",
              thistle: "d8bfd8",
              tomato: "ff6347",
              turquoise: "40e0d0",
              violet: "ee82ee",
              wheat: "f5deb3",
              white: "fff",
              whitesmoke: "f5f5f5",
              yellow: "ff0",
              yellowgreen: "9acd32",
            }),
            H = (o.hexNames = (function (t) {
              var e = {};
              for (var n in t) t.hasOwnProperty(n) && (e[t[n]] = n);
              return e;
            })(B)),
            j = (function () {
              var t = "(?:[-\\+]?\\d*\\.\\d+%?)|(?:[-\\+]?\\d+%?)",
                e =
                  "[\\s|\\(]+(" +
                  t +
                  ")[,|\\s]+(" +
                  t +
                  ")[,|\\s]+(" +
                  t +
                  ")\\s*\\)?",
                n =
                  "[\\s|\\(]+(" +
                  t +
                  ")[,|\\s]+(" +
                  t +
                  ")[,|\\s]+(" +
                  t +
                  ")[,|\\s]+(" +
                  t +
                  ")\\s*\\)?";
              return {
                CSS_UNIT: new RegExp(t),
                rgb: new RegExp("rgb" + e),
                rgba: new RegExp("rgba" + n),
                hsl: new RegExp("hsl" + e),
                hsla: new RegExp("hsla" + n),
                hsv: new RegExp("hsv" + e),
                hsva: new RegExp("hsva" + n),
                hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
                hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
                hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
                hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
              };
            })();
          void 0 !== t && t.exports
            ? (t.exports = o)
            : void 0 !==
                (i = function () {
                  return o;
                }.call(e, n, e, t)) && (t.exports = i);
        })(Math);
      },
      function (t, e) {
        ((e = t.exports =
          function (t) {
            return t.replace(/^\s*|\s*$/g, "");
          }).left = function (t) {
          return t.replace(/^\s*/, "");
        }),
          (e.right = function (t) {
            return t.replace(/\s*$/, "");
          });
      },
      function (t, e) {
        var n;
        n = (function () {
          return this;
        })();
        try {
          n = n || Function("return this")() || (0, eval)("this");
        } catch (t) {
          "object" == typeof window && (n = window);
        }
        t.exports = n;
      },
      function (t, e, n) {
        "use strict";
        function i(t) {
          return t && t.__esModule ? t : { default: t };
        }
        function r() {
          var t =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
          "" === t &&
            ((t = "Settings"), u.length > 0 && (t += " " + (u.length + 1)));
          var e = new s.default(t);
          return u.push(e), e.appendTo(p), e;
        }
        function o(t) {
          return t < u.length ? u[t] : null;
        }
        function a() {
          return o(0) || r();
        }
        var s = i(n(10)),
          c = i((i(n(6)), n(9))),
          l = n(0);
        n(11);
        var u = [],
          h = (0, l.createElement)("div", "guigui"),
          p = (0, l.createElement)("div", "guigui-container"),
          d = new c.default(p, "guigui-container");
        (0, l.appendElement)(h),
          (0, l.appendElement)(p, h),
          d.appendTo(h),
          (t.exports = {
            addPanel: r,
            addFolder: function () {
              var t;
              return (t = a()).addFolder.apply(t, arguments);
            },
            add: function () {
              var t;
              return (t = a()).add.apply(t, arguments);
            },
            addColor: function () {
              var t;
              return (t = a()).addColor.apply(t, arguments);
            },
            addColorPicker: function () {
              var t;
              return (t = a()).addColor.apply(t, arguments);
            },
            getPanel: o,
          });
      },
    ]),
    rt = {};
  Object.defineProperty(rt, "__esModule", { value: !0 }), (rt.gui = void 0);
  var ot = (function (t) {
    return t && t.__esModule ? t : { default: t };
  })(it);
  rt.gui = ot.default.addPanel("SETTINGS");
  var at = v(D),
    st = v(x),
    ct = v(Q),
    lt = v(B),
    ut = document.body,
    ht = new U.WebGLRenderer({ antialias: !0 });
  ht.setClearColor(3289650),
    (ut.style.overflow = "hidden"),
    (ut.style.margin = 0),
    ut.appendChild(ht.domElement);
  var pt = new U.Scene(),
    dt = new U.PerspectiveCamera(
      50,
      st.default.width / st.default.height,
      0.1,
      1e5
    ),
    ft = new lt.default(dt, {
      element: ht.domElement,
      parent: ht.domElement,
      distance: 1500,
      phi: 0.5 * Math.PI,
    }),
    mt = new U.PointLight(16777215, 1);
  pt.add(mt), mt.position.set(0, -1e3, 150);
  var gt = new ct.default();
  pt.add(gt),
    st.default.addListener(function () {
      (dt.aspect = st.default.width / st.default.height),
        dt.updateProjectionMatrix(),
        ht.setSize(st.default.width, st.default.height);
    }),
    (0, at.default)(function (t) {
      gt.update(ht, t), ft.update(), ht.render(pt, dt);
    }).start(),
    rt.gui.add(gt, "strength", { min: 0, max: 15, step: 0.01 }),
    rt.gui.add(gt, "level", { min: 0, max: 10, step: 0.01 }),
    rt.gui.add(gt, "amplitude", { min: 0, max: 1e3, step: 1 }),
    rt.gui.add(gt, "isSobel"),
    rt.gui.add(gt, "isFBM"),
    rt.gui.add(gt, "offset", { min: 0, max: 1e3, step: 0.1 }),
    rt.gui.add(gt, "total", { min: 0, max: 1e3, step: 0.1 }),
    rt.gui.add(mt.position, "x", { min: -1e3, max: 1e3, label: "light.x" }),
    rt.gui.add(mt.position, "y", { min: -1e3, max: 1e3, label: "light.y" }),
    rt.gui.add(mt.position, "z", { min: -1e3, max: 1e3, label: "light.z" }),
    rt.gui.add(gt.material, "metalness", { min: 0, max: 1, step: 0.1 }),
    rt.gui.add(gt.material, "roughness", { min: 0, max: 1, step: 0.1 }),
    rt.gui.add(gt.material, "envMapIntensity", { min: 0, max: 1, step: 0.1 }),
    rt.gui.add(ft, "distance", { min: 0, max: 1e4, step: 0.1, watch: !0 });
})();
